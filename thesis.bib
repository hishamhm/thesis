% This file was created with JabRef 2.10.
% Encoding: UTF8


@InProceedings{DBLP:journals/corr/LeinoW14,
  Title                    = {The Dafny Integrated Development Environment},
  Author                   = {K. Rustan M. Leino and
 Valentin W{\"{u}}stholz},
  Booktitle                = {Proceedings 1st Workshop on Formal Integrated Development Environment,
 {F-IDE} 2014, Grenoble, France, April 6, 2014.},
  Year                     = {2014},
  Pages                    = {3--15},

  Bibsource                = {dblp computer science bibliography, http://dblp.org},
  Biburl                   = {http://dblp.uni-trier.de/rec/bib/journals/corr/LeinoW14},
  Crossref                 = {DBLP:journals/corr/DuboisGM14},
  Doi                      = {10.4204/EPTCS.149.2},
  File                     = {:Users/hisham/ac/dr/reading/pdf/The_Dafny_Integrated_Development_Environment.pdf:PDF},
  Owner                    = {hisham},
  Review                   = {Integration of Z3-based verifier for the Dafny language into Visual Studio.
UI shows progress of verifier to give user feedback.
Challenges are in making the process interactive given that verification is computationally expensive.},
  Timestamp                = {2014-05-02},
  Url                      = {http://dx.doi.org/10.4204/EPTCS.149.2}
}

@Book{Abelson1996SICP,
  Title                    = {Structure and Interpretation of Computer Programs},
  Author                   = {Abelson, Harold and Sussman, Gerald Jay and Sussman, Julie},
  ISBN                     = {0-262-51087-1},
  Publisher                = {MIT Press},
  Year                     = {1996},
  Edition                  = {2},
  Series                   = {Electrical Engineering and Computer Science Series},

  Owner                    = {hisham},
  Timestamp                = {2016-01-25},
  Url                      = {https://mitpress.mit.edu/sicp/full-text/book/book.html}
}

@InProceedings{Abraham:2006:TIS:1140335.1140346,
  Title                    = {Type Inference for Spreadsheets},
  Author                   = {Abraham, Robin and Erwig, Martin},
  Booktitle                = {Proceedings of the 8th ACM SIGPLAN International Conference on Principles and Practice of Declarative Programming},
  Year                     = {2006},

  Address                  = {New York, NY, USA},
  Pages                    = {73--84},
  Publisher                = {ACM},
  Series                   = {PPDP '06},

  Abstract                 = {Spreadsheets are the most popular programming systems in use today. Since spreadsheets are visual, first-order functional languages, research into the foundations of spreadsheets is therefore a highly relevant topic for the principles and, in particular, the practice, of declarative programming.Since the error rate in spreadsheets is very high and since those errors have significant impact, methods and tools that can help detect and remove errors from spreadsheets are very much needed. Type systems have traditionally played a strong role in detecting errors in programming languages, and it is therefore reasonable to ask whether type systems could not be helpful in improving the current situation of spreadsheet programming.In this paper we introduce a type system and a type inference algorithm for spreadsheets and demonstrate how this algorithm and the underlying typing concept can identify programming errors in spreadsheets. In addition, we also demonstrate how the type inference algorithm can be employed to infer models, or specifications, for spreadsheets, which can be used to prevent future errors in spreadsheets.},
  Acmid                    = {1140346},
  Doi                      = {10.1145/1140335.1140346},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Type_Inference_for_Spreadsheets.pdf:PDF},
  ISBN                     = {1-59593-388-3},
  Keywords                 = {end-user software engineering, templates, type inference},
  Location                 = {Venice, Italy},
  Numpages                 = {12},
  Owner                    = {hisham},
  Review                   = {Includes static semantics for Spreadsheets.},
  Timestamp                = {2015-11-25},
  Url                      = {http://doi.acm.org/10.1145/1140335.1140346}
}

@InProceedings{Acher2014Metamorphic,
  Title                    = {Metamorphic Domain-Specific Languages - A Journey Into the Shapes of a Language},
  Author                   = {Acher, Mathieu and Combemale, Benoit and Collet, Philippe},
  Booktitle                = {Proceedings of the 2014 ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming \&\#38; Software},
  Year                     = {2014},

  Address                  = {New York, NY, USA},
  Pages                    = {243--254},
  Publisher                = {ACM},
  Series                   = {Onward! '14},

  Abstract                 = {External or internal domain-specific languages (DSLs) or (fluent) APIs? Whoever you are – a developer or a user of a DSL – you usually have to choose side; you should not! What about metamorphic DSLs that change their shape according to your needs? Our 4-years journey of providing the "right" support (in the domain of feature modeling), led us to develop an external DSL, different shapes of an internal API, and maintain all these languages. A key insight is that there is no one-size-fits-all solution or no clear superiority of a solution compared to another. On the contrary, we found that it does make sense to continue the maintenance of an external and internal DSL. Based on our experience and on an analysis of the DSL engineering field, the vision that we foresee for the future of software languages is their ability to be self-adaptable to the most appropriate shape (including the corresponding integrated development environment) according to a particular usage or task. We call metamorphic DSL such a language, able to change from one shape to another shape.},
  Location                 = {Portland, Oregon, USA},
  Owner                    = {hisham},
  Review                   = {Advocates the design of DSLs that allow the same language to be used with different syntactic frontends for different purposes.
Explores the difference between external DSLs, internal DSLs and fluent APIs.
Ideally, one could be able to move from one "shape" of the language to another
(which is particularly difficult with internal DSLs and fluent APIs, due to being inserted
in (or actually being) another language's code).},
  Timestamp                = {2014-12-16}
}

@Manual{vee93userguide,
  Title                    = {{VEE 9.3 User's Guide}},
  Author                   = {{Agilent Technologies}},
  Year                     = {2011},

  Owner                    = {hisham},
  Timestamp                = {2017-01-12}
}

@InBook{Ahmad2003TypeSystemSpreadsheet,
  Title                    = {A type system for statically detecting spreadsheet errors},
  Author                   = {Y. Ahmad and T. Antoniu and S. Goldwater and S. Krishnamurthi},
  Pages                    = {174--183},
  Year                     = {2003},
  Month                    = {10},

  Abstract                 = {We describe a methodology for detecting user errors in spreadsheets, using the notion of units as our basic elements of checking. We define the concept of a header and discuss two types of relationships between headers, namely is-a and has-a relationships. With these, we develop a set of rules to assign units to cells in the spreadsheet. We check for errors by ensuring that every cell has a well-formed unit. We describe an implementation of the system that allows the user to check Microsoft Excel spreadsheets. We have run our system on practical examples, and even found errors in published spreadsheets.},
  Booktitle                = {Automated Software Engineering, 2003. Proceedings. 18th IEEE International Conference on},
  Doi                      = {10.1109/ASE.2003.1240305},
  ISBN                     = {0-7695-2035-9},
  Owner                    = {hisham},
  Review                   = {infers types of columns based on headers
has found an error in a spreadsheet presented in a book containing examples of spreadsheets in science and engineering},
  Timestamp                = {2016-01-18}
}

@InProceedings{AivaloglouXLGrammar2015,
  Title                    = {A grammar for spreadsheet formulas evaluated on two large datasets},
  Author                   = {E. Aivaloglou and D. Hoepelman and F. Hermans},
  Booktitle                = {Source Code Analysis and Manipulation (SCAM), 2015 IEEE 15th International Working Conference on},
  Year                     = {2015},
  Month                    = {Sept},
  Pages                    = {121-130},

  Abstract                 = {Spreadsheets are ubiquitous in the industrial world and often perform a role similar to other computer programs, which makes them interesting research targets. However, there does not exist a reliable grammar that is concise enough to facilitate formula parsing and analysis and to support research on spreadsheet codebases. This paper presents a grammar for spreadsheet formulas that is compatible with the spreadsheet formula language, is compact enough to feasibly implement with a parser generator, and produces parse trees aimed at further manipulation and analysis. We evaluate the grammar against more than one million unique formulas extracted from the well known EUSES and Enron spreadsheet datasets, successfully parsing 99.99%. Additionally, we utilize the grammar to analyze these datasets and measure the frequency of usage of language features in spreadsheet formulas. Finally, we identify smelly constructs and uncommon cases in the syntax of formulas.},
  Doi                      = {10.1109/SCAM.2015.7335408},
  Keywords                 = {context-free grammars;spreadsheet programs;EUSES;computer program;context-free grammars;parser generator;spreadsheet formula language;Arrays;Generators;Grammar;Indexes;Production;Spreadsheet programs;Syntactics},
  Owner                    = {hisham},
  Timestamp                = {2016-07-01}
}

@InBook{Arvedsen2015,
  Title                    = {Nordic Contributions in IS Research: 6th Scandinavian Conference on Information Systems, SCIS 2015, Oulu, Finland, August 9-12, 2015, Proceedings},
  Author                   = {Arvedsen, Mikkel
and Langergaard, Jonas
and Vollstedt, Jens
and Obwegeser, Nikolaus},
  Chapter                  = {Chances and Limits of End-User Development: A Conceptual Model},
  Editor                   = {Oinas-Kukkonen, Harri
and Iivari, Netta
and Kuutti, Kari
and {\"O}{\"o}rni, Anssi
and Rajanen, Mikko},
  Pages                    = {208--219},
  Publisher                = {Springer International Publishing},
  Year                     = {2015},

  Address                  = {Cham},

  __markedentry            = {[hisham:1]},
  Abstract                 = {Information systems development has seen many trends and hypes on the way from unstructured, unplanned scripting-like software development, via early methods like the waterfall model, heavy plan-based methods like the RUP to finally arrive at today’s state-of-the-art agile methods like SCRUM. This paper looks at what seems to be a recent trend in (agile) software development: End-User Development (EUD). EUD can be seen both as the logical next step to intensified user integration as proposed in many agile methods as well as a radically new approach to not only interact with but rather empower end-users to (partially) design and create themselves. As in many emerging research areas, EUD lacks clear definitions, concepts and a common understanding of its prospects and limits to both researchers and practitioners. Consequently, this paper aims to address these shortfalls and highlights implications for practice by building a conceptual model of EUD application.},
  Doi                      = {10.1007/978-3-319-21783-3_15},
  ISBN                     = {978-3-319-21783-3},
  Owner                    = {hisham},
  Timestamp                = {2016-02-04},
  Url                      = {http://dx.doi.org/10.1007/978-3-319-21783-3_15}
}

@InProceedings{Arvind:1977:IMD:800214.806559,
  Title                    = {Indeterminacy, Monitors, and Dataflow},
  Author                   = {Arvind and Gostelow, Kim P. and Plouffe, Wil},
  Booktitle                = {Proceedings of the Sixth ACM Symposium on Operating Systems Principles},
  Year                     = {1977},

  Address                  = {New York, NY, USA},
  Pages                    = {159--169},
  Publisher                = {ACM},
  Series                   = {SOSP '77},

  __markedentry            = {[hisham:1]},
  Abstract                 = {The work described in this paper began with a desire to include some linguistic concept of a resource manager within a dataflow language we have been designing [AGP76]. In doing so, we discovered that dataflow monitors (resource managers) provide a natural way of thinking about resources and especially their scheduling. Dataflow semantics are based upon a program composed of asynchronous operators interconnected by lines along which data tokens (messages) flow, such that when all of the input tokens for a given operator have arrived then that operator may fire (execute) by absorbing the input tokens, computing, and producing an output token as its result. These operations closely match one's intuitive model of resource managers (operators) passing signals (tokens) to one another for the purpose of synchronizing and scheduling resource usage. Previously though, dataflow languages [D73, K73, W75] have dealt only with the expression of highly asynchronous yet determinate computations; however, resource management characteristically involves indeterminate computation. The introduction here of dataflow monitors and an explicit nondeterministic merge operator for dataflow streams makes dataflow very well suited for expressing interprocess communication and operations on resources.},
  Acmid                    = {806559},
  Doi                      = {10.1145/800214.806559},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Indeterminacy__Monitors__and_Dataflow.pdf:PDF},
  Location                 = {West Lafayette, Indiana, USA},
  Numpages                 = {11},
  Owner                    = {hisham},
  Timestamp                = {2016-01-21},
  Url                      = {http://doi.acm.org/10.1145/800214.806559}
}

@Article{Ashcroft:1977:LNL:359636.359715,
  Title                    = {Lucid, a Nonprocedural Language with Iteration},
  Author                   = {Ashcroft, E. A. and Wadge, W. W.},
  Journal                  = {Commun. ACM},
  Year                     = {1977},

  Month                    = {jul},
  Number                   = {7},
  Pages                    = {519--526},
  Volume                   = {20},

  Abstract                 = {Lucid is a formal system in which programs can be written and proofs of programs carried out. The proofs are particularly easy to follow and straightforward to produce because the statements in a Lucid program are simply axioms from which the proof proceeds by (almost) conventional logical reasoning, with the help of a few axioms and rules of inference for the special Lucid functions. As a programming language, Lucid is unconventional because, among other things, the order of statements is irrelevant and assignment statements are equations. Nevertheless, Lucid programs need not look much different than iterative programs in a conventional structured programming language using assignment and conditional statements and loops.},
  Acmid                    = {359715},
  Address                  = {New York, NY, USA},
  Doi                      = {10.1145/359636.359715},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Lucid__a_Nonprocedural_Language_with_Iteration.pdf:PDF},
  ISSN                     = {0001-0782},
  Issue_date               = {July 1977},
  Keywords                 = {formal systems, iteration, program proving, semantics, structured programming},
  Numpages                 = {8},
  Owner                    = {hisham},
  Publisher                = {ACM},
  Timestamp                = {2016-01-11},
  Url                      = {http://doi.acm.org/10.1145/359636.359715}
}

@Misc{ATTUnixFilm1982,
  Title                    = {{UNIX}: Making Computers Easier To Use},

  Author                   = {{AT\&T}},
  HowPublished             = {AT\&T Archives Film},
  Year                     = {1982},

  Keywords                 = {UNIX, film},
  Owner                    = {hisham},
  Review                   = {Source of this quote

“What we wanted to preserve was not just a good programming environment in which to do programming, but a system around which a community could form, a fellowship. We knew from experience that the essence of communal computing, as supplied by remote-access time-sharing systems, is not just to type programs into a terminal instead of a key-punch, but to encourage close communication.” — Dennis Ritchie, 1982.},
  Timestamp                = {2015-03-08},
  Url                      = {https://www.youtube.com/watch?v=XvDZLjaCJuw}
}

@Article{Avron1994,
  Title                    = {Stability, Sequentiality and Demand Driven Evaluation in Dataflow},
  Author                   = {Avron, Arnon
and Sasson, Nada},
  Journal                  = {Formal Aspects of Computing},
  Year                     = {1994},
  Number                   = {6},
  Pages                    = {620--642},
  Volume                   = {6},

  Abstract                 = {We show that a given dataflow language l has the property that for any program P and any demand for outputs D (which can be satisfied) there exists a least partial computation of P which satisfies D, iff all the operators of l are stable. This minimal computation is the demand-driven evaluation of P. We also argue that in order to actually implement this mode of evaluation, the operators of l should be further restricted to be effectively sequential ones.},
  Doi                      = {10.1007/BF03259389},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Stability_Sequentiality_and_Demand_Driven_Evaluation_in_Dataflow.pdf:PDF},
  ISSN                     = {1433-299X},
  Owner                    = {hisham},
  Review                   = {discussion of demand-driven dataflow for stream (Lustre-style) languages},
  Timestamp                = {2017-01-12},
  Url                      = {http://dx.doi.org/10.1007/BF03259389}
}

@Article{Badros:2001:CLA:504704.504705,
  Title                    = {The Cassowary Linear Arithmetic Constraint Solving Algorithm},
  Author                   = {Badros, Greg J. and Borning, Alan and Stuckey, Peter J.},
  Journal                  = {ACM Trans. Comput.-Hum. Interact.},
  Year                     = {2001},

  Month                    = {dec},
  Number                   = {4},
  Pages                    = {267--306},
  Volume                   = {8},

  __markedentry            = {[hisham:1]},
  Abstract                 = {Linear equality and inequality constraints arise naturally in specifying many aspects of user interfaces, such as requiring that one window be to the left of another, requiring that a pane occupy the leftmost third of a window, or preferring that an object be contained within a rectangle if possible. Previous constraint solvers designed for user interface applications cannot handle simultaneous linear equations and inequalities efficiently. This is a major limitation, as such systems of constraints arise often in natural declarative specifications. We describe Cassowary---an incremental algorithm based on the dual simplex method, which can solve such systems of constraints efficiently. We have implemented the algorithm as part of a constraint-solving toolkit. We discuss the implementation of the toolkit, its application programming interface, and its performance.},
  Acmid                    = {504705},
  Address                  = {New York, NY, USA},
  Doi                      = {10.1145/504704.504705},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Cassowary.pdf:PDF},
  ISSN                     = {1073-0516},
  Issue_date               = {December 2001},
  Keywords                 = {Cassowary, constraint-solving toolkit, constraints, user interface},
  Numpages                 = {40},
  Owner                    = {hisham},
  Publisher                = {ACM},
  Timestamp                = {2016-01-25},
  Url                      = {http://doi.acm.org/10.1145/504704.504705}
}

@Article{Barkati:2013:SPA:2543581.2543591,
  Title                    = {Synchronous Programming in Audio Processing: A Lookup Table Oscillator Case Study},
  Author                   = {Barkati, Karim and Jouvelot, Pierre},
  Journal                  = {ACM Comput. Surv.},
  Year                     = {2013},

  Month                    = {dec},
  Number                   = {2},
  Pages                    = {24:1--24:35},
  Volume                   = {46},

  Abstract                 = {The adequacy of a programming language to a given software project or application domain is often considered a key factor of success in software development and engineering, even though little theoretical or practical information is readily available to help make an informed decision. In this article, we address a particular version of this issue by comparing the adequacy of general-purpose synchronous programming languages to more Domain-Specific Languages (DSLs) in the field of computer music. More precisely, we implemented and tested the same lookup table oscillator example program, one of the most classical algorithms for sound synthesis, using a selection of significant synchronous programming languages, half of which designed as specific music languages—Csound, Pure Data, SuperCollider, ChucK, Faust—and the other half being general synchronous formalisms—Signal, Lustre, Esterel, Lucid Synchrone and C with the OpenMP Stream Extension (Matlab/Octave is used for the initial specification). The advantages of these two approaches are discussed, providing insights to language designers and possibly software developers of both communities regarding programming languages design for the audio domain.},
  Acmid                    = {2543591},
  Address                  = {New York, NY, USA},
  Articleno                = {24},
  Doi                      = {10.1145/2543581.2543591},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Synchronous_Programming_in_Audio_Processing__A_Lookup_Table_Oscillator_Case_Study.pdf:PDF},
  ISSN                     = {0360-0300},
  Issue_date               = {November 2013},
  Keywords                 = {Synchronous programming languages, computer music, music programming languages, signal processing, timing},
  Numpages                 = {35},
  Owner                    = {hisham},
  Publisher                = {ACM},
  Review                   = {researchers from the Faust group compare writing the same wavetable oscillator in 10 languages (5 for music, 5 are general-purpose synchronous languages).},
  Timestamp                = {2015-10-06},
  Url                      = {http://doi.acm.org/10.1145/2543581.2543591}
}

@Article{ee1999labview_vs_vee,
  Title                    = {Evaluation of LabVIEW 5.0 and HP VEE 5.0 - Part 2},
  Author                   = {Ed Baroth and Chris Hartsough and Amy Holst and George Wells},
  Journal                  = {EE, Evaluation Engineering},
  Year                     = {1999},

  Month                    = {may},
  Number                   = {5},
  Pages                    = {5},
  Volume                   = {38},

  Abstract                 = {The features and shortcomings of LabVIEW version 5.0 and Hewlett-Packard's Visual Engineering Environment (VEE) version 5.0 graphical programming languages are discussed. LabVIEW 5.0 and HP VEE 5.0 have both data acquisition, analysis and operations display, and Active X and web processing. They both use graphical programming, but they do it differently, and can offer productivity improvements of up to 10 times conventional programming. For use with PC-based interface cards, the industry seems to have selected LabVIEW over HP VEE, primarily because LabVIEW permits the control of cards effectively. The focus of HP VEE has been and remains on controlling fully capable instruments that connect to computers using GPIB or RS-232.},
  Owner                    = {hisham},
  Review                   = {comparison between LabVIEW and VEE. Says that "LabVIEW follows the data-flow paradigm of programming rigorously. HP VEE is loosely based on data-flow diagrams with a large measure of flow-charting sprinkled with a little decision table. "},
  Timestamp                = {2017-01-12}
}

@InProceedings{Barowy:2014:CDD:2660193.2660207,
  Title                    = {CheckCell: Data Debugging for Spreadsheets},
  Author                   = {Barowy, Daniel W. and Gochev, Dimitar and Berger, Emery D.},
  Booktitle                = {Proceedings of the 2014 ACM International Conference on Object Oriented Programming Systems Languages \& Applications},
  Year                     = {2014},

  Address                  = {New York, NY, USA},
  Pages                    = {507--523},
  Publisher                = {ACM},
  Series                   = {OOPSLA '14},

  Acmid                    = {2660207},
  Doi                      = {10.1145/2660193.2660207},
  File                     = {:Users/hisham/ac/dr/reading/pdf/CheckCell__Data_Debugging_for_Spreadsheets.pdf:PDF},
  ISBN                     = {978-1-4503-2585-1},
  Keywords                 = {data-debugging, debugging, errors, inputs, spreadsheets},
  Location                 = {Portland, Oregon, USA},
  Numpages                 = {17},
  Owner                    = {hisham},
  Review                   = {Top ten functions used in corpus of spreadsheets includes OFFSET and INDEX, which can calculate references to other cells.},
  Timestamp                = {2016-01-16},
  Url                      = {http://doi.acm.org/10.1145/2660193.2660207}
}

@InProceedings{Beaudouin-Lafon:1988:ISM:62453.62492,
  Title                    = {Iconic Shells for Multitasking Workstations},
  Author                   = {Beaudouin-Lafon, Michel and Karsenty, Solange},
  Booktitle                = {Proceedings of the 1988 ACM SIGSMALL/PC Symposium on ACTES},
  Year                     = {1988},

  Address                  = {New York, NY, USA},
  Pages                    = {187--196},
  Publisher                = {ACM},
  Series                   = {SIGSMALL '88},

  Abstract                 = {Today's workstations running a multitasking operating system provide high level graphics toward user friendly interfaces. Microcomputers, on their side, implement graphic interfaces on monotasking operating systems. There are two differences between these machines: the operating system and the user interface to this operating system (the shell). Workstations still use standard shells (textual commands) but through a sophisticated graphic environment as a window manager, while microcomputers have their own graphic shell running on monotasking operating system. In this paper we examine the features of both systems and then we present an iconic shell developed for Unix workstations. This shell differs from existing shells because the interaction language is based on graphic manipulations, and is integrated in a multitasking environment.},
  Acmid                    = {62492},
  Doi                      = {10.1145/62453.62492},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Iconic_Shells_for_Multitasking_Workstations.pdf:PDF},
  ISBN                     = {0-89791-255-1},
  Location                 = {Cannes, France},
  Numpages                 = {10},
  Owner                    = {hisham},
  Review                   = {An old paper where a file manager environment is called an "iconic shell".},
  Timestamp                = {2015-04-14},
  Url                      = {http://doi.acm.org/10.1145/62453.62492}
}

@Article{Bentley:1986:little,
  Title                    = {Programming Pearls: Little Languages},
  Author                   = {Bentley, Jon},
  Journal                  = {Commun. ACM},
  Year                     = {1986},

  Month                    = {aug},
  Number                   = {8},
  Pages                    = {711--721},
  Volume                   = {29},

  Acmid                    = {315691},
  Address                  = {New York, NY, USA},
  Doi                      = {10.1145/6424.315691},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Programming_Pearls__Little_Languages.pdf:PDF},
  ISSN                     = {0001-0782},
  Issue_date               = {Aug. 1986},
  Numpages                 = {11},
  Owner                    = {hisham},
  Publisher                = {ACM},
  Timestamp                = {2015-05-14},
  Url                      = {http://doi.acm.org/10.1145/6424.315691}
}

@Article{Bentley:1986:PPL:5948.315654,
  Title                    = {Programming Pearls: A Literate Program},
  Author                   = {Bentley, Jon and Knuth, Don and McIlroy, Doug},
  Journal                  = {Commun. ACM},
  Year                     = {1986},

  Month                    = {jun},
  Number                   = {6},
  Pages                    = {471--483},
  Volume                   = {29},

  Acmid                    = {315654},
  Address                  = {New York, NY, USA},
  Doi                      = {10.1145/5948.315654},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Programming_Pearls__A_Literate_Program.pdf:PDF},
  ISSN                     = {0001-0782},
  Issue_date               = {June 1986},
  Numpages                 = {13},
  Owner                    = {hisham},
  Publisher                = {ACM},
  Timestamp                = {2014-12-17},
  Url                      = {http://doi.acm.org/10.1145/5948.315654}
}

@InProceedings{Beuvens:2012:DGU:2379057.2379116,
  Title                    = {Designing Graphical User Interfaces Integrating Gestures},
  Author                   = {Beuvens, Fran\c{c}ois and Vanderdonckt, Jean},
  Booktitle                = {Proceedings of the 30th ACM International Conference on Design of Communication},
  Year                     = {2012},

  Address                  = {New York, NY, USA},
  Pages                    = {313--322},
  Publisher                = {ACM},
  Series                   = {SIGDOC '12},

  __markedentry            = {[hisham:1]},
  Acmid                    = {2379116},
  Doi                      = {10.1145/2379057.2379116},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Designing_Graphical_User_Interfaces_Integrating_Gestures.pdf:PDF},
  ISBN                     = {978-1-4503-1497-8},
  Keywords                 = {method engineering, model-driven architecture, pen-based gesture, sketch, user interface},
  Location                 = {Seattle, Washington, USA},
  Numpages                 = {10},
  Owner                    = {hisham},
  Timestamp                = {2015-05-18},
  Url                      = {http://doi.acm.org/10.1145/2379057.2379116}
}

@Article{Bhattacharya:2001:PDM:2197975.2202339,
  Title                    = {Parameterized Dataflow Modeling for DSP Systems},
  Author                   = {Bhattacharya, B. and Bhattacharyya, S.S.},
  Journal                  = {Trans. Sig. Proc.},
  Year                     = {2001},

  Month                    = oct,
  Number                   = {10},
  Pages                    = {2408--2421},
  Volume                   = {49},

  Abstract                 = {Dataflow has proven to be an attractive computation model for programming digital signal processing (DSP) applications. A restricted version of dataflow, termed synchronous dataflow (SDF), that offers strong compile-time predictability properties, but has limited expressive power, has been studied extensively in the DSP context. Many extensions to synchronous dataflow have been proposed to increase its expressivity while maintaining its compile-time predictability properties as much as possible. We proposed a parameterized dataflow framework that can be applied as a meta-modeling technique to significantly improve the expressive power of any dataflow model that possesses a well-defined concept of a graph iteration, Indeed, the parameterized dataflow framework is compatible with many of the existing dataflow models for DSP including SDF, cyclo-static dataflow, scalable synchronous dataflow, and Boolean dataflow. In this paper, we develop precise, formal semantics for parameterized synchronous dataflow (PSDF)-the application of our parameterized modeling framework to SDF-that allows data-dependent, dynamic DSP systems to be modeled in a natural and intuitive fashion. Through our development of PSDF, we demonstrate that desirable properties of a DSP modeling environment such as dynamic reconfigurability and design reuse emerge as inherent characteristics of our parameterized framework. An example of a speech compression application is used to illustrate the efficacy of the PSDF approach and its amenability to efficient software synthesis techniques. In addition, we illustrate the generality of our parameterized framework by discussing its application to cyclo-static dataflow, which is a popular alternative to the SDF model},
  Acmid                    = {2202339},
  Address                  = {Piscataway, NJ, USA},
  Doi                      = {10.1109/78.950795},
  ISSN                     = {1053-587X},
  Issue_date               = {October 2001},
  Numpages                 = {14},
  Owner                    = {hisham},
  Publisher                = {IEEE Press},
  Timestamp                = {2017-03-12},
  Url                      = {http://dx.doi.org/10.1109/78.950795}
}

@InProceedings{Bilsen1995cyclo,
  Title                    = {Cyclo-static data flow},
  Author                   = {G. Bilsen and M. Engels and R. Lauwereins and J. A. Peperstraete},
  Booktitle                = {1995 International Conference on Acoustics, Speech, and Signal Processing},
  Year                     = {1995},
  Month                    = {May},
  Pages                    = {3255-3258 vol.5},
  Volume                   = {5},

  __markedentry            = {[hisham:1]},
  Abstract                 = {The high sample-rates involved in many DSP-applications, require the use of static schedulers wherever possible. The construction of static schedules however is classically limited to applications that fit in the synchronous data flow model. In this paper we present cyclo-static data flow as a model to describe applications with a cyclically changing behaviour. We give both a necessary and sufficient condition for the existence of a static schedule for a cyclo-static data flow graph and show how such a schedule can be constructed. The example of a video encoder is used to illustrate the importance of cyclo-static data flow for real-life DSP-systems},
  Doi                      = {10.1109/ICASSP.1995.479579},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Cyclo-static dataflow.pdf:PDF},
  ISSN                     = {1520-6149},
  Keywords                 = {data flow graphs;processor scheduling;signal sampling;video coding;video equipment;DSP systems;DSP-applications;cyclically changing behaviour;cyclo-static data flow graph;high sample-rates;necessary condition;static schedule;static schedulers;sufficient condition;synchronous data flow model;video encoder;Costs;Digital signal processing;Dynamic scheduling;Emulation;Flow graphs;Hardware;Processor scheduling;Prototypes;Runtime;Sufficient conditions},
  Owner                    = {hisham},
  Timestamp                = {2017-03-12}
}

@InProceedings{Blackwell1999,
  Title                    = {Investment of attention as an analytic approach to cognitive dimensions},
  Author                   = {Blackwell, Alan F and Green, Thomas RG},
  Booktitle                = {Collected Papers of the 11th Annual Workshop of the Psychology of Programming Interest Group (PPIG-11)},
  Year                     = {1999},
  Pages                    = {24--35},

  Keywords                 = {HCI, Cognition, Cognitive Dimensions, Attention},
  Owner                    = {hisham},
  Review                   = {Cognitive dimensions: hidden dependencies, juxtaposition, secondary notation, etc.
Loss of attention in information artifacts - examples: writing a family tree when reading a book; saving a number in quick dial in a telephone.
Investment of attention in programming - looking up an API, when to look for a similar function, refactoring, etc.
Attention economies! (A great quote in the paper, saying that information is not scarce; attention is.)
Experiment with a simulation (process of searching+replacing), Clippy, etc.
Describing notational activities in attentional terms: transcription, incrementation, modification, search.},
  Timestamp                = {2014-09-02}
}

@Book{sunset1982easy,
  Title                    = {Easy Basics for Good Cooking},
  Author                   = {Sunset Books},
  Editor                   = {David E. Clark},
  ISBN                     = {0-376-02093-8},
  Publisher                = {Lane},
  Year                     = {1982},

  Address                  = {Menlo Park, CA},
  Edition                  = {1},

  Keywords                 = {cooking},
  Lccn                     = {82081368},
  Owner                    = {hisham},
  Review                   = {Cooking book that includes examples that is like exception-handling.},
  Timestamp                = {2015-01-14},
  Url                      = {https://books.google.com.br/books?id=NSUCAAAACAAJ}
}

@InProceedings{Borg:1990:IVU:97243.97274,
  Title                    = {IShell: A Visual UNIX Shell},
  Author                   = {Borg, Kjell},
  Booktitle                = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
  Year                     = {1990},

  Address                  = {New York, NY, USA},
  Pages                    = {201--207},
  Publisher                = {ACM},
  Series                   = {CHI '90},

  Acmid                    = {97274},
  Doi                      = {10.1145/97243.97274},
  File                     = {:Users/hisham/ac/dr/reading/pdf/IShell__A_Visual_UNIX_Shell.pdf:PDF},
  ISBN                     = {0-201-50932-6},
  Location                 = {Seattle, Washington, USA},
  Numpages                 = {7},
  Owner                    = {hisham},
  Review                   = {IShell, a visual UNIX shell based on the desktop metaphor
Uses IScript, a visual language based on dataflow graphs
Concept of "machines" ("cat" machine, "wc" machine, "sort", etc.)
Detectors to monitor data flow},
  Timestamp                = {2015-04-14},
  Url                      = {http://doi.acm.org/10.1145/97243.97274}
}

@InProceedings{Boyce:1973:SQR:951762.951765,
  Title                    = {Specifying Queries As Relational Expressions},
  Author                   = {Boyce, R. F. and Chamberlin, D. D. and Hammer, M. M. and King, W. F.},
  Booktitle                = {Proceedings of the 1973 Meeting on Programming Languages and Information Retrieval},
  Year                     = {1973},

  Address                  = {New York, NY, USA},
  Pages                    = {31--47},
  Publisher                = {ACM},
  Series                   = {SIGPLAN '73},

  Abstract                 = {SQUARE (Specifying Queries As Relational Expressions) is a set oriented data sublanguage for expressing queries (access, modification, insertion, and deletion) to a data base consisting of a collection of time-varying relations. The language mimics how people use relations or tables to obtain information. It does not require the sophisticated mathematical machinery of the predicate calculus (bound variables, quantifiers, etc.) in order to express simple references to tables. However, the language has been shown to be complete, i.e., any query expressible in the predicate calculus is expressible in SQUARE.},
  Acmid                    = {951765},
  Doi                      = {10.1145/951762.951765},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Specifying_Queries_As_Relational_Expressions.pdf:PDF},
  Location                 = {Gaithersburg, Maryland},
  Numpages                 = {17},
  Owner                    = {hisham},
  Review                   = {Presents SQUARE, the forerunner of SQL.
SEQUEL (which became SQL) is also presented in a short section as a syntactic variant.},
  Timestamp                = {2014-12-12},
  Url                      = {http://doi.acm.org/10.1145/951762.951765}
}

@Book{brooks2010design,
  Title                    = {The Design of Design: Essays from a Computer Scientist},
  Author                   = {Brooks, Frederick P.},
  ISBN                     = {9780321702067},
  Publisher                = {Pearson Education},
  Year                     = {2010},

  Lccn                     = {2009045215},
  Owner                    = {hisham},
  Timestamp                = {2015-03-09},
  Url                      = {http://books.google.com.br/books?id=0qG4TQi-e-4C}
}

@Book{Brooks1995Mythical,
  Title                    = {The Mythical Man-Month: Essays on Software Engineering, Anniversary Edition (2nd Edition)},
  Author                   = {Brooks, Frederick P.},
  ISBN                     = {0201835959},
  Publisher                = {Addison-Wesley Professional},
  Year                     = {1995},
  Edition                  = {Anniversary},
  Month                    = {aug},

  Abstract                 = {{These essays draw from Brooks' experience as project manager for the IBM System/360 computer family and then for OS/360, its massive software system. Now, 20 years after the initial publication of his book, Brooks has revisited his original ideas and added new thoughts and advice. -- from publisher description}},
  Day                      = {12},
  File                     = {:Users/hisham/ac/dr/reading/pdf/The_Mythical_Man_Month.pdf:PDF},
  HowPublished             = {Paperback},
  Keywords                 = {book, project-managment},
  Owner                    = {hisham},
  Posted-at                = {2007-03-28 16:04:43},
  Timestamp                = {2015-03-08}
}

@PhdThesis{Buck:1993:SDD:921086,
  Title                    = {Scheduling Dynamic Dataflow Graphs with Bounded Memory Using the Token Flow Model},
  Author                   = {Buck, Joseph Tobin},
  Year                     = {1993},
  Note                     = {AAI9431898},

  Abstract                 = {This thesis presents an analytical model of the behavior of dataflow graphs with data-dependent control flow. In this model, the number of tokens produced or consumed by each actor is given as a symbolic function of the Boolean-valued tokens in the system. Several definitions of consistency are discussed and compared. Necessary and sufficient conditions for bounded-length schedules, as well as sufficient conditions for determining whether a dataflow graph can be scheduled in bounded memory are given. These are obtained by analyzing the properties of minimal cyclic schedules, defined as minimal sequences of actor executions that return the dataflow graph to its original state. Additional analysis techniques, including a clustering algorithm that reduces graphs to standard control structures (such as "if-then-else" and "do-while") and a state enumeration procedure, are also described. Relationships between these techniques and those used in Petri net analysis, as well as in the theory of certain stream languages, are discussed.

Finally, an implementation of these techniques using Ptolemy, an object-oriented simulation and software prototyping platform, is described. Given a dynamic dataflow graph, the implementation is capable either of simulating the execution of the graph, or generating efficient code for it (in an assembly language or higher level language).},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Scheduling dynamic dataflow graphs with bounded memory.pdf:PDF},
  Owner                    = {hisham},
  Publisher                = {University of California, Berkeley},
  Review                   = {Boolean Data Flow (BDF)

Cited in \cite{Wipliez2010}},
  Timestamp                = {2017-03-12}
}

@InProceedings{Burlet:2015:ESE:2820518.2820554,
  Title                    = {An Empirical Study of End-user Programmers in the Computer Music Community},
  Author                   = {Burlet, Gregory and Hindle, Abram},
  Booktitle                = {Proceedings of the 12th Working Conference on Mining Software Repositories},
  Year                     = {2015},

  Address                  = {Piscataway, NJ, USA},
  Pages                    = {292--302},
  Publisher                = {IEEE Press},
  Series                   = {MSR '15},

  Abstract                 = {Computer musicians are a community of end-user programmers who often use visual programming languages such as Max/MSP or Pure Data to realize their musical compositions. This research study conducts a multifaceted analysis of the software development practices of computer musicians when programming in these visual music-oriented languages. A statistical analysis of project metadata harvested from software repositories hosted on GitHub reveals that in comparison to the general population of software developers, computer musicians' repositories have less commits, less frequent commits, more commits on weekends, yet similar numbers of bug reports and similar numbers of contributing authors. Analysis of source code in these repositories reveals that the vast majority of code can be reconstructed from duplicate fragments. Finally, these results are corroborated by a survey of computer musicians and interviews with individuals in this end-user community. Based on this analysis and feedback from computer musicians we find that there are many avenues where software engineering can be applied to help aid this community of end-user programmers.},
  Acmid                    = {2820554},
  File                     = {:Users/hisham/ac/dr/reading/pdf/An_Empirical_Study_of_End_user_Programmers_in_the_Computer_Music_Community.pdf:PDF},
  Location                 = {Florence, Italy},
  Numpages                 = {11},
  Owner                    = {hisham},
  Review                   = {A study of Max/MSP and Pure Data patches stored in Github.
Seems to conclude they use Git in a more amateur way (by commit numbers),
despite having similar numbers of bug reports and contributors.
They detect "clones" in patches, but I think the clones they detected
are just typical program statements (akin to finding MIN and MAX macros in C code).
One interesting thing is that they note users reinvent functions already provided.},
  Timestamp                = {2016-01-18},
  Url                      = {http://dl.acm.org/citation.cfm?id=2820518.2820554}
}

@Article{Burnett95ScalingUpVPLs,
  Title                    = {Scaling Up Visual Programming Languages},
  Author                   = {Margaret M. Burnett and Marla J. Baker and Carisa Bohus and Paul Carlson and Sherry Yang and Pieter van Zee},
  Journal                  = {Computer},
  Year                     = {1995},

  Month                    = {mar},
  Number                   = {3},
  Pages                    = {45--54},
  Volume                   = {28},

  __markedentry            = {[hisham:1]},
  Abstract                 = {The directness, immediacy, and simplicity of visual programming languages are appealing. The question is, can VPLs be effectively applied to large-scale programming problems while retaining these characteristics?},
  Doi                      = {10.1109/2.366157},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Scaling_Up_Visual_Programming_Languages.pdf:PDF},
  Owner                    = {hisham},
  Timestamp                = {2017-01-11},
  Url                      = {http://web.engr.oregonstate.edu/~burnett/Scaling/ScalingUp.html}
}

@InBook{Burnett2014EUD,
  Title                    = {The Encyclopedia of Human-Computer Interaction, 2nd Ed.},
  Author                   = {Burnett, Margaret M. and Scaffidi, Christopher},
  Chapter                  = {End-User Development},
  Editor                   = {Soegaard, Mads and Dam, Rikke Friis},
  Publisher                = {The Interaction Design Foundation},
  Year                     = {2014},

  Address                  = {{Aarhus}, {Denmark}},

  Comment                  = {https://www.interaction-design.org/encyclopedia/end-user_development.html},
  Owner                    = {hisham},
  Review                   = {Introduction to End-user Development
History of EUD, cites spreadsheets VisiCalc and Lotus 1-2-3 as seminal examples.
End-user Programming (EUP)
End-user Software Engineering (EUSE)},
  Timestamp                = {2014-12-09}
}

@InCollection{Cappiello2011EUDMashups,
  Title                    = {Enabling End User Development through Mashups: Requirements, Abstractions and Innovation Toolkits},
  Author                   = {Cappiello, Cinzia and Daniel, Florian and Matera, Maristella and Picozzi, Matteo and Weiss, Michael},
  Booktitle                = {End-User Development},
  Publisher                = {Springer Berlin Heidelberg},
  Year                     = {2011},
  Editor                   = {Costabile, MariaFrancesca and Dittrich, Yvonne and Fischer, Gerhard and Piccinno, Antonio},
  Pages                    = {9-24},
  Series                   = {Lecture Notes in Computer Science},
  Volume                   = {6654},

  Doi                      = {10.1007/978-3-642-21530-8_3},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Enabling_End_User_Development_through_Mashups__Requirements__Abstractions_and_Innovation_Toolkits.pdf:PDF},
  ISBN                     = {978-3-642-21529-2},
  Keywords                 = {Web Mashups; End User Development; User-driven Innovation},
  Language                 = {English},
  Owner                    = {hisham},
  Review                   = {The development of modern Web 2.0 applications is increasingly characterized by the involvement of end users with typically limited programming skills. In particular, an emerging practice is the development of web mashups, i.e., applications based on the composition of contents and functions that are accessible via the Web. In this article, we try to explain the ingredients that are needed for end users to become mashup developers, namely adequatemashup tools and lightweight development processes, leveraging on the users’ capability to innovate. We also describe our own solution, the DashMash platform, an example of end-user-oriented mashup platform that tries to fill the gaps that typically prevent end users from fully exploiting the mashup potential as innovation instruments. DashMash offers an intelligible, easy-to-use composition paradigm that enables even inexperienced users to compose own mashups. As confirmed by a user-centric experiment, its paradigm is effective and increases the satisfaction of the end users.},
  Timestamp                = {2015-04-15},
  Url                      = {http://dx.doi.org/10.1007/978-3-642-21530-8_3}
}

@InProceedings{Carver:2006:EET:1159733.1159775,
  Title                    = {An Empirical Evaluation of a Testing and Debugging Methodology for Excel},
  Author                   = {Carver, Jeffrey and Fisher,II, Marc and Rothermel, Gregg},
  Booktitle                = {Proceedings of the 2006 ACM/IEEE International Symposium on Empirical Software Engineering},
  Year                     = {2006},

  Address                  = {New York, NY, USA},
  Pages                    = {278--287},
  Publisher                = {ACM},
  Series                   = {ISESE '06},

  Acmid                    = {1159775},
  Doi                      = {10.1145/1159733.1159775},
  File                     = {:Users/hisham/ac/dr/reading/pdf/An_Empirical_Evaluation_of_a_Testing_and_Debugging_Methodology_for_Excel.pdf:PDF},
  ISBN                     = {1-59593-218-6},
  Keywords                 = {empirical study, end-user software engineering, human subjects},
  Location                 = {Rio de Janeiro, Brazil},
  Numpages                 = {10},
  Owner                    = {hisham},
  Timestamp                = {2016-01-18},
  Url                      = {http://doi.acm.org/10.1145/1159733.1159775}
}

@InProceedings{cervesato2006everyday,
  Title                    = {A Spreadsheet for Everyday Symbolic Reasoning},
  Author                   = {Cervesato, I.},
  Booktitle                = {{AAAI Fall Symposium on Integrating Reasoning into Everyday Applications}},
  Year                     = {2006},

  Address                  = {Menlo Park, CA, USA},
  Month                    = {oct},
  Number                   = {FS-06-04},
  Organization             = {AAAI},
  Pages                    = {1--8},
  Publisher                = {{The AAAI Press}},

  Abstract                 = {We propose a deductive extension of the spreadsheet paradigm as the basis for an automated assistant for the daily reasoning and decision-making needs of computer users, in the same way as a spreadsheet application such as Microsoft Excel assists them every day with calculations simple and complex. Users without formal training in Logic or even Computer Science can interactively define logical rules in the same simple way as they define formulas in Excel. These rules are immediately evaluated thereby returning lists of values that satisfy them, again just like with numerical formulas. The deductive component is seamlessly integrated into the traditional spreadsheet so that a user not only still has access to the usual functionalities, but is able to mix deductive reasoning and numerical calculation.},
  Institution              = {The AAAI Press},
  Owner                    = {hisham},
  Review                   = {States that array formulas do not increase the expressiveness of scalar spreadsheets.},
  Timestamp                = {2016-03-22}
}

@InProceedings{Chamberlin:1974:SSE:800296.811515,
  Title                    = {SEQUEL: A Structured English Query Language},
  Author                   = {Chamberlin, Donald D. and Boyce, Raymond F.},
  Booktitle                = {Proceedings of the 1974 ACM SIGFIDET (Now SIGMOD) Workshop on Data Description, Access and Control},
  Year                     = {1974},

  Address                  = {New York, NY, USA},
  Pages                    = {249--264},
  Publisher                = {ACM},
  Series                   = {SIGFIDET '74},

  Abstract                 = {In this paper we present the data manipulation facility for a structured English query language (SEQUEL) which can be used for accessing data in an integrated relational data base. Without resorting to the concepts of bound variables and quantifiers SEQUEL identifies a set of simple operations on tabular structures, which can be shown to be of equivalent power to the first order predicate calculus. A SEQUEL user is presented with a consistent set of keyword English templates which reflect how people use tables to obtain information. Moreover, the SEQUEL user is able to compose these basic templates in a structured manner in order to form more complex queries. SEQUEL is intended as a data base sublanguage for both the professional programmer and the more infrequent data base user.},
  Acmid                    = {811515},
  Doi                      = {10.1145/800296.811515},
  File                     = {:Users/hisham/ac/dr/reading/pdf/SEQUEL__A_Structured_English_Query_Language.pdf:PDF},
  Keywords                 = {Data Base Management Systems, Data Manipulation Languages, Information Retrieval, Query Languages},
  Location                 = {Ann Arbor, Michigan},
  Numpages                 = {16},
  Owner                    = {hisham},
  Review                   = {The paper that introduced SQL (then called SEQUEL) to the world.
Also presents briefly SQUARE, an equivalent language with a more mathematical syntax.},
  Timestamp                = {2014-12-11},
  Url                      = {http://doi.acm.org/10.1145/800296.811515}
}

@InProceedings{Chang:2015:SMH:2702123.2702587,
  Title                    = {A Spreadsheet Model for Handling Streaming Data},
  Author                   = {Chang, Kerry Shih-Ping and Myers, Brad A.},
  Booktitle                = {Proceedings of the 33rd Annual ACM Conference on Human Factors in Computing Systems},
  Year                     = {2015},

  Address                  = {New York, NY, USA},
  Pages                    = {3399--3402},
  Publisher                = {ACM},
  Series                   = {CHI '15},

  __markedentry            = {[hisham:1]},
  Acmid                    = {2702587},
  Doi                      = {10.1145/2702123.2702587},
  File                     = {:Users/hisham/ac/dr/reading/pdf/A_Spreadsheet_Model_for_Handling_Streaming_Data.pdf:PDF},
  ISBN                     = {978-1-4503-3145-6},
  Keywords                 = {end-user programming, live programming, spreadsheets, streaming data, web services},
  Location                 = {Seoul, Republic of Korea},
  Numpages                 = {4},
  Owner                    = {hisham},
  Timestamp                = {2015-05-18},
  Url                      = {http://doi.acm.org/10.1145/2702123.2702587}
}

@Article{Chen2014210,
  Title                    = {VisualTPL: A visual dataflow language for report data transformation },
  Author                   = {Woei-Kae Chen and Pin-Ying Tu},
  Journal                  = {Journal of Visual Languages \& Computing },
  Year                     = {2014},
  Number                   = {3},
  Pages                    = {210 - 226},
  Volume                   = {25},

  __markedentry            = {[hisham:1]},
  Abstract                 = {Abstract Data transformation, an important part of report generation, converts the layout of source data into a new layout suitable for presentation. Many report tools have been developed for end-users to specify data transformation. However, current report tools only support a limited set of report layouts. This paper proposes a visual dataflow programming language, called VisualTPL, to resolve this problem. Data transformation is accomplished by writing graphical dataflow programs, which manipulate tables as first-class objects with a set of extendable table operations. A report tool, called VisualTPS, has been developed to offer an easy and intuitive end-user programming environment. Reports with sophisticated layouts can be created through top-down decomposition and incremental development. An evaluation has been conducted to assess end-users' performance with VisualTPL. The results indicated that end-users could learn VisualTPL in a short time and create complicated report layouts all by themselves. And, in comparison with a commercial report tool, VisualTPL offered end-users similar performances and was preferred over the commercial tool. },
  Doi                      = {http://dx.doi.org/10.1016/j.jvlc.2013.11.003},
  File                     = {:Users/hisham/ac/dr/reading/pdf/VisualTPL__A_visual_dataflow_language_for_report_data_transformation_.pdf:PDF},
  ISSN                     = {1045-926X},
  Keywords                 = {Report generation},
  Owner                    = {hisham},
  Timestamp                = {2016-01-19},
  Url                      = {http://www.sciencedirect.com/science/article/pii/S1045926X13000803}
}

@Book{citrin2007little,
  Title                    = {The Little Black Apron: A Single Girl's Guide to Cooking with Style and Grace},
  Author                   = {Citrin, J. and Gibson, M. and Nunes, K.},
  ISBN                     = {9781598692068},
  Publisher                = {Adams Media},
  Year                     = {2007},

  Lccn                     = {2007018899},
  Owner                    = {hisham},
  Review                   = {cooking example with decision: "if you want a crisper crust".},
  Timestamp                = {2015-01-14},
  Url                      = {https://books.google.com.br/books?id=1Thj5mcoQlMC}
}

@Article{Codd:1970:RMD:362384.362685,
  Title                    = {A Relational Model of Data for Large Shared Data Banks},
  Author                   = {Codd, E. F.},
  Journal                  = {Commun. ACM},
  Year                     = {1970},

  Month                    = {jun},
  Number                   = {6},
  Pages                    = {377--387},
  Volume                   = {13},

  Abstract                 = {Future users of large data banks must be protected from having to know how the data is organized in the machine (the internal representation). A prompting service which supplies such information is not a satisfactory solution. Activities of users at terminals and most application programs should remain unaffected when the internal representation of data is changed and even when some aspects of the external representation are changed. Changes in data representation will often be needed as a result of changes in query, update, and report traffic and natural growth in the types of stored information. Existing noninferential, formatted data systems provide users with tree-structured files or slightly more general network models of the data. In Section 1, inadequacies of these models are discussed. A model based on n-ary relations, a normal form for data base relations, and the concept of a universal data sublanguage are introduced. In Section 2, certain operations on relations (other than logical inference) are discussed and applied to the problems of redundancy and consistency in the user's model.},
  Acmid                    = {362685},
  Address                  = {New York, NY, USA},
  Doi                      = {10.1145/362384.362685},
  File                     = {:Users/hisham/ac/dr/reading/pdf/A_Relational_Model_of_Data_for_Large_Shared_Data_Banks.pdf:PDF},
  ISSN                     = {0001-0782},
  Issue_date               = {June 1970},
  Keywords                 = {composition, consistency, data bank, data base, data integrity, data organization, data structure, derivability, hierarchies of data, join, networks of data, predicate calculus, redundancy, relations, retrieval language, security},
  Numpages                 = {11},
  Owner                    = {hisham},
  Publisher                = {ACM},
  Review                   = {Introduces relational algebra.},
  Timestamp                = {2014-12-12},
  Url                      = {http://doi.acm.org/10.1145/362384.362685}
}

@InCollection{Cooper2006FrTime,
  Title                    = {Embedding Dynamic Dataflow in a Call-by-Value Language},
  Author                   = {Cooper, GregoryH. and Krishnamurthi, Shriram},
  Booktitle                = {Programming Languages and Systems},
  Publisher                = {Springer Berlin Heidelberg},
  Year                     = {2006},
  Editor                   = {Sestoft, Peter},
  Pages                    = {294-308},
  Series                   = {Lecture Notes in Computer Science},
  Volume                   = {3924},

  __markedentry            = {[hisham:1]},
  Abstract                 = {This paper describes FrTime, an extension of Scheme designed for writing interactive applications. Inspired by functional reactive programming, the language embeds dynamic dataflow within a call-by-value functional language. The essence of the embedding is to make program expressions evaluate to nodes in a dataflow graph. This strategy eases importation of legacy code and permits incremental program construction. We have integrated FrTime with the DrScheme programming environment and have used it to develop several novel applications. We describe FrTime’s design and implementation in detail and present a formal semantics of its evaluation model.},
  Doi                      = {10.1007/11693024_20},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Embedding_Dynamic_Dataflow_in_a_Call_by_Value_Language.pdf:PDF},
  ISBN                     = {978-3-540-33095-0},
  Language                 = {English},
  Owner                    = {hisham},
  Timestamp                = {2016-01-21},
  Url                      = {http://dx.doi.org/10.1007/11693024_20}
}

@InCollection{Cordy1992,
  Title                    = {Why the User Interface Is Not The Programming Language---and How It Can Be},
  Author                   = {James R. Cordy},
  Booktitle                = {Languages for developing user interfaces},
  Publisher                = {AK Peters, Ltd.},
  Year                     = {1992},
  Chapter                  = {6},
  Editor                   = {Brad A. Myers},
  Pages                    = {329--342},

  Owner                    = {hisham},
  Review                   = {What makes a programming language?
* Values and structures
* Decision, repetition, abstraction, parameterization, recursion
Specifying GUIs: an example how to specify visually a binary tree?
A visual language that provides all of the above: we needed a programming language.},
  Timestamp                = {2014-08-28}
}

@InCollection{Cordy1992LDUI,
  Title                    = {Hints on the Design of User Interface Language Features---Lessons from the Design of Turing},
  Author                   = {James R. Cordy},
  Booktitle                = {Languages for developing user interfaces},
  Publisher                = {AK Peters, Ltd.},
  Year                     = {1992},
  Chapter                  = {18},
  Editor                   = {Brad A. Myers},
  Pages                    = {329--342},

  Owner                    = {hisham},
  Review                   = {Turing programming language: designed as a successor to Pascal.
Syntactic conciseness, consistency. 
Define-by-example: simple type inference in initializations.},
  Timestamp                = {2014-08-28}
}

@InCollection{CordyReport1992LDUI,
  Title                    = {Report of the "Linguistic Support" Working Group},
  Author                   = {James R. Cordy and Ralph D. Hill and Gurminder Singh and Brad Vander Zanden},
  Booktitle                = {Languages for developing user interfaces},
  Publisher                = {AK Peters, Ltd.},
  Year                     = {1992},
  Chapter                  = {21},
  Editor                   = {Brad A. Myers},
  Pages                    = {385--399},

  Owner                    = {hisham},
  Review                   = {Goal of the group: dissatisfaction with the lack of UI support in existing app programming languages; lack of consistent semantic model relating UI to application.
These things are possible to fix with existing (1992) technology.
Architecture: separate program data and UI via idealized abstract data types.
Application ←→ ADT: critical issue is synchronization.
ADT ←→ UI: critical issue is graphical representation and mapping of commands to the ADT.
Example systems: RENDEZVOUS, UofA*, Constraint Grammars, GVL.},
  Timestamp                = {2014-08-28}
}

@InProceedings{Cunha:2009:SRD:1480945.1480972,
  Title                    = {From Spreadsheets to Relational Databases and Back},
  Author                   = {Cunha, J\'{a}come and Saraiva, Jo\~{a}o and Visser, Joost},
  Booktitle                = {Proceedings of the 2009 ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation},
  Year                     = {2009},

  Address                  = {New York, NY, USA},
  Pages                    = {179--188},
  Publisher                = {ACM},
  Series                   = {PEPM '09},

  Abstract                 = {This paper presents techniques and tools to transform spreadsheets into relational databases and back. A set of data refinement rules is introduced to map a tabular datatype into a relational database schema. Having expressed the transformation of the two data models as data refinements, we obtain for free the functions that migrate the data. We use well-known relational database techniques to optimize and query the data. Because data refinements define bi-directional transformations we can map such database back to an optimized spreadsheet. We have implemented the data refinement rules and we constructed Haskell-based tools to manipulate, optimize and refactor Excel-like spreadsheets.},
  Acmid                    = {1480972},
  Doi                      = {10.1145/1480945.1480972},
  File                     = {:Users/hisham/ac/dr/reading/pdf/From_Spreadsheets_to_Relational_Databases_and_Back.pdf:PDF},
  ISBN                     = {978-1-60558-327-3},
  Keywords                 = {bi-directional transformations, functional programming, spreadsheets, type-safe data migration},
  Location                 = {Savannah, GA, USA},
  Numpages                 = {10},
  Owner                    = {hisham},
  Timestamp                = {2016-01-16},
  Url                      = {http://doi.acm.org/10.1145/1480945.1480972}
}

@InCollection{brock1980consistent,
  Title                    = {Consistent semantics for a data flow language},
  Author                   = {Dean Brock, J.},
  Booktitle                = {Mathematical Foundations of Computer Science 1980},
  Publisher                = {Springer Berlin Heidelberg},
  Year                     = {1980},
  Editor                   = {Dembiński, P.},
  Pages                    = {168-180},
  Series                   = {Lecture Notes in Computer Science},
  Volume                   = {88},

  __markedentry            = {[hisham:1]},
  Abstract                 = {We have defined ADFL, an Applicative Data Flow Language, given its denotational semantics, thus demonstrating its simplicity, given its operational semantics, thus demonstrating its concurrency, and proven the consistency of the two semantic definitions.

This research is best extended by extension of the data flow language. Procedures are an obvious, and easy, addition to the language. The addition of constructs for programming real-time systems is a difficult, though rewarding, extension. In the data flow language of Weng [13], program identifiers may have streams (histories) as values. Interprocess communication, similar to that observed in real-time systems, is accomplished by the passing of streams. Dennis [7] has defined a stream operator which non-determinately merges two input stream and has used it to specify the inherently non-determinate airline reservation system. While the non-determinacy of this language limits the simplicity of its-semantic characterization, the elevation of process communication and synchronization to the level of passed parameters results in programs which are easier to comprehend and verify.},
  Doi                      = {10.1007/BFb0022503},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Consistent_semantics_for_a_data_flow_language.pdf:PDF},
  ISBN                     = {978-3-540-10027-0},
  Language                 = {English},
  Owner                    = {hisham},
  Timestamp                = {2016-01-21},
  Url                      = {http://dx.doi.org/10.1007/BFb0022503}
}

@Article{Demetrescu:2014:RIP:2688877.2623200,
  Title                    = {Reactive Imperative Programming with Dataflow Constraints},
  Author                   = {Demetrescu, Camil and Finocchi, Irene and Ribichini, Andrea},
  Journal                  = {ACM Trans. Program. Lang. Syst.},
  Year                     = {2014},

  Month                    = {nov},
  Number                   = {1},
  Pages                    = {3:1--3:53},
  Volume                   = {37},

  Abstract                 = {Dataflow languages provide natural support for specifying constraints between objects in dynamic applications, where programs need to react efficiently to changes in their environment. In this article, we show that one-way dataflow constraints, largely explored in the context of interactive applications, can be seamlessly integrated in any imperative language and can be used as a general paradigm for writing performance-critical reactive applications that require efficient incremental computations. In our framework, programmers can define ordinary statements of the imperative host language that enforce constraints between objects stored in special memory locations designated as “reactive.” Reactive objects can be of any legal type in the host language, including primitive data types, pointers, arrays, and structures. Statements defining constraints are automatically re-executed every time their input memory locations change, letting a program behave like a spreadsheet where the values of some variables depend on the values of other variables. The constraint-solving mechanism is handled transparently by altering the semantics of elementary operations of the host language for reading and modifying objects. We provide a formal semantics and describe a concrete embodiment of our technique into C/C++, showing how to implement it efficiently in conventional platforms using off-the-shelf compilers. We discuss common coding idioms and relevant applications to reactive scenarios, including incremental computation, observer design pattern, data structure repair, and software visualization. The performance of our implementation is compared to problem-specific change propagation algorithms, as well as to language-centric approaches such as self-adjusting computation and subject/observer communication mechanisms, showing that the proposed approach is efficient in practice.},
  Acmid                    = {2623200},
  Address                  = {New York, NY, USA},
  Articleno                = {3},
  Doi                      = {10.1145/2623200},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Reactive_Imperative_Programming_with_Dataflow_Constraints.pdf:PDF},
  ISSN                     = {0164-0925},
  Issue_date               = {January 2015},
  Keywords                 = {Reactive programming, constraint solving, data structure repair, dataflow programming, imperative programming, incremental computation, observer design pattern, one-way dataflow constraints, software visualization},
  Numpages                 = {53},
  Owner                    = {hisham},
  Publisher                = {ACM},
  Review                   = {Extended version of paper on DC, an extension of C that adds an extension for reactive dataflow.
Uses a dataflow constraint solver to handle reactions.
Integrates into C using a small set of C primitives:
* allocation - dc_malloc, dc_free
* atomic blocks - dc_begin_at, dc_end_at
* creating and deleting constraints
* reading and modifying of objects: adds no syntax for this, traps memory accesses using hardware protection and self-modifying binary code
Integrates into C++ using a small wrapper class that uses C primitives

The paper presents an abstract model specifying its operational semantics as DWhile, an extension of While (archetypical imperative language).},
  Timestamp                = {2015-10-06},
  Url                      = {http://doi.acm.org/10.1145/2623200}
}

@Unpublished{Denckla2006,
  Title                    = {Another essence of dataflow programming},
  Author                   = {Ben Denckla},
  Note                     = {Draft 5},

  Month                    = {feb},
  Year                     = {2006},

  Abstract                 = {Uustalu and Vene use comonads to separate the dataflow and non-
dataflow aspects of an interpreter for a dataflow language. I show that this
separation can be achieved more simply if an applicative functor is used
instead of a comonad. Applicative functors have recently been described
by McBride and Paterson.},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Another_essence_of_dataflow_programming.pdf:PDF},
  Keywords                 = {dataflow, comonads, applicative functors},
  Owner                    = {hisham},
  Review                   = {Response paper to "The essence of dataflow programming".
Argues that applicative functors can specify dataflow semantics in a simpler way than comonads.},
  Timestamp                = {2014-08-27},
  Url                      = {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.60.7044&rep=rep1&type=pdf}
}

@InCollection{Deng2011Framework,
  Title                    = {Designing a Framework for End User Applications},
  Author                   = {Deng, Yanbo and Churcher, Clare and Abell, Walt and McCallum, John},
  Booktitle                = {End-User Development},
  Publisher                = {Springer Berlin Heidelberg},
  Year                     = {2011},
  Editor                   = {Costabile, MariaFrancesca and Dittrich, Yvonne and Fischer, Gerhard and Piccinno, Antonio},
  Pages                    = {67-75},
  Series                   = {Lecture Notes in Computer Science},
  Volume                   = {6654},

  Abstract                 = {Specialised end user developed database applications can often be designed and developed quickly and simply to meet specific needs. However these applications are often difficult to generalise or adapt when requirements inevitably change. In this paper we describe a framework that allows a basic data model to have several co-existing variations which will satisfy the requirements of different user groups in a common domain. A web service and development toolkits provide a simple programming interface for interacting with the database. User trials showed that end users were able to use the system to quickly adapt and create applications. The result allows the needs of several different groups of users to have their specialist needs managed within a single organisational database.},
  Doi                      = {10.1007/978-3-642-21530-8_7},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Designing_a_Framework_for_End_User_Applications.pdf:PDF},
  ISBN                     = {978-3-642-21529-2},
  Keywords                 = {End user development; Data management; Frameworks; Tool-kits},
  Language                 = {English},
  Owner                    = {hisham},
  Review                   = {(Read for Clarisse's EUP class)
Experience report of the development of a simple framework for New Zealand's Plant and Food Research agency.
Users could customize instances of the framework using Excel and VBA.},
  Timestamp                = {2014-12-15},
  Url                      = {http://dx.doi.org/10.1007/978-3-642-21530-8_7}
}

@InProceedings{Dennis85Models,
  Title                    = {Models of Data Flow Computation},
  Author                   = {Jack B. Dennis},
  Booktitle                = {Control Flow and Data Flow - Concepts of Distributed Programming},
  Year                     = {1985},

  Address                  = {Berlin Heidelberg},
  Editor                   = {Manfred Broy},
  Publisher                = {Springer},

  File                     = {:ac/dr/reading/djvu/Control_Flow_and_Data_Flow_-_Concepts_of_Distributed_Programming.djvu:Djvu},
  Owner                    = {hisham},
  Timestamp                = {2016-12-07}
}

@InCollection{Dertouzos1992,
  Title                    = {The User Interface is The Language},
  Author                   = {Michael L. Dertouzos},
  Booktitle                = {Languages for developing user interfaces},
  Publisher                = {AK Peters, Ltd.},
  Year                     = {1992},
  Chapter                  = {2},
  Editor                   = {Brad A. Myers},
  Pages                    = {21--30},

  Owner                    = {hisham},
  Review                   = {The relevance of I/O: 10% of Dartmouth Basic calls; 70% of Microsoft Basic for Mac functions
Out-in programming: starts with UI design, continues with progressively deeper inner structures
Total environment integration: I/O for multiple media; network communication for users/servers; capabilities for multiple resources
Interfaces as "rails" on which components plug},
  Timestamp                = {2014-08-28}
}

@Article{diehl2000,
  Title                    = {Natural Semantics-Directed Generation of Compilers and Abstract Machines},
  Author                   = {Stephan Diehl},
  Journal                  = {Formal Aspects of Computing},
  Year                     = {2000},
  Pages                    = {71--99},
  Volume                   = {12},

  __markedentry            = {[hisham:1]},
  Abstract                 = {In this paper we present the motivation, theory and transformations of our semantics-directed
compiler generator. The main novelty of our generator is that it generates compilers and abstract machines.
The execution times of the abstract machine programs produced by our generated compiler compare well
to those of target programs produced by compilers generated by other semantics-directed generators. The
generated specifications of compilers and abstract machines are suitable as a starting point for handwriting
compilers and abstract machines. Our generator is fully automated and its core transformations are proved
correct},
  Owner                    = {hisham},
  Timestamp                = {2016-03-08},
  Url                      = {http://www.st.uni-trier.de/~diehl/pubs/facdiehl.pdf}
}

@Book{Dougherty1987unix,
  Title                    = {UNIX Text Processing},
  Author                   = {Dougherty, D. and O'Reilly, T. and Kochan, S.G. and Wood, P.H. and O'Reilly \& Associates},
  ISBN                     = {9780672462917},
  Publisher                = {Hayden Books},
  Year                     = {1987},
  Series                   = {Hayden Books UNIX library system},

  File                     = {:Users/hisham/ac/dr/reading/pdf/UNIX_Text_Processing.pdf:PDF},
  Lccn                     = {87060537},
  Owner                    = {hisham},
  Timestamp                = {2016-01-07},
  Url                      = {https://books.google.com.br/books?id=H148AQAAIAAJ}
}

@InCollection{draxler2011managing,
  Title                    = {Managing software portfolios: a comparative study},
  Author                   = {Draxler, Sebastian and Jung, Adrian and Stevens, Gunnar},
  Booktitle                = {End-User Development},
  Publisher                = {Springer},
  Year                     = {2011},
  Pages                    = {337--342},

  File                     = {:Users/hisham/ac/dr/reading/pdf/Managing_software_portfolios__a_comparative_study.pdf:PDF},
  Owner                    = {hisham},
  Timestamp                = {2016-01-25},
  Url                      = {https://www.wiwi.uni-siegen.de/wirtschaftsinformatik/paper/2011/managing-software-portfolios_draxler-etal_2011.pdf}
}

@Article{Edwards:1988:VPL:44326.44330,
  Title                    = {Visual Programming Languages: The Next Generation},
  Author                   = {Edwards, Alistair D. N.},
  Journal                  = {SIGPLAN Not.},
  Year                     = {1988},

  Month                    = {apr},
  Number                   = {4},
  Pages                    = {43--50},
  Volume                   = {23},

  Acmid                    = {44330},
  Address                  = {New York, NY, USA},
  Doi                      = {10.1145/44326.44330},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Visual_Programming_Languages__The_Next_Generation.pdf:PDF},
  ISSN                     = {0362-1340},
  Issue_date               = {April, 1988},
  Numpages                 = {8},
  Owner                    = {hisham},
  Publisher                = {ACM},
  Timestamp                = {2015-04-14},
  Url                      = {http://doi.acm.org/10.1145/44326.44330}
}

@InProceedings{Elliott:2007:TFP:1291151.1291163,
  Title                    = {Tangible Functional Programming},
  Author                   = {Elliott, Conal M.},
  Booktitle                = {Proceedings of the 12th ACM SIGPLAN International Conference on Functional Programming},
  Year                     = {2007},

  Address                  = {New York, NY, USA},
  Pages                    = {59--70},
  Publisher                = {ACM},
  Series                   = {ICFP '07},

  Abstract                 = {We present a user-friendly approach to unifying program creation and execution, based on a notion of "tangible values" (TVs), which are visual and interactive manifestations of pure values, including functions. Programming happens by gestural composition of TVs. Our goal is to give end-users the ability to create parameterized, composable content without imposing the usual abstract and linguistic working style of programmers. We hope that such a system will put the essence of programming into the hands of many more people, and in particular people with artistic/visual creative style.

In realizing this vision, we develop algebras for visual presentation and for "deep" function application, where function and argument may both be nested within a structure of tuples, functions, etc. Composition gestures are translated into chains of combinators that act simultaneously on statically typed values and their visualizations.},
  Acmid                    = {1291163},
  Doi                      = {10.1145/1291151.1291163},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Tangible_Functional_Programming.pdf:PDF},
  ISBN                     = {978-1-59593-815-2},
  Keywords                 = {arrows, combinator libraries, end-user programming, gestural composition, interactive programming, interactive visualization},
  Location                 = {Freiburg, Germany},
  Numpages                 = {12},
  Owner                    = {hisham},
  Review                   = {This paper has two parts: A UI for building functional programs visually, generating UIs for functions where arguments can be tweaked in real time (ie, a live programming environment); and the formalization of the underlying language, in Haskell.},
  Timestamp                = {2015-11-25},
  Url                      = {http://doi.acm.org/10.1145/1291151.1291163}
}

@InProceedings{Ellner:2007:SGL:1244381.1244402,
  Title                    = {The Semantics of Graphical Languages},
  Author                   = {Ellner, Stephan and Taha, Walid},
  Booktitle                = {Proceedings of the 2007 ACM SIGPLAN Symposium on Partial Evaluation and Semantics-based Program Manipulation},
  Year                     = {2007},

  Address                  = {New York, NY, USA},
  Pages                    = {122--133},
  Publisher                = {ACM},
  Series                   = {PEPM '07},

  __markedentry            = {[hisham:1]},
  Abstract                 = {Visual notations are pervasive in circuit design, control systems, and increasingly in mainstream programming environments. Yet many of the foundational advances in programming language theory are taking place in the context of textual notations. In order to map such advances to the graphical world, and to take the concerns of the graphical world into account when working with textual formalisms, there is a need for rigorous connections between textual and graphical expressions of computation.

To this end, this paper presents a graphical calculus called Uccello. Our key insight is that Ariola and Blom's work on sharing in the cyclic lambda calculus provides an excellent foundation for formalizing the semantics of graphical languages. As an example of what can be done with this foundation, we use it to extend a graphical language with staging constructs. In doing so, we provide the first formal account of sharing in a multi-stage calculus.},
  Acmid                    = {1244402},
  Doi                      = {10.1145/1244381.1244402},
  File                     = {:Users/hisham/ac/dr/reading/pdf/The_Semantics_of_Graphical_Languages.pdf:PDF},
  ISBN                     = {978-1-59593-620-2},
  Location                 = {Nice, France},
  Numpages                 = {12},
  Owner                    = {hisham},
  Timestamp                = {2014-12-11},
  Url                      = {http://doi.acm.org/10.1145/1244381.1244402}
}

@Book{ergul2013guide,
  Title                    = {Guide to Programming and Algorithms Using R},
  Author                   = {Erg{\"u}l, {\"O}.},
  ISBN                     = {9781447153283},
  Publisher                = {Springer London},
  Year                     = {2013},
  Series                   = {SpringerLink : B{\"u}cher},

  Owner                    = {hisham},
  Review                   = {Compares programming to cooking in page 2.},
  Timestamp                = {2015-01-14},
  Url                      = {https://books.google.com.br/books?id=2z29BAAAQBAJ}
}

@InProceedings{Falaki:2010:DSU:1814433.1814453,
  Title                    = {Diversity in Smartphone Usage},
  Author                   = {Falaki, Hossein and Mahajan, Ratul and Kandula, Srikanth and Lymberopoulos, Dimitrios and Govindan, Ramesh and Estrin, Deborah},
  Booktitle                = {Proceedings of the 8th International Conference on Mobile Systems, Applications, and Services},
  Year                     = {2010},

  Address                  = {New York, NY, USA},
  Pages                    = {179--194},
  Publisher                = {ACM},
  Series                   = {MobiSys '10},

  Abstract                 = {Using detailed traces from 255 users, we conduct a comprehensive study of smartphone use. We characterize intentional user activities -- interactions with the device and the applications used -- and the impact of those activities on network and energy usage. We find immense diversity among users. Along all aspects that we study, users differ by one or more orders of magnitude. For instance, the average number of interactions per day varies from 10 to 200, and the average amount of data received per day varies from 1 to 1000 MB. This level of diversity suggests that mechanisms to improve user experience or energy consumption will be more effective if they learn and adapt to user behavior. We find that qualitative similarities exist among users that facilitate the task of learning user behavior. For instance, the relative application popularity for can be modeled using an exponential distribution, with different distribution parameters for different users. We demonstrate the value of adapting to user behavior in the context of a mechanism to predict future energy drain. The 90th percentile error with adaptation is less than half compared to predictions based on average behavior across users.},
  Acmid                    = {1814453},
  Doi                      = {10.1145/1814433.1814453},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Diversity_in_Smartphone_Usage.pdf:PDF},
  ISBN                     = {978-1-60558-985-5},
  Keywords                 = {smartphone usage, user behavior},
  Location                 = {San Francisco, California, USA},
  Numpages                 = {16},
  Owner                    = {hisham},
  Review                   = {Uses the term "graphical shell" to refer to the smartphone UI.},
  Timestamp                = {2015-04-14},
  Url                      = {http://doi.acm.org/10.1145/1814433.1814453}
}

@Article{Falk:2013:RQS:2442116.2442124,
  Title                    = {A Rule-based Quasi-static Scheduling Approach for Static Islands in Dynamic Dataflow Graphs},
  Author                   = {Falk, Joachim and Zebelein, Christian and Haubelt, Christian and Teich, J\"{u}rgen},
  Journal                  = {ACM Trans. Embed. Comput. Syst.},
  Year                     = {2013},

  Month                    = apr,
  Number                   = {3},
  Pages                    = {74:1--74:31},
  Volume                   = {12},

  Abstract                 = {In this article, an efficient rule-based clustering algorithm for static dataflow subgraphs in a dynamic dataflow graph is presented. The clustered static dataflow actors are quasi-statically scheduled, in such a way that the global performance in terms of latency and throughput is improved compared to a dynamically scheduled execution, while avoiding the introduction of deadlocks as generated by naive static scheduling approaches. The presented clustering algorithm outperforms previously published approaches by a faster computation and more compact representation of the derived quasi-static schedule. This is achieved by a rule-based approach, which avoids an explicit enumeration of the state space. A formal proof of the correctness of the presented clustering approach is given. Experimental results show significant improvements in both, performance and code size, compared to a state-of-the-art clustering algorithm.},
  Acmid                    = {2442124},
  Address                  = {New York, NY, USA},
  Articleno                = {74},
  Doi                      = {10.1145/2442116.2442124},
  File                     = {:Users/hisham/ac/dr/reading/pdf/A Rule-based Quasi-static Scheduling Approach for Static Islands in Dynamic Dataflow Graphs.pdf:PDF},
  ISSN                     = {1539-9087},
  Issue_date               = {March 2013},
  Keywords                 = {Data flow analysis, actor-oriented design, clustering, scheduling},
  Numpages                 = {31},
  Owner                    = {hisham},
  Publisher                = {ACM},
  Timestamp                = {2017-03-12},
  Url                      = {http://doi.acm.org/10.1145/2442116.2442124}
}

@Article{JOT:issue_2014_09/article1,
  Title                    = {Specifying and Solving Constraints on Object Behavior},
  Author                   = {Tim Felgentreff and Alan Borning and Robert Hirschfeld},
  Journal                  = {Journal of Object Technology},
  Year                     = {2014},

  Month                    = {sep},
  Number                   = {4},
  Pages                    = {1:1-38},
  Volume                   = {13},

  Abstract                 = {Constraints allow developers to specify desired properties of systems in a number of domains, and have those properties be maintained automatically. This results in compact, declarative code, avoiding scattered code to check and imperatively re-satisfy invariants. Despite these advantages, constraint programming is not yet widespread, with imperative programming still the norm. There is a long history of research on integrating constraint programming with the imperative paradigm. However, this integration typically does not unify the constructs for encapsulation and abstraction from both paradigms. This impedes re-use of modules, as client code written in one paradigm can only use modules written to support that paradigm. Modules require redundant definitions if they are to be used in both paradigms. We present a language -- Babelsberg -- that unifies the constructs for encapsulation and abstraction by using only object-oriented method definitions for both declarative and imperative code. Our prototype -- Babelsberg/R -- is an extension to Ruby, and continues to support Ruby's object-oriented semantics. It allows programmers to add constraints to existing Ruby programs in incremental steps by placing them on the results of normal object-oriented message sends. It is implemented by modifying a state-of-the-art Ruby virtual machine. The performance of Ruby code without constraints is only modestly impacted, with typically less than 10% overhead compared with the unmodified virtual machine. Furthermore, our architecture for adding multiple constraint solvers allows Babelsberg to deal with constraints in a variety of domains. We argue that our approach provides a useful step toward making constraint solving a useful tool for object-oriented programmers. We also provide example applications, written in our Ruby-based implementation, which use constraints in a variety of application domains, including interactive graphics, circuit simulations, data streaming with both hard and soft constraints on performance, and configuration file management.},
  Doi                      = {10.5381/jot.2014.13.4.a1},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Specifying_and_Solving_Constraints_on_Object_Behavior.pdf:PDF},
  ISSN                     = {1660-1769},
  Owner                    = {hisham},
  Timestamp                = {2016-01-21},
  Url                      = {http://www.jot.fm/issues/issue_2014_09/article1.pdf}
}

@TechReport{Felgentreff2014BabelsbergSem,
  Title                    = {Developing a Formal Semantics for Babelsberg: A Step-by-Step Approach},
  Author                   = {Tim Felgentreff and Todd Millstein and Alan Borning},
  Institution              = {Viewpoints Research Institute},
  Year                     = {2014},

  Address                  = {Los Angeles, CA},
  Month                    = {9},
  Note                     = {2014},
  Number                   = {TR-2014-002b},

  File                     = {:Users/hisham/ac/dr/reading/pdf/Developing_a_formal_semantics_for_Babelsberg.pdf:PDF},
  Keywords                 = {objects, constraints, language, semantics, inc},
  Owner                    = {hisham},
  Timestamp                = {2016-01-21},
  Url                      = {http://www.vpri.org/pdf/tr2014002_babelsberg.pdf}
}

@Article{Felgentreff:2015:CBC:2858965.2814311,
  Title                    = {Checks and Balances: Constraint Solving Without Surprises in Object-constraint Programming Languages},
  Author                   = {Felgentreff, Tim and Millstein, Todd and Borning, Alan and Hirschfeld, Robert},
  Journal                  = {SIGPLAN Not.},
  Year                     = {2015},

  Month                    = {oct},
  Number                   = {10},
  Pages                    = {767--782},
  Volume                   = {50},

  __markedentry            = {[hisham:1]},
  Acmid                    = {2814311},
  Address                  = {New York, NY, USA},
  Doi                      = {10.1145/2858965.2814311},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Checks_and_Balances__Constraint_Solving_Without_Surprises_in_Object_constraint_Programming_Languages.pdf:PDF},
  ISSN                     = {0362-1340},
  Issue_date               = {October 2015},
  Keywords                 = {Constraint Imperative Programming, Constraints, Executable Semantics Test Suites, Object-Constraint Programming},
  Numpages                 = {16},
  Owner                    = {hisham},
  Publisher                = {ACM},
  Timestamp                = {2016-01-21},
  Url                      = {http://doi.acm.org/10.1145/2858965.2814311}
}

@InProceedings{DinamicaVM,
  Title                    = {The {Dinamica} Virtual Machine for Geosciences},
  Author                   = {Ferreira, Bruno and Pereira, Fernando Quint{\~a}o},
  Booktitle                = {{Brazilian Symposium on Programming Languages} - {SBLP}},
  Year                     = {2015},

  Owner                    = {hisham},
  Timestamp                = {2015-10-06}
}

@InProceedings{Foley-Bourgon:2016:EIC:2989225.2989235,
  Title                    = {Efficiently Implementing the Copy Semantics of MATLAB's Arrays in JavaScript},
  Author                   = {Foley-Bourgon, Vincent and Hendren, Laurie},
  Booktitle                = {Proceedings of the 12th Symposium on Dynamic Languages},
  Year                     = {2016},

  Address                  = {New York, NY, USA},
  Pages                    = {72--83},
  Publisher                = {ACM},
  Series                   = {DLS 2016},

  __markedentry            = {[hisham:1]},
  Abstract                 = {Compiling MATLAB---a dynamic, array-based language---to JavaScript is an attractive proposal: the output code can be deployed on a platform used by billions and can leverage the countless hours that have gone into making JavaScript JIT engines fast. But before that can happen, the original MATLAB code must be properly translated, making sure to bridge the semantic gaps of the two languages.

An important area where MATLAB and JavaScript differ is in their handling of arrays: for example, in MATLAB, arrays are one-indexed and writing at an index beyond the end of an array extends it; in JavaScript, typed arrays are zero-indexed and writing out of bounds is a no-op. A MATLAB-to-JavaScript compiler must address these mismatches. Another salient and pervasive difference between the two languages is the assignment of arrays to variables: in MATLAB, this operation has value semantics, while in JavaScript is has reference semantics.

In this paper, we present MatJuice --- a source-to-source, ahead-of-time compiler back-end for MATLAB --- and how it deals efficiently with this last issue. We present an intra-procedural data-flow analysis to track where each array variable may point to and which variables are possibly aliased. We also present the associated copy insertion transformation that uses the points-to information to insert explicit copies when necessary. The resulting JavaScript program respects the MATLAB value semantics and we show that it performs fewer run-time copies than some alternative approaches.},
  Acmid                    = {2989235},
  Doi                      = {10.1145/2989225.2989235},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Efficiently Implementing the Copy Semantics of MATLABs Arrays in JavaScript.pdf:PDF},
  ISBN                     = {978-1-4503-4445-6},
  Keywords                 = {JavaScript, MATLAB, dataflow analysis, dynamic language semantics, program transformation},
  Location                 = {Amsterdam, Netherlands},
  Numpages                 = {12},
  Owner                    = {hisham},
  Review                   = {Practical example of work designed to avoid excessive array copying. Uses dataflow analysis.},
  Timestamp                = {2017-03-09},
  Url                      = {http://doi.acm.org/10.1145/2989225.2989235}
}

@InProceedings{Fonner2015comonads,
  Title                    = {{Functional Pearl: Getting a Quick Fix on Comonads}},
  Author                   = {Fonner, Kenneth},
  Booktitle                = {2015 ACM SIGPLAN Symposium on Haskell},
  Year                     = {2015},
  Publisher                = {ACM},

  Abstract                 = {A piece of functional programming folklore due to Piponi provides Löb's theorem from modal provability logic with a computational interpretation as an unusual fixed point. Interpreting modal necessity as an arbitrary |Functor| in Haskell, the ``type'' of Löb's theorem is inhabited by a fixed point function allowing each part of a structure to refer to the whole.

However, |Functor|'s logical interpretation may be used to prove Löb's theorem only by relying on its implicit functorial strength, an axiom not available in the provability modality. As a result, the well known |loeb| fixed point ``cheats'' by using functorial strength to implement its recursion.

Rather than |Functor|, a closer Curry analogue to modal logic's Howard inspiration is a closed (semi-)comonad, of which Haskell's |ComonadApply| typeclass provides analogous structure. Its computational interpretation permits the definition of a novel fixed point function allowing each part of a structure to refer to its own context within the whole. This construction further guarantees maximal sharing and asymptotic efficiency superior to |loeb| for locally contextual computations upon a large class of structures. With the addition of a distributive law, closed comonads may be composed into spaces of arbitrary dimensionality while preserving the performance guarantees of this new fixed point.

From these elements, we construct a small embedded domain-specific language to elegantly express and evaluate multidimensional ``spreadsheet-like'' recurrences for a variety of cellular automata.},
  File                     = {:Users/hisham/ac/dr/reading/pdf/_Functional_Pearl__Getting_a_Quick_Fix_on_Comonads_.pdf:PDF},
  Owner                    = {hisham},
  Review                   = {defines operations on comonads to allow sharing of computations, and builds a spreadsheet-like evaluation DSL on top of it. Cites The Essence of Dataflow Programming, which also deals with comonads for representing dataflow.},
  Timestamp                = {2015-10-05},
  Url                      = {https://github.com/kwf/GQFC}
}

@InProceedings{Foust:2015:GRP:2814204.2814207,
  Title                    = {Generating Reactive Programs for Graphical User Interfaces from Multi-way Dataflow Constraint Systems},
  Author                   = {Foust, Gabriel and J\"{a}rvi, Jaakko and Parent, Sean},
  Booktitle                = {Proceedings of the 2015 ACM SIGPLAN International Conference on Generative Programming: Concepts and Experiences},
  Year                     = {2015},

  Address                  = {New York, NY, USA},
  Pages                    = {121--130},
  Publisher                = {ACM},
  Series                   = {GPCE 2015},

  __markedentry            = {[hisham:1]},
  Abstract                 = {For a GUI to remain responsive, it must be able to schedule lengthy tasks to be executed asynchronously. In the traditional approach to GUI implementation--writing functions to handle individual user events--asynchronous programming easily leads to defects. Ensuring that all data dependencies are respected is difficult when new events arrive while prior events are still being handled. Reactive programming techniques, gaining popularity in GUI programming, help since they make data dependencies explicit and enforce them automatically as variables' values change. However, data dependencies in GUIs usually change along with its state. Reactive programming must therefore describe a GUI as a collection of many reactive programs, whose interaction the programmer must explicitly coordinate. This paper presents a declarative approach for GUI programming that relieves the programmer from coordinating asynchronous computations. The approach is based on our prior work on "property models", where GUI state is maintained by a dataflow constraint system. A property model responds to user events by atomically constructing new data dependencies and scheduling asynchronous computations to enforce those dependencies. In essence, a property model dynamically generates a reactive program, adding to it as new events occur. The approach gives the following guarantee: the same sequence of events produces the same results, regardless of the timing of those events.},
  Acmid                    = {2814207},
  Doi                      = {10.1145/2814204.2814207},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Generating Reactive Programs for Graphical User Interfaces from Multi-way Dataflow Constraint Systems.pdf:PDF},
  ISBN                     = {978-1-4503-3687-1},
  Keywords                 = {Dataflow constraint systems, Graphical user interfaces, asynchronous programming},
  Location                 = {Pittsburgh, PA, USA},
  Numpages                 = {10},
  Owner                    = {hisham},
  Timestamp                = {2017-03-09},
  Url                      = {http://doi.acm.org/10.1145/2814204.2814207}
}

@Book{Fowler:2010:DSL:1809745,
  Title                    = {Domain Specific Languages},
  Author                   = {Fowler, Martin},
  ISBN                     = {0321712943, 9780321712943},
  Publisher                = {Addison-Wesley Professional},
  Year                     = {2010},
  Edition                  = {1st},

  Abstract                 = {Designed as a wide-ranging guide to Domain Specific Languages (DSLs) and how to approach building them, this book covers a variety of different techniques available for DSLs. The goal is to provide readers with enough information to make an informed choice about whether or not to use a DSL and what kinds of DSL techniques to employ. Part I is a 150-page narrative overview that gives you a broad understanding of general principles. The reference material in Parts II through VI provides the details and examples you willneed to get started using the various techniques discussed. Both internal and external DSL topics are covered, in addition to alternative computational models and code generation. Although the general principles and patterns presented can be used with whatever programming language you happen to be using, most of the examples are in Java or C#.},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Domain_Specific_Languages.pdf:PDF},
  Owner                    = {hisham},
  Review                   = {Makes the distinction between external and internal DSLs.
Internal DSLs are "fluent APIs": APIs designed to make you feel like you're programming a different language.
Presents a "DSL zoo" (a chapter with a selection of DSLs)
Teaches various classic interpreter and compiler writing techniques, for programmers with no background in PL theory.},
  Timestamp                = {2014-12-11}
}

@Electronic{Fowler2005LanguageWorkbench,
  Title                    = {Language Workbenches: The Killer-App for Domain Specific Languages?},
  Author                   = {Martin Fowler},
  HowPublished             = {http://martinfowler.com/articles/languageWorkbench.html},
  Month                    = {jun},
  Url                      = {http://martinfowler.com/articles/languageWorkbench.html},
  Year                     = {2005},

  Abstract                 = {Most new ideas in software developments are really new variations on old ideas. This article describes one of these, the growing idea of a class of tools that I call Language Workbenches - examples of which include Intentional Software, JetBrains's Meta Programming System, and Microsoft's Software Factories. These tools take an old style of development - which I call language oriented programming and use IDE tooling in a bid to make language oriented programming a viable approach. Although I'm not enough of a prognosticator to say whether they will succeed in their ambition, I do think that these tools are some of the most interesting things on the horizon of software development. Interesting enough to write this essay to try to explain, at least in outline, how they work and the main issues around their future usefulness.},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Language_Workbenches__The_Killer_App_for_Domain_Specific_Languages_.pdf:PDF},
  Keywords                 = {dsl, language, workbench},
  Owner                    = {hisham},
  Review                   = {Another article that refers to MATLAB as a domain specific language},
  Timestamp                = {2015-01-13}
}

@InCollection{FreemanBensonBorning1992LDUI,
  Title                    = {Constraint Imperative Programming Languages for Building Interactive Systems},
  Author                   = {Bjorn N. Freeman-Benson and Alan Borning},
  Booktitle                = {Languages for developing user interfaces},
  Publisher                = {AK Peters, Ltd.},
  Year                     = {1992},
  Chapter                  = {11},
  Editor                   = {Brad A. Myers},
  Pages                    = {161--182},

  Owner                    = {hisham},
  Review                   = {Constraint Imperative Programming: CIP - integrates constraint and imperative paradigms
Imperative paradigm: imperative engine ←→ Passive data store.
Constraint paradigm: constraint graph.
CIP: Imperative engine ←→ Active constraint store.
constraint satisfaction algorithms: DeltaBlue algorithm, DeltaStar solver
Variables are viewed as streams, like Lucid
Because all computation in CIP is done with constraints, the imperactive actions "write" and "compute"
are replaced by "add constraint". The other operation is "read".
Values can only flow forward in time: x:=x+1 becomes x[t+1] = x[t]? + 1 where x[t]? is read-only use of x[t].},
  Timestamp                = {2014-08-28}
}

@InCollection{Gansner1992,
  Title                    = {A Foundation for User Interface Construction},
  Author                   = {Emden R. Gansner and John H. Reppy},
  Booktitle                = {Languages for developing user interfaces},
  Publisher                = {AK Peters, Ltd.},
  Year                     = {1992},
  Chapter                  = {14},
  Editor                   = {Brad A. Myers},
  Pages                    = {239--260},

  Owner                    = {hisham},
  Review                   = {Pegasus system, PML language (dialect of ML).
Foundational requirements for GUIs: concurrency; strong, static typing; side-effect free; higher-order functions and polymorphism; parameterized modules for programming in the large; garbage collection.
Threads are objects. Dynamic thread creation and synchronous (rendezvous) communication on typed channels.},
  Timestamp                = {2014-08-28}
}

@InProceedings{Gantel2011dataflowReconfigurable,
  Title                    = {Dataflow programming model for reconfigurable computing},
  Author                   = {Gantel, L. and Khiar, A. and Miramond, B. and Benkhelifa, A. and Lemonnier, F. and Kessal, L.},
  Booktitle                = {Reconfigurable Communication-centric Systems-on-Chip (ReCoSoC), 2011 6th International Workshop on},
  Year                     = {2011},
  Month                    = {June},
  Pages                    = {1-8},

  __markedentry            = {[hisham:1]},
  Abstract                 = {This paper addresses the problem of image processing algorithms implementation onto dynamically and reconfigurable architectures. Today, these Systems-on-Chip (SoC), offer the possibility to implement several heterogeneous processing elements in a single chip. It means several processors, few hardware accelerators as well as communication mediums between all these components. Applications for this kind of platform are described with software threads, running on processors, and specific hardware accelerators, running on hardware partitions. This paper focuses on the complex problem of communication management between software and hardware actors for dataflow oriented processing, and proposes solutions to leverage this issue.},
  Doi                      = {10.1109/ReCoSoC.2011.5981505},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Dataflow_programming_model_for_reconfigurable_computing.pdf:PDF},
  Keywords                 = {data flow computing;digital signal processing chips;hardware-software codesign;logic partitioning;multi-threading;reconfigurable architectures;system-on-chip;communication management;dataflow programming model;hardware accelerators;hardware partitions;image processing;reconfigurable computing;software threads;system-on-chip;Computational modeling;Computer architecture;Hardware;Instruction sets;Middleware;Operating systems;FPGA;dataflow programming;hardware actors;image processing;multiprocessor architectures;real-time operating systems;reconfigurable computing},
  Owner                    = {hisham},
  Timestamp                = {2016-01-21},
  Url                      = {http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=5981505}
}

@InCollection{Ghianni2011Mashups,
  Title                    = {Creating Mashups by Direct Manipulation of Existing Web Applications},
  Author                   = {Ghiani, Giuseppe and Paterno, Fabio and Spano, LucioDavide},
  Booktitle                = {End-User Development},
  Publisher                = {Springer Berlin Heidelberg},
  Year                     = {2011},
  Editor                   = {Costabile, Maria Francesca and Dittrich, Yvonne and Fischer, Gerhard and Piccinno, Antonio},
  Pages                    = {42-52},
  Series                   = {Lecture Notes in Computer Science},
  Volume                   = {6654},

  Doi                      = {10.1007/978-3-642-21530-8_5},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Creating_Mashups_by_Direct_Manipulation_of_Existing_Web_Applications.pdf:PDF},
  ISBN                     = {978-3-642-21529-2},
  Keywords                 = {Mashups; Web applications; End User Development},
  Language                 = {English},
  Owner                    = {hisham},
  Timestamp                = {2015-04-15},
  Url                      = {http://dx.doi.org/10.1007/978-3-642-21530-8_5}
}

@Article{Gill:2014:DLC:2611429.2617811,
  Title                    = {Domain-specific Languages and Code Synthesis Using Haskell},
  Author                   = {Gill, Andy},
  Journal                  = {Queue},
  Year                     = {2014},

  Month                    = {apr},
  Number                   = {4},
  Pages                    = {30:30--30:43},
  Volume                   = {12},

  Abstract                 = {Looking at embedded DSLs},
  Acmid                    = {2617811},
  Address                  = {New York, NY, USA},
  Articleno                = {30},
  Doi                      = {10.1145/2611429.2617811},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Domain_specific_Languages_and_Code_Synthesis_Using_Haskell.pdf:PDF},
  ISSN                     = {1542-7730},
  Issue_date               = {April 2014},
  Numpages                 = {14},
  Owner                    = {hisham},
  Publisher                = {ACM},
  Review                   = {Article that refers to MATLAB as a domain-specific language.},
  Timestamp                = {2015-01-13},
  Url                      = {http://doi.acm.org/10.1145/2611429.2617811}
}

@Article{Glesner:2004:NSS:982158.982161,
  Title                    = {Natural Semantics As a Static Program Analysis Framework},
  Author                   = {Glesner, Sabine and Zimmermann, Wolf},
  Journal                  = {ACM Trans. Program. Lang. Syst.},
  Year                     = {2004},

  Month                    = may,
  Number                   = {3},
  Pages                    = {510--577},
  Volume                   = {26},

  __markedentry            = {[hisham:1]},
  Abstract                 = {Natural semantics specifications have become mainstream in the formal specification of programming language semantics during the last 10 years. In this article, we set up sorted natural semantics as a specification framework which is able to express static semantic information of programming languages declaratively in a uniform way and allows one at the same time to generate corresponding analyses. Such static semantic information comprises context-sensitive properties which are checked in the semantic analysis phase of compilers as well as further static program analyses such as, for example, classical data and control flow analyses or type and effect systems. The latter require fixed-point analyses to determine their solutions. We show that, given a sorted natural semantics specification, we can generate the corresponding analysis. Therefore, we classify the solution of such an analysis by the notion of a proof tree. We show that a proof tree can be computed by solving an equivalent residuation problem. In case of the semantic analysis, this solution can be found by a basic algorithm. We show that its efficiency can be enhanced using solution strategies. We also demonstrate our prototype implementation of the basic algorithm which proves its applicability in practical situations. With the results of this article, we have established natural semantics as a framework which closes the gap between declarative and operational specification methods for static semantic properties as well as between specification frameworks for the semantic analysis. In particular, we show that natural semantics is expressive enough to define fixed-point program analyses.},
  Acmid                    = {982161},
  Address                  = {New York, NY, USA},
  Doi                      = {10.1145/982158.982161},
  ISSN                     = {0164-0925},
  Issue_date               = {May 2004},
  Keywords                 = {Natural semantics, compiler generators, constraint solving, fixed-point program analyses, semantic analysis, static program analysis},
  Numpages                 = {68},
  Owner                    = {hisham},
  Publisher                = {ACM},
  Timestamp                = {2016-03-08},
  Url                      = {http://doi.acm.org/10.1145/982158.982161}
}

@InProceedings{Gold2011MaxMSP,
  Title                    = {Cloning in {Max/MSP} Patches},
  Author                   = {Nicolas Gold and Jens Krinke and Mark Harman and David Binkley},
  Booktitle                = {Proceedings of International Computer Music Conference 2011},
  Year                     = {2011},

  Address                  = {Huddersfield, {UK}},
  Month                    = {July},
  Organization             = {International Computer Music Association},
  Pages                    = {159--162},

  Abstract                 = {Max/MSP is widely used for developing applications in music and art yet less attention has been given to supporting developers working in this language than for more traditional languages such as Java. Technologies such as code-completion, reuse support, and refactoring may be helpful but are largely unexplored. Such methods rely on detecting similarities between language elements. This paper presents a method for detecting similarities between Max/MSP patches (and sub-patches) based on clone detection techniques. The method has been implemented and a proof-of-concept evaluation has been undertaken by applying it to the set of Max tutorial patches supplied with Max/MSP 5. The results show that significant cloning takes place both within and outwith an individual patch and that, as clone constraints are relaxed, the number of clone pairs increases.},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Cloning_in_MAX_MSP_Patches.pdf:PDF},
  Owner                    = {hisham},
  Review                   = {mentions that Max/MSP uses the visual layout to determine the order of message passing.},
  Timestamp                = {2017-02-24}
}

@InProceedings{Gold2009MaxPoster,
  Title                    = {Clone Detection for Max/MSP Patch Libraries (Poster Abstract)},
  Author                   = {Nicolas Gold and Jens Krinke and Mark Harman and David Binkley},
  Booktitle                = {Digital Music Research Network Workshop},
  Year                     = {2009},

  File                     = {:Users/hisham/ac/dr/reading/pdf/Clone_Detection_for_MAX_MSP_Patche_Libraries.pdf:PDF},
  Owner                    = {hisham},
  Review                   = {contains an example where Max/MSP visual layout affects evaluation order},
  Timestamp                = {2017-02-24}
}

@InCollection{Graham1992LDUI,
  Title                    = {Constructing User Interfaces with Functions and Temporal Constraints},
  Author                   = {T.C. Nicholas Graham},
  Booktitle                = {Languages for developing user interfaces},
  Publisher                = {AK Peters, Ltd.},
  Year                     = {1992},
  Chapter                  = {16},
  Editor                   = {Brad A. Myers},
  Pages                    = {279--301},

  Owner                    = {hisham},
  Review                   = {Requirements for UI languages: rapid prototyping; non-determinism and concurrency; efficiency.
Bridging the gap between prototyping and production:
* Specification level: (1a) Temporal constraints (implicit synchronization) + (1b) Declarative spec of application
* Implementation level: (2a) Tailored synchronization constructs + (2b) Optimized application
(Proofs in temporal logic convert 1a into 2a, transformation/compilation convert 1b into 2b.)
Clock language: functional programming; result continuations for I/O.
Communication streams for connecting components: input, output, query, notification.
A stream logic: first order logic + temporal operators: ◇p (sometime p), p << q (p precedes q).
Used to implement constraints. Examples with event handlers.},
  Timestamp                = {2014-08-28}
}

@InCollection{GrahamReport1992LDUI,
  Title                    = {Future Research Issues in Languages for Developing User Interfaces},
  Author                   = {T.C. Nicholas Graham},
  Booktitle                = {Languages for developing user interfaces},
  Publisher                = {AK Peters, Ltd.},
  Year                     = {1992},
  Chapter                  = {22},
  Editor                   = {Brad A. Myers},
  Pages                    = {401--418},

  Owner                    = {hisham},
  Review                   = {General language issues:
* A new language, an extended language, or a toolkit?
* Show we have multiple languages or a single language?
* How should the environment look?
* How should constraints be integrated?
* How much static typing?
* Is there a role for functional programming in HCI?
* Is OO useful for UI?
End-user programming:
* Making abstractions understable for end-users?
* Are component-based applications suitable for the end-user?
Non-WIMP interfaces:
* What kind of concurrency do we need?
* Can we support concurrency transparently?
* Supporting time/temporal aspects?
Programming in the large:
* Translating from behavioral to constructional domains?
* How do we make UIs reliable?
* Connecting App code to interface code?
* How to solve practical problems with components?
* How to support reuse?},
  Timestamp                = {2014-08-28}
}

@Article{vee1998,
  Title                    = {A Compiler for {HP VEE}},
  Author                   = {Steven Greenbaum and Stanley Jefferson},
  Journal                  = {Hewlett-Packard Journal},
  Year                     = {1998},

  Month                    = {may},
  Number                   = {2},
  Pages                    = {98--122},
  Volume                   = {49},

  Owner                    = {hisham},
  Review                   = {Description of VEE, HP's LabVIEW-like language.
Interesting description of the semantics for sequence nodes.},
  Timestamp                = {2017-01-09}
}

@InProceedings{Gupta:2011:DES:2155620.2155628,
  Title                    = {Dataflow Execution of Sequential Imperative Programs on Multicore Architectures},
  Author                   = {Gupta, Gagan and Sohi, Gurindar S.},
  Booktitle                = {Proceedings of the 44th Annual IEEE/ACM International Symposium on Microarchitecture},
  Year                     = {2011},

  Address                  = {New York, NY, USA},
  Pages                    = {59--70},
  Publisher                = {ACM},
  Series                   = {MICRO-44},

  __markedentry            = {[hisham:1]},
  Abstract                 = {As multicore processors become the default, researchers are aggressively looking for program execution models that make it easier to use the available resources. Multithreaded programming models that rely on statically-parallel programs have gained prevalence. Most of the existing research is directed at adapting and enhancing such models, alleviating their drawbacks, and simplifying their usage. This paper takes a different approach and proposes a novel execution model to achieve parallel execution of statically-sequential programs. It dynamically parallelizes the execution of suitably-written sequential programs, in a dataflow fashion, on multiple processing cores. Significantly, the execution is race-free and determinate. Thus the model eases program development and yet exploits available parallelism.

This paper describes the implementation of a software runtime library that implements the proposed execution model on existing commercial multicore machines. We present results from experiments running benchmark programs, using both the proposed technique as well as traditional parallel programming, on three different systems. We find that in addition to easing the development of the benchmarks, the approach is resource-efficient and achieves performance similar to the traditional approach, using stock compilers, operating systems and hardware, despite the overheads of an all-software implementation of the model.},
  Acmid                    = {2155628},
  Doi                      = {10.1145/2155620.2155628},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Dataflow_Execution_of_Sequential_Imperative_Programs_on_Multicore_Architectures.pdf:PDF},
  ISBN                     = {978-1-4503-1053-6},
  Keywords                 = {dataflow, determinacy, multicore, programming},
  Location                 = {Porto Alegre, Brazil},
  Numpages                 = {12},
  Owner                    = {hisham},
  Timestamp                = {2016-01-21},
  Url                      = {http://doi.acm.org/10.1145/2155620.2155628}
}

@InCollection{Guzdial1992,
  Title                    = {Report of the "User/Programmer Distinction" Working Group},
  Author                   = {Mark Guzdial and John Reppy and Randall B. Smith},
  Booktitle                = {Languages for developing user interfaces},
  Publisher                = {AK Peters, Ltd.},
  Year                     = {1992},
  Chapter                  = {20},
  Editor                   = {Brad A. Myers},
  Pages                    = {367--384},

  Owner                    = {hisham},
  Review                   = {Challenges in user/programmer distinction:
* Task differences: specific vs flexible; direct vs symbolic; mapping non-visual semantics
* Domain differences: mathematics; more objects; complexity of modifying code
* Market challenges
Embedded languages: Elisp (GNU Emacs), WOOL, Tcl.
Programming by demonstration.},
  Timestamp                = {2014-08-28}
}

@InCollection{Guzdial1992LDUI,
  Title                    = {Design Support Environments for End Users},
  Author                   = {Mark Guzdial and Peri Weingrand and Robert Boyle and Elliot Soloway},
  Booktitle                = {Languages for developing user interfaces},
  Publisher                = {AK Peters, Ltd.},
  Year                     = {1992},
  Chapter                  = {4},
  Editor                   = {Brad A. Myers},
  Pages                    = {57--78},

  Owner                    = {hisham},
  Review                   = {Expert programmers have 3 types of knowledge structures that novices lack: domain knowledge (programming language), structure, process (bottom-up, top-down, opportunistic)
Need for domain knowledge: language, reusable components
Need for structure: articulation
Need for process: problem-solving methods 
Non-programming environment: MediaText
Programming environment: GPCeditor - environment forces top-down design - "I am seeing GPC in my mind when I write THINK [Pascal]"},
  Timestamp                = {2014-08-28}
}

@Article{Lustre,
  Title                    = {The synchronous data flow programming language LUSTRE},
  Author                   = {N. Halbwachs and P. Caspi and P. Raymond and D. Pilaud},
  Journal                  = {Proceedings of the IEEE},
  Year                     = {1991},

  Month                    = {Sep},
  Number                   = {9},
  Pages                    = {1305-1320},
  Volume                   = {79},

  __markedentry            = {[hisham:1]},
  Abstract                 = {The authors describe LUSTRE, a data flow synchronous language designed for programming reactive systems-such as automatic control and monitoring systems-as well as for describing hardware. The data flow aspect of LUSTRE makes it very close to usual description tools in these domains (block-diagrams, networks of operators, dynamical sample-systems, etc.), and its synchronous interpretation makes it well suited for handling time in programs. Moreover, this synchronous interpretation allows it to be compiled into an efficient sequential program. The LUSTRE formalism is very similar to temporal logics. This allows the language to be used for both writing programs and expressing program properties, which results in an original program verification methodology},
  Doi                      = {10.1109/5.97300},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Lustre.pdf:PDF},
  ISSN                     = {0018-9219},
  Keywords                 = {parallel languages;program verification;temporal logic;LUSTRE;description tools;program verification methodology;reactive systems;sequential program;synchronous data flow programming language;temporal logics;Aerospace control;Automatic programming;Computer languages;Computerized monitoring;Delay;Design methodology;Frequency synchronization;Hardware design languages;Protocols;Real time systems},
  Owner                    = {hisham},
  Timestamp                = {2017-03-11},
  Url                      = {http://www6.in.tum.de/pub/Main/TeachingWs2009Echtzeitsysteme/procieee1991-3.pdf}
}

@InCollection{HartsonBrandenburgHix1992LDUI,
  Title                    = {Different Languages for Different Development Activities: Behavioral Representation Techniques for User Interface Design},
  Author                   = {H. Rex Hartson and Jeffrey L. Brandenburg and Deborah Hix},
  Booktitle                = {Languages for developing user interfaces},
  Publisher                = {AK Peters, Ltd.},
  Year                     = {1992},
  Chapter                  = {17},
  Editor                   = {Brad A. Myers},
  Pages                    = {303--328},

  Owner                    = {hisham},
  Review                   = {User Action Notation (UAN), notation for behavioral specification.
Argue that design and development should be separate: "interaction design as a separate role".
Syntax for specifying GUI actions.},
  Timestamp                = {2014-08-28}
}

@Article{Heer:2010:DLD:1907651.1908001,
  Title                    = {Declarative Language Design for Interactive Visualization},
  Author                   = {Heer, Jeffrey and Bostock, Michael},
  Journal                  = {IEEE Transactions on Visualization and Computer Graphics},
  Year                     = {2010},

  Month                    = {nov},
  Number                   = {6},
  Pages                    = {1149--1156},
  Volume                   = {16},

  __markedentry            = {[hisham:1]},
  Acmid                    = {1908001},
  Address                  = {Piscataway, NJ, USA},
  Doi                      = {10.1109/TVCG.2010.144},
  File                     = {:Users/hisham/ac/dr/reading/pdf/2010-Protovis-InfoVis.pdf:PDF},
  ISSN                     = {1077-2626},
  Issue_date               = {November 2010},
  Keywords                 = {declarative languages, domain specific languages, information visualization, information visualization, user interfaces, toolkits, domain specific languages, declarative languages, optimization, optimization, toolkits, user interfaces},
  Numpages                 = {8},
  Owner                    = {hisham},
  Publisher                = {IEEE Educational Activities Department},
  Timestamp                = {2015-05-11},
  Url                      = {http://dx.doi.org/10.1109/TVCG.2010.144}
}

@Article{Hidders2008261,
  Title                    = {DFL: A dataflow language based on Petri nets and nested relational calculus },
  Author                   = {Jan Hidders and Natalia Kwasnikowska and Jacek Sroka and Jerzy Tyszkiewicz and Jan Van den Bussche},
  Journal                  = {Information Systems },
  Year                     = {2008},
  Number                   = {3},
  Pages                    = {261 - 284},
  Volume                   = {33},

  __markedentry            = {[hisham:1]},
  Abstract                 = {In this paper we propose DFL—a formal, graphical workflow language for dataflows, i.e., workflows where large amounts of complex data are manipulated, and the structure of the manipulated data is reflected in the structure of the workflow. It is a common extension of (1) Petri nets, which are responsible for the organization of the processing tasks, and (2) nested relational calculus, which is a database query language over complex objects, and is responsible for handling collections of data items (in particular, for iteration) and for the typing system. We demonstrate that dataflows constructed in a hierarchical manner, according to a set of refinement rules we propose, are semi-sound, i.e., initiated with a single token (which may represent a complex scientific data collection) in the input node, terminate with a single token in the output node (which represents the output data collection). In particular they never leave any “debris data” behind and an output is always eventually computed regardless of how the computation proceeds.},
  Doi                      = {http://dx.doi.org/10.1016/j.is.2007.09.002},
  File                     = {:Users/hisham/ac/dr/reading/pdf/DFL__A_dataflow_language_based_on_Petri_nets_and_nested_relational_calculus_.pdf:PDF},
  ISSN                     = {0306-4379},
  Keywords                 = {DFL},
  Owner                    = {hisham},
  Timestamp                = {2016-01-19},
  Url                      = {http://www.sciencedirect.com/science/article/pii/S0306437907000634}
}

@InCollection{Hill1992LDUI,
  Title                    = {Languages for the Construction of Multi-User Multi-Media Synchronous ({MUMMS}) Applications},
  Author                   = {Ralph D. Hill},
  Booktitle                = {Languages for developing user interfaces},
  Publisher                = {AK Peters, Ltd.},
  Year                     = {1992},
  Chapter                  = {9},
  Editor                   = {Brad A. Myers},
  Pages                    = {125-145},

  Owner                    = {hisham},
  Review                   = {Networked shared environment for graphical applications
Design and construction of RENDEZVOUS language
Case study with a card table application
The basic actions: 1) display objects, 2) maintain relations, 3) react to user input.
Features: OOP (basic), objects as processes (reaction), IPC (reaction), event-based input (reaction),
declarative output (display), constraints (maintenance), real-time requirements (basic, reaction),
libraries and components (basic), assistance dealing with large numbers of parameters (basic),
rapid prototyping (basic).
Problem areas: synchronization of media, declarative specification of non-graphical or mixed media.},
  Timestamp                = {2014-08-28}
}

@Article{Hils1992DFVPLSurvey,
  Title                    = {Visual Langauges and Computing Survey: Data Flow Visual Programming Languages},
  Author                   = {Daniel D. Hils},
  Journal                  = {Journal of Visual Languages \& Computing},
  Year                     = {1992},
  Pages                    = {69--101},
  Volume                   = {3},

  __markedentry            = {[hisham:]},
  Abstract                 = {The data flow model is a popular model on which to base a visual programming language. This paper describes alternatives available to a designer of data flow languages, describes many of the languages, discusses some strengths of the languages, and discusses some unsolved problems in the design of data flow languages.},
  Doi                      = {1045-926X/92/010069+33},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Visual_Langauges_and_Computing_Survey__Data_Flow_Visual_Programming_Languages.pdf:PDF},
  Owner                    = {hisham},
  Timestamp                = {2016-01-19},
  Url                      = {http://fab.cba.mit.edu/classes/S62.12/docs/Hils_visual.pdf}
}

@InProceedings{Hils1991datavis,
  Title                    = {Datavis: A Visual Programming Language for Scientific Visualization},
  Author                   = {Hils, Daniel D.},
  Booktitle                = {Proceedings of the 19th Annual Conference on Computer Science},
  Year                     = {1991},

  Address                  = {New York, NY, USA},
  Pages                    = {439--448},
  Publisher                = {ACM},
  Series                   = {CSC '91},

  Acmid                    = {327331},
  Doi                      = {10.1145/327164.327331},
  File                     = {:Users/hisham/ac/dr/reading/pdf/DataVis.pdf:PDF},
  ISBN                     = {0-89791-382-5},
  Location                 = {San Antonio, Texas, USA},
  Numpages                 = {10},
  Owner                    = {hisham},
  Timestamp                = {2017-01-11},
  Url                      = {http://doi.acm.org/10.1145/327164.327331}
}

@InCollection{Horn1992LDUI,
  Title                    = {Properties of User Interface Systems and the Siri Programming Language},
  Author                   = {Bruce Horn},
  Booktitle                = {Languages for developing user interfaces},
  Publisher                = {AK Peters, Ltd.},
  Year                     = {1992},
  Chapter                  = {13},
  Editor                   = {Brad A. Myers},
  Pages                    = {211--237},

  Owner                    = {hisham},
  Review                   = {Reactive programs: allow the program to modify its model in response to the user changing the visual representation.
Implementation issues: use and display of control objects; modeless interaction; mapping user events; reflection of
model and context; consistency maintenence; concurrency and time.
Toolboxes are not enough: the boundary between toolbox and application isolates important information from the interface.
Characteristics of a new language: OO; multi-way constraints; multi-threading; incremental computation; meta programming and interpretation; support for real-time behavior.
Siri (Symbolic Reduction Interpreter): OO programming language with a simple, event-based, multi-way constraint satisfaction mechanism.
Fundamental structure and only abstraction mechanism is the constraint pattern.
Constraint satisfaction via equation solving. Event patterns have sequencing operator, support "previous" keyword for previous value.
Constraint patterns are evaluated via augmented term rewriting . Labels must obey restrictions. Linear equation solver.},
  Timestamp                = {2014-08-28}
}

@InProceedings{Horn:1992:CPB:141936.141955,
  Title                    = {Constraint Patterns As a Basis for Object Oriented Programming},
  Author                   = {Horn, Bruce},
  Booktitle                = {Conference Proceedings on Object-oriented Programming Systems, Languages, and Applications},
  Year                     = {1992},

  Address                  = {New York, NY, USA},
  Pages                    = {218--233},
  Publisher                = {ACM},
  Series                   = {OOPSLA '92},

  __markedentry            = {[hisham:1]},
  Abstract                 = {This paper describes a general abstraction mechanism called a constraint pattern, with which an object oriented language can be built. In such a language, constraint patterns play the roles of code and data abstractions, and subsume classes, instance variables, methods and control structures. Constraint patterns, a conceptual blend and extension of BETA’s patterns and Bertrand’s augmented term rewriting rules, use equation solving for constraint satisfaction, method generation, and compilation. Basing a language on this abstraction makes simple equational constraints available as a fundamental language feature, integrated with the semantics.},
  Acmid                    = {141955},
  Doi                      = {10.1145/141936.141955},
  ISBN                     = {0-201-53372-3},
  Location                 = {Vancouver, British Columbia, Canada},
  Numpages                 = {16},
  Owner                    = {hisham},
  Timestamp                = {2016-01-21},
  Url                      = {http://doi.acm.org/10.1145/141936.141955}
}

@InCollection{Hudson1992LDUI,
  Title                    = {How Programming Languages Might Better Support User Interface Tools},
  Author                   = {Scott Hudson},
  Booktitle                = {Languages for developing user interfaces},
  Publisher                = {AK Peters, Ltd.},
  Year                     = {1992},
  Chapter                  = {7},
  Editor                   = {Brad A. Myers},
  Pages                    = {105--114},

  Owner                    = {hisham},
  Review                   = {Pretty dated.
General requirements for programming languages supporting UI development:
efficient runtime, fast translation/compilation, portability, facilities for reuse, strong typing.
OO features: multiple inheritance, late binding, static type checking, separation of subtyping and inheritance, method composition
Environment: multiple views of data and aprograms, machine representation of programs, dynamic compilation},
  Timestamp                = {2014-08-28}
}

@InProceedings{Hupp:2007:SBA:1294211.1294226,
  Title                    = {Smart Bookmarks: Automatic Retroactive Macro Recording on the Web},
  Author                   = {Hupp, Darris and Miller, Robert C.},
  Booktitle                = {Proceedings of the 20th Annual ACM Symposium on User Interface Software and Technology},
  Year                     = {2007},

  Address                  = {New York, NY, USA},
  Pages                    = {81--90},
  Publisher                = {ACM},
  Series                   = {UIST '07},

  Abstract                 = {We present a new web automation system that allows users to create a smart bookmark, consisting of a starting URL plus a script of commands that returns to a particular web page or state of a web application. A smart bookmark can be requested for any page, and the necessary commands are automatically extracted from the user's interaction history. Unlike other web macro recorders, which require the user to start recording before navigating to the desired page, smart bookmarks are generated retroactively, after the user has already reached a page, and the starting point of the macro is found automatically. Smart bookmarks have a rich graphical visualization that combines textual commands, web page screenshots, and animations to explain what the bookmark does. A bookmark's script consists of keyword commands, interpreted without strict reliance on syntax, allowing bookmarks to be easily edited and shared.},
  Acmid                    = {1294226},
  Doi                      = {10.1145/1294211.1294226},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Smart_Bookmarks__Automatic_Retroactive_Macro_Recording_on_the_Web.pdf:PDF},
  ISBN                     = {978-1-59593-679-0},
  Keywords                 = {browsers, macro recording, web automation},
  Location                 = {Newport, Rhode Island, USA},
  Numpages                 = {10},
  Owner                    = {hisham},
  Review                   = {Research on EUD related to integration with the browser},
  Timestamp                = {2015-04-15},
  Url                      = {http://doi.acm.org/10.1145/1294211.1294226}
}

@Article{Isakowitz:1995:TLT:195705.195708,
  Title                    = {Toward a Logical/Physical Theory of Spreadsheet Modeling},
  Author                   = {Isakowitz, Tom\'{a}s and Schocken, Shimon and Lucas,Jr., Henry C.},
  Journal                  = {ACM Trans. Inf. Syst.},
  Year                     = {1995},

  Month                    = {jan},
  Number                   = {1},
  Pages                    = {1--37},
  Volume                   = {13},

  Abstract                 = {In spite of the increasing sophistication and power of commercial spreadsheet packages, we still lack a formal theory or a methodology to support the construction and maintenance of spreadsheet models. Using a dual logical/physical perspective, we identify four principal components that characterize any spread sheet model: schema, data, editorial, and binding. We present a factoring algorithm for identifying and extracting these components from conventional spreadsheets with minimal user intervention, and a synthesis algorithm that assists users in the construction of executable spreadsheets from reusable model components. This approach opens new possibilities for applying object-oriented and model management techniques to support the construction, sharing, and reuse of spreadsheet models in organizations. Importantly, our approach to model management and the Windows-based prototype that we have developed are designed to coexist with, rather than replace, traditional spreadsheet programs. In other words, the users are not required to learn a new modeling language; instead, their logical models and data sets are extracted from their spreadsheets transparently, as a side-effect of using standard spreadsheet programs.},
  Acmid                    = {195708},
  Address                  = {New York, NY, USA},
  Doi                      = {10.1145/195705.195708},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Toward_a_Logical_Physical_Theory_of_Spreadsheet_Modeling.pdf:PDF},
  ISSN                     = {1046-8188},
  Issue_date               = {Jan. 1995},
  Keywords                 = {model management},
  Numpages                 = {37},
  Owner                    = {hisham},
  Publisher                = {ACM},
  Review                   = {Automated tools to detect and extract a schema and database from a spreadsheet.
spreadsheet = schema + data + editorial + binding
* Schema (S): set of functional-relation definitions embedded in a spreadsheet; formal definition of a spreadsheet's logic
* Data (D): structured collection of constants on which S operates
* Editorial (E): what is left over after S and D are extracted: titles, column and row headings, documentation
* Binding (B): logical-to-physical mapping that binds S, D and E to the grid

Produce an annotated map of the spreadsheet as an intermediate step.},
  Timestamp                = {2015-11-25},
  Url                      = {http://doi.acm.org/10.1145/195705.195708}
}

@Standard{ISO29500_OfficeOpenXML,
  Title                    = {{ISO/IEC 29500-1:2012 -- Office Open XML File Formats}},
  Organization             = {{ISO}},
  Author                   = {{ISO}},
  Revision                 = {3rd},
  Url                      = {http://standards.iso.org/ittf/PubliclyAvailableStandards/c061750_ISO_IEC_29500-1_2012.zip},
  Year                     = {2012},

  File                     = {:Users/hisham/ac/dr/reading/pdf/_ISO_IEC_29500_1_2012____Office_Open_XML_File_Formats_.pdf:PDF},
  Owner                    = {hisham},
  Review                   = {Includes a description in English of the evaluation of array formulas},
  Timestamp                = {2016-01-18}
}

@InProceedings{Jarvi:2014:SPH:2658761.2658762,
  Title                    = {Specializing Planners for Hierarchical Multi-way Dataflow Constraint Systems},
  Author                   = {J\"{a}rvi, Jaakko and Foust, Gabriel and Haveraaen, Magne},
  Booktitle                = {Proceedings of the 2014 International Conference on Generative Programming: Concepts and Experiences},
  Year                     = {2014},

  Address                  = {New York, NY, USA},
  Pages                    = {1--10},
  Publisher                = {ACM},
  Series                   = {GPCE 2014},

  __markedentry            = {[hisham:1]},
  Acmid                    = {2658762},
  Doi                      = {10.1145/2658761.2658762},
  ISBN                     = {978-1-4503-3161-6},
  Keywords                 = {DFAs, Dataflow constraint systems, program specialization, user interfaces},
  Location                 = {V\&\#228;ster\&\#229;s, Sweden},
  Numpages                 = {10},
  Owner                    = {hisham},
  Timestamp                = {2016-01-21},
  Url                      = {http://doi.acm.org/10.1145/2658761.2658762}
}

@Article{Johnston:2004:ADP:1013208.1013209,
  Title                    = {Advances in Dataflow Programming Languages},
  Author                   = {Johnston, Wesley M. and Hanna, J. R. Paul and Millar, Richard J.},
  Journal                  = {ACM Comput. Surv.},
  Year                     = {2004},

  Month                    = {mar},
  Number                   = {1},
  Pages                    = {1--34},
  Volume                   = {36},

  Abstract                 = {Many developments have taken place within dataflow programming languages in the past decade. In particular, there has been a great deal of activity and advancement in the field of dataflow visual programming languages. The motivation for this article is to review the content of these recent developments and how they came about. It is supported by an initial review of dataflow programming in the 1970s and 1980s that led to current topics of research. It then discusses how dataflow programming evolved toward a hybrid von Neumann dataflow formulation, and adopted a more coarse-grained approach. Recent trends toward dataflow visual programming languages are then discussed with reference to key graphical dataflow languages and their development environments. Finally, the article details four key open topics in dataflow programming languages.},
  Acmid                    = {1013209},
  Address                  = {New York, NY, USA},
  Doi                      = {10.1145/1013208.1013209},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Advances_in_Dataflow_Programming_Languages.pdf:PDF},
  ISSN                     = {0360-0300},
  Issue_date               = {March 2004},
  Keywords                 = {Dataflow, co-ordination languages, component software, data flow visual programming, graphical programming, multithreading, software engineering},
  Numpages                 = {34},
  Owner                    = {hisham},
  Publisher                = {ACM},
  Review                   = {* Dataflow execution models. Pure dataflow: graphs with tokens firing through arcs; gate types. Structure-based versus token-based. 
* Early dataflow hardware architectures. Synchronous dataflow.
* What constitutes a dataflow language? The boundary is blurred. Core features: no side effects; locality of effect; data dependencies define scheduling; single assignment; special notation for iteration; no history in procedures. "Thus it seems that dataflow languages are essentially functional languages with an imperative syntax [Wail and Abramson 1995]."
* The experience of the 80s: dataflow languages and hardware.
* Fine vs large grained dataflow. Hybrid model, threaded dataflow. 
* Dataflow visual languages
* Open issues: representing iteration (both text and visual); data structures; nondeterminism.},
  Timestamp                = {2014-08-27},
  Url                      = {http://doi.acm.org/10.1145/1013208.1013209}
}

@Electronic{Jones2005formulas,
  Title                    = {Comments from {Tim Bray} on {OpenDocument}},
  Author                   = {Brian Jones},
  HowPublished             = {\url{http://blogs.msdn.com/b/brian_jones/archive/2005/10/04/477127.aspx}},
  Month                    = {10},
  Url                      = {http://blogs.msdn.com/b/brian_jones/archive/2005/10/04/477127.aspx},
  Year                     = {2005},

  File                     = {:Users/hisham/ac/dr/reading/pdf/Comments_from__Tim_Bray__on__OpenDocument_.pdf:PDF},
  Owner                    = {hisham},
  Timestamp                = {2016-01-18}
}

@InProceedings{Jones03User-centred,
  Title                    = {A User-Centred Approach to Functions in {Excel}},
  Author                   = {Simon Peyton Jones and Alan Blackwell and Margaret Burnett},
  Booktitle                = {In ICFP '03: Proceedings of the eighth ACM SIGPLAN international conference on Functional programming},
  Year                     = {2003},
  Pages                    = {165--176},
  Publisher                = {ACM Press},

  Owner                    = {hisham},
  Timestamp                = {2014-12-09}
}

@InProceedings{Kaufmann:2009:FVL:1637837.1637851,
  Title                    = {Formal Verification of LabVIEW Programs Using the ACL2 Theorem Prover},
  Author                   = {Kaufmann, Matt and Kornerup, Jacob and Reitblatt, Mark},
  Booktitle                = {8th International Workshop on the ACL2 Theorem Prover and Its Applications},
  Year                     = {2009},

  Address                  = {New York, NY, USA},
  Pages                    = {82--89},
  Publisher                = {ACM},
  Series                   = {ACL2 '09},

  Abstract                 = {The LabVIEW™ system is based on a graphical dataflow language, and is widely used for data acquisition, instrument control and industrial automation. This paper presents a methodology for annotating LabVIEW programs with their specifications, translating those annotated programs into ACL2, and proving the translated specifications with ACL2. Our system supports verification of inductive invariants of bounded loops as well as assertions about straight-line code. Our verification methodology supports the user by generating a highly structured set of proof obligations, many or all of which are discharged automatically. This methodology makes extensive use of hints to support scalability, including careful theory control as well as functional instantiation that avoids explicit use of induction. We describe the design, applicability and limitations of the framework. We also present several examples demonstrating our approach.},
  Acmid                    = {1637851},
  Doi                      = {10.1145/1637837.1637851},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Formal_Verification_of_LabVIEW_Programs_Using_the_ACL2_Theorem_Prover.pdf:PDF},
  ISBN                     = {9781-60558-742-4},
  Keywords                 = {ACL2, LabVIEW, formal verification, translator},
  Location                 = {Boston, Massachusetts, USA},
  Numpages                 = {8},
  Owner                    = {hisham},
  Review                   = {formalizes a purely functional subset of LabVIEW using ACL2, a total-functional language derived from Common Lisp},
  Timestamp                = {2015-10-07},
  Url                      = {http://doi.acm.org/10.1145/1637837.1637851}
}

@Article{kavi2015dataflow,
  Title                    = {Concurrency, Synchronization, and Speculation--The Dataflow Way},
  Author                   = {Krishna Kavi and Charles Shelor and Domenico Pace},
  Journal                  = {Advances in Computers},
  Year                     = {2015},
  Pages                    = {47--104},
  Volume                   = {96},

  Abstract                 = {This chapter provides a brief overview of dataflow, including concepts, languages, historical
architectures, and recent architectures. It is to serve as an introduction to and
summary of the development of the dataflow paradigm during the past 45 years.
Dataflow has inherent advantages in concurrency, synchronization, and speculation
over control flow or imperative implementations. However, dataflow has its own set
of challenges to efficient implementations. This chapter addresses the advantages
and challenges of dataflow to set a context for the remainder of this issue.},
  Chapter                  = {2},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Concurrency__Synchronization_and_Speculation--The_Dataflow_Way.pdf:PDF},
  Owner                    = {hisham},
  Publisher                = {Elsevier},
  Review                   = {Contains a nice review of the dataflow model in general, and especially a review of the well-known historical dataflow languages ID, VAL and SISAL.
Second half of the article discusses recent (2000s-2010s) dataflow hardware architectures.},
  Timestamp                = {2017-01-02}
}

@InProceedings{Klein:2001:NVR:1766791.1766798,
  Title                    = {Null Values in Relational Databases and Sure Information Answers},
  Author                   = {Klein, Hans-Joachim},
  Booktitle                = {Proceedings of the 2Nd International Conference on Semantics in Databases},
  Year                     = {2003},

  Address                  = {Berlin, Heidelberg},
  Pages                    = {119--138},
  Publisher                = {Springer-Verlag},

  Acmid                    = {1766798},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Null_Values_in_Relational_Databases_and_Sure_Information_Answers.pdf:PDF},
  ISBN                     = {3-540-00957-4},
  Location                 = {Dagstuhl Castle, Germany},
  Numpages                 = {20},
  Owner                    = {hisham},
  Review                   = {Discusses the meaning of null values, considering various semantics:
* non-applicable or nothing nulls: the knowledge about the value is complete but is not representable by any value
* value existent but unknown
It contrasts open-world and closed-world assumptions.
SQL uses the "unknown" interpretation, leads to unwanted results if in our model null means N/A.
Warns of "peculiarities" that arise in SQL due to use of three-valued logic.},
  Timestamp                = {2014-12-12},
  Url                      = {http://dl.acm.org/citation.cfm?id=1766791.1766798}
}

@Article{Kosinski:1973:DFL:390014.808289,
  Title                    = {A Data Flow Language for Operating Systems Programming},
  Author                   = {Kosinski, Paul R.},
  Journal                  = {SIGPLAN Not.},
  Year                     = {1973},

  Month                    = {jan},
  Number                   = {9},
  Pages                    = {89--94},
  Volume                   = {8},

  Abstract                 = {This paper describes a graphical programming language based on the concept of pure data flow sequencing of computations. Programs in this language are constructed through function definition and composition, and are based on the primitive notions of iteration, recursion, conditional expression, data replication, aggregation and selection, and the usual arithmetic and logical operations. Various useful programming devices such as the DO loop and, surprisingly, the memory cell are defined in terms of these primitives. Programs in this language are determinate in operation unless indeterminism is explicitly introduced. The utility of this language for designing and implementing operating systems is discussed.},
  Acmid                    = {808289},
  Address                  = {New York, NY, USA},
  Doi                      = {10.1145/390014.808289},
  File                     = {:Users/hisham/ac/dr/reading/pdf/A_Data_Flow_Language_for_Operating_Systems_Programming.pdf:PDF},
  ISSN                     = {0362-1340},
  Issue_date               = {September 1973},
  Numpages                 = {6},
  Owner                    = {hisham},
  Publisher                = {ACM},
  Timestamp                = {2016-01-21},
  Url                      = {http://doi.acm.org/10.1145/390014.808289}
}

@Article{Krasner1988,
  Title                    = {A Description of the {Model-View-Controller} User Interface Paradigm in the {Smalltalk-80} system},
  Author                   = {Krasner, Glenn E and Pope, Stephen T and others},
  Journal                  = {Journal of object oriented programming},
  Year                     = {1988},
  Number                   = {3},
  Pages                    = {26--49},
  Volume                   = {1},

  Abstract                 = {This essay describes the Model-View-Controller (MVC) programming paradigm and methodology used in the Smalltalk-80TM programming system. MVC programming is the application of a three-way factoring, whereby objects of different classes take over the operations related to the application domain, the display of the application's state, and the user interaction with the model and the view. We present several extended examples of MVC implementations and of the layout of composite application views. The Appendices provide reference materials for the Smalltalk-80 programmer wishing to understand and use MVC better within the Smalltalk-80 system.},
  File                     = {:Users/hisham/ac/dr/reading/pdf/A_Description_of_the__Model_View_Controller__User_Interface_Paradigm_in_the__Smalltalk_80__system.pdf:PDF},
  Keywords                 = {MVC, Smalltalk},
  Owner                    = {hisham},
  Review                   = {Definition of MVC in this paper:
Model: domain-specific software simulation or implementation of the app's central structure.
Views: deal with everything graphical
Controller: interface between associated models and views and the input devices.

Views and Controllers are more tightly coupled. Controllers seem to me an implementation artifact.
Some controllers embed some visual aspects even (context menu controllers).
Composing interfaces, broadcasting change to dependent views, etc.
Discussion of various examples.},
  Timestamp                = {2014-08-27},
  Url                      = {http://heaveneverywhere.com/stp/PostScript/mvc.pdf}
}

@InProceedings{Lasecki:2015:ACU:2702123.2702565,
  Title                    = {Apparition: Crowdsourced User Interfaces That Come to Life As You Sketch Them},
  Author                   = {Lasecki, Walter S. and Kim, Juho and Rafter, Nick and Sen, Onkur and Bigham, Jeffrey P. and Bernstein, Michael S.},
  Booktitle                = {Proceedings of the 33rd Annual ACM Conference on Human Factors in Computing Systems},
  Year                     = {2015},

  Address                  = {New York, NY, USA},
  Pages                    = {1925--1934},
  Publisher                = {ACM},
  Series                   = {CHI '15},

  __markedentry            = {[hisham:1]},
  Acmid                    = {2702565},
  Doi                      = {10.1145/2702123.2702565},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Apparition__Crowdsourced_User_Interfaces_That_Come_to_Life_As_You_Sketch_Them.pdf:PDF},
  ISBN                     = {978-1-4503-3145-6},
  Keywords                 = {crowdsourcing, human computation, rapid prototyping},
  Location                 = {Seoul, Republic of Korea},
  Numpages                 = {10},
  Owner                    = {hisham},
  Timestamp                = {2015-05-18},
  Url                      = {http://doi.acm.org/10.1145/2702123.2702565}
}

@InProceedings{VPL1991,
  Title                    = {VPL: An Active, Declarative Visual Programming System},
  Author                   = {David Lau-Kee and Adam Billyard and Robin Faichney and Yasuo Kozato and Paul Otto and Mark Smith and Ian Wilkinson},
  Booktitle                = {Proceedings 1991 IEEE Workshop on Visual Languages},
  Year                     = {1991},
  Month                    = {Oct},
  Pages                    = {40-46},

  __markedentry            = {[hisham:1]},
  Abstract                 = {VPL is a visual programming language and environment for interactive image processing. VPL uses a novel system architecture which separates interaction and computation components in order to provide a highly interactive visual programming user-interface. VPL is based on a declarative, demand driven dataflow model of computation. It is a practical, usable visual programming system, integrating tools for browsing, inspecting and editing components and documentation. VPL also provides data persistence and data import/export mechanisms. The visual programming model supports both function extensibility and higher order functions, allowing users to build their own program dataflow structures within the VPL environment},
  Doi                      = {10.1109/WVL.1991.238852},
  File                     = {:Users/hisham/ac/dr/reading/pdf/VPL.pdf:PDF},
  Keywords                 = {programming environments;user interfaces;visual languages;visual programming;VPL;dataflow structures;declarative visual programming system;demand driven dataflow model;documentation;function extensibility;interactive image processing;user-interface;visual programming language;Computational modeling;Computer architecture;Computer interfaces;Computer languages;Documentation;Europe;Functional programming;Image processing;Libraries;Production systems},
  Owner                    = {hisham},
  Timestamp                = {2017-01-12},
  Url                      = {https://camazotz.com/docs/vpl.pdf}
}

@Article{Lee1987synchdataflow,
  Title                    = {Synchronous data flow},
  Author                   = {E. A. Lee and D. G. Messerschmitt},
  Journal                  = {Proceedings of the IEEE},
  Year                     = {1987},

  Month                    = {Sept},
  Number                   = {9},
  Pages                    = {1235-1245},
  Volume                   = {75},

  Abstract                 = {Data flow is a natural paradigm for describing DSP applications for concurrent implementation on parallel hardware. Data flow programs for signal processing are directed graphs where each node represents a function and each arc represents a signal path. Synchronous data flow (SDF) is a special case of data flow (either atomic or large grain) in which the number of data samples produced or consumed by each node on each invocation is specified a priori. Nodes can be scheduled statically (at compile time) onto single or parallel programmable processors so the run-time overhead usually associated with data flow evaporates. Multiple sample rates within the same system are easily and naturally handled. Conditions for correctness of SDF graph are explained and scheduling algorithms are described for homogeneous parallel processors sharing memory. A preliminary SDF software system for automatically generating assembly language code for DSP microcomputers is described. Two new efficiency techniques are introduced, static buffering and an extension to SDF to efficiently implement conditionals.},
  Doi                      = {10.1109/PROC.1987.13876},
  ISSN                     = {0018-9219},
  Keywords                 = {Assembly systems;Digital signal processing;Flow graphs;Hardware;Microcomputers;Processor scheduling;Runtime;Scheduling algorithm;Signal processing;Software systems},
  Owner                    = {hisham},
  Timestamp                = {2017-03-12}
}

@InProceedings{Leshed:2008:CAS:1357054.1357323,
  Title                    = {CoScripter: Automating \& Sharing How-to Knowledge in the Enterprise},
  Author                   = {Leshed, Gilly and Haber, Eben M. and Matthews, Tara and Lau, Tessa},
  Booktitle                = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
  Year                     = {2008},

  Address                  = {New York, NY, USA},
  Pages                    = {1719--1728},
  Publisher                = {ACM},
  Series                   = {CHI '08},

  Abstract                 = {Modern enterprises are replete with numerous online processes. Many must be performed frequently and are tedious, while others are done less frequently yet are complex or hard to remember. We present interviews with knowledge workers that reveal a need for mechanisms to automate the execution of and to share knowledge about these processes. In response, we have developed the CoScripter system (formerly Koala [11]), a collaborative scripting environment for recording, automating, and sharing web-based processes. We have deployed CoScripter within a large corporation for more than 10 months. Through usage log analysis and interviews with users, we show that CoScripter has addressed many user automation and sharing needs, to the extent that more than 50 employees have voluntarily incorporated it into their work practice. We also present ways people have used CoScripter and general issues for tools that support automation and sharing of how-to knowledge.},
  Acmid                    = {1357323},
  Doi                      = {10.1145/1357054.1357323},
  File                     = {:Users/hisham/ac/dr/reading/pdf/CoScripter__Automating____Sharing_How_to_Knowledge_in_the_Enterprise.pdf:PDF},
  ISBN                     = {978-1-60558-011-1},
  Keywords                 = {automation, knowledge sharing, procedural knowledge, programming-by-demonstration, scripting, user study, wiki},
  Location                 = {Florence, Italy},
  Numpages                 = {10},
  Owner                    = {hisham},
  Review                   = {CoScripter, the tool on which SideTalk is based. Tool for end-user programming with a control-oriented interface.},
  Timestamp                = {2015-10-07},
  Url                      = {http://doi.acm.org/10.1145/1357054.1357323}
}

@InProceedings{Lin2008Parameterized,
  Title                    = {A parameterized dataflow language extension for embedded streaming systems},
  Author                   = {Yuan Lin and Yoonseo Choi and Mahlke, S. and Mudge, T. and Chakrabarti, C.},
  Booktitle                = {Embedded Computer Systems: Architectures, Modeling, and Simulation, 2008. SAMOS 2008. International Conference on},
  Year                     = {2008},
  Month                    = {July},
  Pages                    = {10-17},

  __markedentry            = {[hisham:1]},
  Abstract                 = {Many embedded DSP systems can be characterized as streaming applications. Imperative programming languages are ill suited for describing the concurrency within these DSP systems. SPEX is a language extension designed to let the programmers describe the inherent parallelism within DSP systems. In this paper, we highlight SPEXpsilas language features for describing the streaming computation and communication patterns of DSP systems, and allowing the compiler to generate efficient code for embedded DSP architectures. This language extension is based on the parameterized dataflow computation model, with modifications to better describe DSP systemspsila complex streaming patterns. SPEX is applied as an extension onto the C++ programming language. It consists of a set of language constructs for describing the semantics of parameterized dataflow computations, and a set of language restrictions for helping the embedded compilation process. In this paper, the W-CDMA wireless protocol is used as our case study.},
  Doi                      = {10.1109/ICSAMOS.2008.4664841},
  File                     = {:Users/hisham/ac/dr/reading/pdf/A_parameterized_dataflow_language_extension_for_embedded_streaming_systems.pdf:PDF},
  Keywords                 = {C++ language;code division multiple access;embedded systems;parallel languages;C++ programming language;DSP systems;W-CDMA wireless protocol;embedded compilation;embedded streaming systems;parameterized dataflow language extension;Computational modeling;Computer architecture;Computer languages;Concurrent computing;Digital signal processing;Embedded computing;Multiaccess communication;Parallel processing;Programming profession;Wireless application protocol},
  Owner                    = {hisham},
  Timestamp                = {2017-03-09},
  Url                      = {http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=4664841}
}

@InProceedings{Liu:2007:VLE:1273714.1273728,
  Title                    = {A Visual Language and Environment for Specifying User Interface Event Handling in Design Tools},
  Author                   = {Liu, Na and Hosking, John and Grundy, John},
  Booktitle                = {Proceedings of the Eight Australasian Conference on User Interface - Volume 64},
  Year                     = {2007},

  Address                  = {Darlinghurst, Australia, Australia},
  Pages                    = {87--94},
  Publisher                = {Australian Computer Society, Inc.},
  Series                   = {AUIC '07},

  __markedentry            = {[hisham:1]},
  Abstract                 = {End users often need the ability to tailor diagramming-based design tools and to specify dynamic interactive behaviours of graphical user interfaces. However most want to avoid having to use textual scripting languages or programming language approaches directly. We describe a new visual language for user interface event handling specification targeted at end users. Our visual language provides end users with abstract ways to express both simple and complex event handling mechanisms via visual specifications. These specifications incorporate event filtering, tool state querying and action invocation. We describe our language, its incorporation into a meta-tool for building visual design environments, examples of its use and results of evaluations of its effectiveness.},
  Acmid                    = {1273728},
  File                     = {:Users/hisham/ac/dr/reading/pdf/A_Visual_Language_and_Environment_for_Specifying_User_Interface_Event_Handling_in_Design_Tools.pdf:PDF},
  ISBN                     = {1-920682-46-5},
  Keywords                 = {event handling, meta tool, user interface, visual language},
  Location                 = {Ballarat, Victoria, Australia},
  Numpages                 = {8},
  Owner                    = {hisham},
  Timestamp                = {2015-05-18},
  Url                      = {http://dl.acm.org/citation.cfm?id=1273714.1273728}
}

@Article{loui2008scripting,
  Title                    = {In Praise of Scripting: Real Programming Pragmatics},
  Author                   = {Ronald P. Loui},
  Journal                  = {Computer},
  Year                     = {2008},

  Month                    = {jun},
  Number                   = {9162},
  Pages                    = {22--26},
  Volume                   = {18},

  Abstract                 = {The author recommends that that scripting, not Java, be taught first, asserting that students should learn to love their own possibilities before they learn to loathe other people’s restrictions.},
  File                     = {:Users/hisham/ac/dr/reading/pdf/in_praise_of_scripting.pdf:PDF},
  Owner                    = {hisham},
  Timestamp                = {2016-10-12}
}

@InProceedings{Mackay:1990:PSC:99332.99356,
  Title                    = {Patterns of Sharing Customizable Software},
  Author                   = {Mackay, Wendy E.},
  Booktitle                = {Proceedings of the 1990 ACM Conference on Computer-supported Cooperative Work},
  Year                     = {1990},

  Address                  = {New York, NY, USA},
  Pages                    = {209--221},
  Publisher                = {ACM},
  Series                   = {CSCW '90},

  Acmid                    = {99356},
  Doi                      = {10.1145/99332.99356},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Patterns_of_Sharing_Customizable_Software.pdf:PDF},
  ISBN                     = {0-89791-402-3},
  Location                 = {Los Angeles, California, USA},
  Numpages                 = {13},
  Owner                    = {hisham},
  Timestamp                = {2016-01-08},
  Url                      = {http://doi.acm.org/10.1145/99332.99356}
}

@InProceedings{MacLean:1990:USP:97243.97271,
  Title                    = {User-tailorable Systems: Pressing the Issues with Buttons},
  Author                   = {MacLean, Allan and Carter, Kathleen and L\"{o}vstrand, Lennart and Moran, Thomas},
  Booktitle                = {Proceedings of the SIGCHI Conference on Human Factors in Computing Systems},
  Year                     = {1990},

  Address                  = {New York, NY, USA},
  Pages                    = {175--182},
  Publisher                = {ACM},
  Series                   = {CHI '90},

  Acmid                    = {97271},
  Doi                      = {10.1145/97243.97271},
  File                     = {:Users/hisham/ac/dr/reading/pdf/User_tailorable_Systems__Pressing_the_Issues_with_Buttons.pdf:PDF},
  ISBN                     = {0-201-50932-6},
  Location                 = {Seattle, Washington, USA},
  Numpages                 = {8},
  Owner                    = {hisham},
  Timestamp                = {2016-01-08},
  Url                      = {http://doi.acm.org/10.1145/97243.97271}
}

@Book{malik2011javatm,
  Title                    = {Java Programming: From Problem Analysis to Program Design},
  Author                   = {Malik, D.},
  ISBN                     = {9781111530532},
  Publisher                = {Cengage Learning},
  Year                     = {2011},
  Series                   = {Introduction to Programming Series},

  Lccn                     = {2010940363},
  Owner                    = {hisham},
  Pages                    = {26},
  Review                   = {Compares programming to cooking in page 26.},
  Timestamp                = {2015-01-14},
  Url                      = {https://books.google.com.br/books?id=FAe0utEYqKoC}
}

@Article{xorshift,
  Title                    = {Xorshift RNGs},
  Author                   = {George Marsaglia},
  Journal                  = {Journal of Statistical Software},
  Year                     = {2003},
  Number                   = {1},
  Pages                    = {1--6},
  Volume                   = {8},

  Abstract                 = {Description of a class of simple, extremely fast random number generators (RNGs) with periods 2k - 1 for k = 32, 64, 96, 128, 160, 192. These RNGs seem to pass tests of randomness very well.},
  Doi                      = {10.18637/jss.v008.i14},
  ISSN                     = {1548-7660},
  Owner                    = {hisham},
  Review                   = {simple PRNG used in the LvInterpreter},
  Timestamp                = {2017-03-08},
  Url                      = {https://www.jstatsoft.org/index.php/jss/article/view/v008i14}
}

@Article{DBLP:journals/corr/Martini15,
  Title                    = {Several types of types in programming languages},
  Author                   = {Simone Martini},
  Journal                  = {CoRR},
  Year                     = {2015},
  Volume                   = {abs/1510.03726},

  Abstract                 = {Types are an important part of any modern programming language, but we often forget that the concept of type we understand nowadays is not the same it was perceived in the sixties. Moreover, we conflate the concept of "type" in programming languages with the concept of the same name in mathematical logic, an identification that is only the result of the convergence of two different paths, which started apart with different aims. The paper will present several remarks (some historical, some of more conceptual character) on the subject, as a basis for a further investigation. The thesis we will argue is that there are three different characters at play in programming languages, all of them now called types: the technical concept used in language design to guide implementation; the general abstraction mechanism used as a modelling tool; the classifying tool inherited from mathematical logic. We will suggest three possible dates ad quem for their presence in the programming language literature, suggesting that the emergence of the concept of type in computer science is relatively independent from the logical tradition, until the Curry-Howard isomorphism will make an explicit bridge between them.},
  Bibsource                = {dblp computer science bibliography, http://dblp.org},
  Biburl                   = {http://dblp.uni-trier.de/rec/bib/journals/corr/Martini15},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Several_types_of_types_in_programming_languages.pdf:PDF},
  Review                   = {Light historical discussion on the historical uses of the word "type" in CS.},
  Timestamp                = {2015-11-01},
  Url                      = {http://arxiv.org/abs/1510.03726}
}

@InCollection{Masui1992,
  Title                    = {User Interface Programming with Cooperative Processes},
  Author                   = {Toshiyuki Masui},
  Booktitle                = {Languages for developing user interfaces},
  Publisher                = {AK Peters, Ltd.},
  Year                     = {1992},
  Chapter                  = {15},
  Editor                   = {Brad A. Myers},
  Pages                    = {261--278},

  Owner                    = {hisham},
  Review                   = {Low-level problems in writing UI programs: 
* structure and control flow of application and interface programs 
* single I/O at one time
Linda: parallel execution specification langauge using tuples in tuple spaces.
Using Linda for UI programming.
Decoupling of UI and application for solving control-flow problems.
Parallel UI toolkit: widgets communicate via tuple space.
Using multiple languages, communicating via Linda.
Limitations of Linda: bandwidth of I/O; sequencing of tuples.},
  Timestamp                = {2014-08-28}
}

@InProceedings{McDirmid:2014:PMT:2661136.2661145,
  Title                    = {Programming with Managed Time},
  Author                   = {McDirmid, Sean and Edwards, Jonathan},
  Booktitle                = {Proceedings of the 2014 ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming \&\#38; Software},
  Year                     = {2014},

  Address                  = {New York, NY, USA},
  Pages                    = {1--10},
  Publisher                = {ACM},
  Series                   = {Onward! '14},

  Abstract                 = {Most languages expose the computer's ability to globally read and write memory at any time. Programmers must then choreograph control flow so all reads and writes occur in correct relative orders, which can be difficult particularly when dealing with initialization, reactivity, and concurrency. Just as many languages now manage memory to unburden us from properly freeing memory, they should also manage time to automatically order memory accesses for us in the interests of comprehensibility, correctness, and simplicity. Time management is a general language feature with a large design space that is largely unexplored; we offer this perspective to relate prior work and guide future research.

We introduce Glitch as a form of managed time that replays code for an appearance of simultaneous memory updates, avoiding the need for manual order. The key to such replay reaching consistent program states is an ability to reorder and rollback updates as needed, restricting the imperative model while retaining the basic concepts of memory access and control flow. This approach can also handle code to enable live programming that incrementally revises program executions in an IDE under arbitrary code changes.},
  Acmid                    = {2661145},
  Doi                      = {10.1145/2661136.2661145},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Programming_with_Managed_Time.pdf:PDF},
  ISBN                     = {978-1-4503-3210-1},
  Keywords                 = {live programming, programming models},
  Location                 = {Portland, Oregon, USA},
  Numpages                 = {10},
  Owner                    = {hisham},
  Review                   = {Presents Glitch, which is a platform for implementing programming systems with managed time.
Features a proof-of-concept language, YinYang, that uses managed time.
The YinYang live coding IDE is written in C# using Glitch as a library.
This paper discusses design issues and how they affect the implementation of this model, in which code is replayed as needed.},
  Timestamp                = {2014-11-10},
  Url                      = {http://doi.acm.org/10.1145/2661136.2661145}
}

@Electronic{Microsoft2016ArrayFormulas,
  Title                    = {Guidelines and examples of array formulas},
  Author                   = {Microsoft},
  HowPublished             = {\url{https://support.office.com/en-us/article/Guidelines-and-examples-of-array-formulas-3BE0C791-3F89-4644-A062-8E6E9ECEE523}},
  Url                      = {https://support.office.com/en-us/article/Guidelines-and-examples-of-array-formulas-3BE0C791-3F89-4644-A062-8E6E9ECEE523},
  Year                     = {2016},

  File                     = {:Users/hisham/ac/dr/reading/pdf/Guidelines_and_examples_of_array_formulas.pdf:PDF},
  Owner                    = {hisham},
  Review                   = {Array formulas explained by examples, no complete definition.},
  Timestamp                = {2016-01-18}
}

@Electronic{Microsoft2014ByTheNumbers,
  Title                    = {Microsoft By The Numbers},
  Author                   = {Microsoft},
  HowPublished             = {\url{https://news.microsoft.com/bythenumbers/ms_numbers.pdf}},
  Url                      = {https://news.microsoft.com/bythenumbers/ms_numbers.pdf},
  Year                     = {2014},

  File                     = {:Users/hisham/ac/dr/reading/pdf/Microsoft_By_The_Numbers.pdf:PDF},
  Owner                    = {hisham},
  Review                   = {Contains statistic of 1.2 billion Office users.},
  Timestamp                = {2016-01-18}
}

@Article{Modugno:1997:GRP:264645.264659,
  Title                    = {Graphical Representation of Programs in a Demonstrational Visual Shell\&Mdash;an Empirical Evaluation},
  Author                   = {Modugno, Francesmary and Corbett, Albert T. and Myers, Brad A.},
  Journal                  = {ACM Trans. Comput.-Hum. Interact.},
  Year                     = {1997},

  Month                    = {sep},
  Number                   = {3},
  Pages                    = {276--308},
  Volume                   = {4},

  Abstract                 = {An open question in the area of Programming by Demonstration (PBD) is how to best represent the inferred program. Without a way to view, edit, and share programs, PBD systems will never reach their full potential. We designed and implemented two graphical representation languages for a PBD desktop similar to the Apple Macintosh Finder. Although a user study showed that both languages enabled nonprogrammers to generate and comprehend programs, the study also revealed that the language that more closely reflected the desktop domain doubled users' abilities to accurately generate programs. Trends suggest that the same language was easier for users to comprehend. These findings suggest that it is possible for a PBD system to enable nonprogrammers to construct programs and that the form of the representation can impact the PBD system's effectiveness. A paper-and-pencil evaluation of the two versions of the PBD desktop prior to the study supported these finding and provided interesting feedback on the interaction between usability evaluations and user studies. In particular, the comparison of the paper-and-pencil evaluation with the empirical evaluation suggested that nonempirical evaluation techniques can provide guidance into how to interpret empirical data and, in particular, that PBD systems need to provide support for programming-strategy selection in order to be successful.},
  Acmid                    = {264659},
  Address                  = {New York, NY, USA},
  Doi                      = {10.1145/264645.264659},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Graphical_Representation_of_Programs_in_a_Demonstrational_Visual_Shell__Mdash_an_Empirical_Evaluation.pdf:PDF},
  ISSN                     = {1073-0516},
  Issue_date               = {Sept. 1997},
  Keywords                 = {programming by demonstration, pursuit},
  Numpages                 = {33},
  Owner                    = {hisham},
  Publisher                = {ACM},
  Timestamp                = {2015-04-14},
  Url                      = {http://doi.acm.org/10.1145/264645.264659}
}

@InProceedings{Mok1998RTLLabVIEW,
  Title                    = {An RTL semantics for LabVIEW},
  Author                   = {Mok, A.K. and Stuart, D.},
  Booktitle                = {Aerospace Conference, 1998 IEEE},
  Year                     = {1998},
  Month                    = {Mar},
  Pages                    = {61-71 vol.4},
  Volume                   = {4},

  Abstract                 = {LabVIEW is a commercial tool for designing virtual instruments, software substitutes for conventional laboratory instrument, that is poised for use in control and embedded applications of which avionics is an important area. To successfully transition to this new environment, LabVIEW must have a well-defined real-time semantics, e.g., for specifying stringent real-time requirements. Real Time Logic (RTL) is a first order logic for describing real-time and embedded systems. After introducing LabVIEW and RTL, we propose an RTL semantics for the basic constructs of LabVIEW and examine several of the issues that must be resolved in order to finalize an effective semantics. Providing a semantics for LabVIEW virtual instruments in RTL is a first step to its use in real-time embedded aerospace applications},
  Doi                      = {10.1109/AERO.1998.682156},
  File                     = {:Users/hisham/ac/dr/reading/pdf/An_RTL_semantics_for_LabVIEW.pdf:PDF},
  ISSN                     = {1095-323X},
  Keywords                 = {aerospace computing;avionics;electronic design automation;embedded systems;logic CAD;virtual instrumentation;LabVIEW;RTL semantics;Real Time Logic;avionics;control applications;embedded applications;first order logic;real-time semantics;virtual instruments;Aerospace electronics;Application software;Embedded software;Embedded system;Instruments;Laboratories;Logic;Real time systems;Software design;Software tools},
  Owner                    = {hisham},
  Review                   = {Modeling of LabVIEW in RTL (real-time logic). Notes the difficulty in specifying LabVIEW having little source material, and that design decisions have to be made where it is not clear.},
  Timestamp                = {2015-10-07},
  Url                      = {http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=682156}
}

@InProceedings{Monteiro:2013:GBF:2577101.2577124,
  Title                    = {Going Back and Forth in Metacommunication Threads},
  Author                   = {Monteiro, Ingrid Teixeira and Tolmasquim, Eduardo Tiomno and de Souza, Clarisse Sieckenius},
  Booktitle                = {12th Brazilian Symposium on Human Factors in Computing Systems},
  Year                     = {2013},

  Address                  = {Porto Alegre, Brazil, Brazil},
  Pages                    = {102--111},
  Publisher                = {SBC},
  Series                   = {IHC '13},

  Abstract                 = {This paper presents an exploratory study about how savvy end users configure return points in mediated interactions with Web applications through WNH (Web Navigation Helper), a user agent that supports rephrasing, explanation, commentary and elaboration of interaction in scripted Web activities. The study is part of a long-term research on self-expression through software programming. Savvy users creating mediation dialogs for the benefit of other users (third parties) are actually engaged in a human-computer interaction (HCI) design process involved in end user development (EUD). The study shows that decisions about when, where, how and why to go back to previous points in the design of mediated conversation with WNH are very complex, even for savvy users. More importantly, we collected powerful evidence of the participants' interpretation of what interaction through WNH is all about. We believe that such evidence stands for their intuitions about HCI in a broader sense. The main contribution of the study is thus to illuminate aspects of EUD and HCI that haven't been discussed to-date and to propose questions for new kinds of investigation.},
  Acmid                    = {2577124},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Going_Back_and_Forth_in_Metacommunication_Threads.pdf:PDF},
  ISBN                     = {978-85-7669-278-2},
  Keywords                 = {back navigation, dialog management, end-user development, mediated metacommunication},
  Location                 = {Manaus, Brazil},
  Numpages                 = {10},
  Owner                    = {hisham},
  Review                   = {Research using SideTalk, a tool from PUC-Rio's SERG based on CoScripter which employs a storytelling paradigm, and it therefore better suited for control-oriented interaction. It is an example where dataflow does not fit.},
  Timestamp                = {2015-10-07},
  Url                      = {http://dl.acm.org/citation.cfm?id=2577101.2577124}
}

@Article{Mosconi:2000:ICD:2245742.2245907,
  Title                    = {Iteration Constructs in Data-flow Visual Programming Languages},
  Author                   = {Mosconi, M. and Porta, M.},
  Journal                  = {Comput. Lang.},
  Year                     = {2000},

  Month                    = jul,
  Number                   = {2-4},
  Pages                    = {67--104},
  Volume                   = {26},

  __markedentry            = {[hisham:1]},
  Acmid                    = {2245907},
  Address                  = {Tarrytown, NY, USA},
  Doi                      = {10.1016/S0096-0551(01)00009-1},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Iteration_Constructs_in_Data-flow-Visual_Programming_Languages.pdf:PDF},
  ISSN                     = {0096-0551},
  Issue_date               = {July, 2000},
  Keywords                 = {Data-flow visual languages, Iterations, Visual programming},
  Numpages                 = {38},
  Owner                    = {hisham},
  Publisher                = {Pergamon Press, Inc.},
  Timestamp                = {2017-03-08},
  Url                      = {http://dx.doi.org/10.1016/S0096-0551(01)00009-1}
}

@Article{Muhammad2007capis,
  Title                    = {C APIs in Extension and Extensible Languages},
  Author                   = {Hisham Muhammad and Roberto Ierusalimschy},
  Journal                  = {j-jucs},
  Year                     = {2007},

  Month                    = {jun},
  Number                   = {6},
  Pages                    = {839--853},
  Volume                   = {13},

  Abstract                 = {Scripting languages are used in conjuction with C code in two ways: as extension languages, where the interpreter is embedded as a library into an application; or as extensible languages, where the interpreter loads C code as add-on modules. These two scenarios share many similarities, as in both of them two-way communication of code and data needs to take place. However, the differences between them impose design tradeoffs that affect the C API that bridges the two languages, often making a scripting language more suitable for extending than embedding, or vice-versa. This paper discusses how these tradeoffs are handled in the APIs of popular scripting languages, and the impact on their use as embedded or extensible languages.},
  Date                     = {2007-06-28},
  File                     = {:Users/hisham/ac/dr/reading/pdf/C_APIs_in_Extension_and_Extensible_Languages.pdf:PDF},
  Owner                    = {hisham},
  Timestamp                = {2015-03-29},
  Url                      = {http://www.jucs.org/jucs_13_6/c_apis_in_extension}
}

@InProceedings{Murray:2013:NTD:2517349.2522738,
  Title                    = {Naiad: A Timely Dataflow System},
  Author                   = {Murray, Derek G. and McSherry, Frank and Isaacs, Rebecca and Isard, Michael and Barham, Paul and Abadi, Mart\'{\i}n},
  Booktitle                = {Proceedings of the Twenty-Fourth ACM Symposium on Operating Systems Principles},
  Year                     = {2013},

  Address                  = {New York, NY, USA},
  Pages                    = {439--455},
  Publisher                = {ACM},
  Series                   = {SOSP '13},

  Abstract                 = {Naiad is a distributed system for executing data parallel, cyclic dataflow programs. It offers the high throughput of batch processors, the low latency of stream processors, and the ability to perform iterative and incremental computations. Although existing systems offer some of these features, applications that require all three have relied on multiple platforms, at the expense of efficiency, maintainability, and simplicity. Naiad resolves the complexities of combining these features in one framework.

A new computational model, timely dataflow, underlies Naiad and captures opportunities for parallelism across a wide class of algorithms. This model enriches dataflow computation with timestamps that represent logical points in the computation and provide the basis for an efficient, lightweight coordination mechanism.

We show that many powerful high-level programming models can be built on Naiad's low-level primitives, enabling such diverse tasks as streaming data analysis, iterative machine learning, and interactive graph mining. Naiad outperforms specialized systems in their target application domains, and its unique features enable the development of new high-performance applications.},
  Acmid                    = {2522738},
  Doi                      = {10.1145/2517349.2522738},
  ISBN                     = {978-1-4503-2388-8},
  Location                 = {Farminton, Pennsylvania},
  Numpages                 = {17},
  Owner                    = {hisham},
  Review                   = {"Structured loops" proposed here is exactly the same as LabVIEW loops.},
  Timestamp                = {2017-03-09},
  Url                      = {http://doi.acm.org/10.1145/2517349.2522738}
}

@InCollection{Myers1992LDUI,
  Title                    = {Ideas from {Garnet} for Future User Interface Programming Languages},
  Author                   = {Brad A Myers},
  Booktitle                = {Languages for developing user interfaces},
  Publisher                = {AK Peters, Ltd.},
  Year                     = {1992},
  Chapter                  = {10},
  Editor                   = {Brad A. Myers},
  Pages                    = {147--160},

  Owner                    = {hisham},
  Review                   = {Garnet user interface development environment:
* Prototype-based OO 
* Constraint system: arbitrary Common Lisp expressions, one-way constraints
* Input handling: "interactors", encapsulations of input device behaviors (Choice interactor for menus, checkboxes, etc; Trace interactor for capturing a mouse path; etc.)},
  Timestamp                = {2014-08-28}
}

@Book{Myers1992,
  Title                    = {Languages for developing user interfaces},
  Author                   = {Myers, Brad A and others},
  ISBN                     = {9780867204506},
  Publisher                = {AK Peters, Ltd.},
  Year                     = {1992},

  Abstract                 = {Computing is evolving from batch-based applications to interactive, graphical applications. However, most user interface software is still written using languages designed for writing text-based or even batch applications, such as Fortran, Pascal, C, or Ada. Researchers are investigating new approaches that may allow the next generation of computer programming languages to better support the creation of user interface software.

In addition, user interface designers are increasingly realizing that it is important to provide a high degree of end-user customization. In many cases, it would be ideal to allow end users to create their own applications. In a sense, this is what spreadsheets allow, since they can be "programmed" by their users. The success of spreadsheets shows that end users can learn to program, and that environments that support end-user programming can be successful.

At the SIGCHI conference in New Orleans in May, 1991, twenty leaders of the field got together in a workshop to discuss the future of languages for programming user interface software, and for end-user programming. These twenty were chosen from over 60 people who applied. The goal of the workshop was to discuss what types of computer languages would be appropriate in the future, and begin collaborations on creating these languages. This book contains the results of those discussions.

First, Chapter 1 presents an overview of the topic, and a summary of previous work. The first day of the workshop was spent with talks from the attendees. Chapters 2 through 18 contain the written papers that accompanied their talks. During the second day of the workshop, we broke into three groups to discuss various issues in depth. Chapters 19 through 21 report on the group results. Naturally, we discovered more issues than we resolved, and Chapter 22 contains a summary of the issues that were raised. We hope this will be seen as a challenge to future language designers.

In the user interface community, this book should be of interest to creators of toolkits, UIMSs and other user interface tools, as well as people creating end-user applications that want to provide end-user customization. In the programming language community, language designers would find this book useful, since future programmers will need to write modern user interfaces with their languages.},
  Keywords                 = {interface},
  Owner                    = {hisham},
  Review                   = {See reviews in each chapter.},
  Timestamp                = {2014-08-27},
  Url                      = {http://www.cs.cmu.edu/afs/cs/user/bam/www/langbook.html}
}

@InCollection{MyersReport1992LDUI,
  Title                    = {Report of the "{End-User Programming}" Working Group},
  Author                   = {Brad A Myers and David Canfield Smith and Bruce Horn},
  Booktitle                = {Languages for developing user interfaces},
  Publisher                = {AK Peters, Ltd.},
  Year                     = {1992},
  Chapter                  = {19},
  Editor                   = {Brad A. Myers},
  Pages                    = {343--366},

  Owner                    = {hisham},
  Review                   = {Two kinds of end-user programming: 1) programming by connecting pre-defined modules; 2) construct programs from low-level primitives (HyperCard and spreadsheets).

A few good interfaces:
Legos: small learning cost; only a few fixed interfaces; versatile; instant gratification; incremental planning; kinesthetic experience; transparent; examples supplied; ease and speed of assembly; no serious errors; safe; fun.
Spreadsheets: visibility; interactive; locality; modeless; no side effects; no explicit control structures; no explicit sequencing; levels of complexity; few data types; user's conceptual model; smart assistance (copying cells adjust formulas); multiple views
Xerox/Mac UI: desktop metaphor; generic commands (cut/copy/paste); noun-verb interaction; few commands, many objects; data interchange; direct manipulation.
MacPaint: WYSIWYG; concrete tools
HyperCard: directness; powerful idea (a button can be linked to a card); reduced nesting ("it" variable)
Video games: reward; performance metric; mystery and thrill of discovery; physical action; use of appropriate devices

Ideal properties:
A single programming language; Direct manipulation; ease of use.
Module architecture: full coverage; ease of searching; communication.
Language: few side effects; smooth transition between languages; abstraction; unobtrusive typing; simple control structures.

Open issues:
Applications vs components
Intelligence (how automatic?)
Transitioning levels
Component interconnection
Data formats
Typing
Data interchange vs intelligent objects 
Programming paradigm},
  Timestamp                = {2014-08-28}
}

@Book{Nardi1993,
  Title                    = {A Small Matter of Programming: Perspectives on End User Computing},
  Author                   = {Bonnie A. Nardi},
  ISBN                     = {0262140535},
  Publisher                = {MIT press},
  Year                     = {1993},

  Abstract                 = {A Small Matter of Programming asks why it has been so difficult for end users to command programming power and explores the problems of end user-driven application development that must be solved to afford end users greater computational power.Drawing on empirical research on existing end user systems, A Small Matter of Programming analyzes cognitive, social, and technical issues of end user programming. In particular, it examines the importance of task-specific programming languages, visual application frameworks, and collaborative work practices for end user computing, with the goal of helping designers and programmers understand and better satisfy the needs of end users who want the capability to create, customize, and extend their applications software.The ideas in the book are based on the author's research on two successful end user programming systems - spreadsheets and CAD systems - as well as other empirical research. Nardi concentrates on broad issues in end user programming, especially end users' strengths and problems, introducing tools and techniques as they are related to higher-level user issues. Bonnie A. Nardi was formerly a Member of the Technical Staff at Hewlett Packard Laboratories. She recently joined the Advanced Technologies Group at Apple Computer as a Senior Scientist.},
  Owner                    = {hisham},
  Review                   = {The author defends a number of interesting positions.
She defines end users as people who use computers for some goal that's not computing itself (ie, they use computers not because they like computers, but to get something done).
She criticizes the 80s/90s view that "mundane conversation" should be the end goal of human-computer interaction: her counterargument is that even between humans, different contexts result in different, often more controlled, modes of use of the language.
She defends task-specific programming languages, and defends that people are used to employing formal systems, when it makes sense for them (even outside computing: baseball scorecards, knitting patterns, etc.)
She discusses visual programming and argues that text is sometimes the best medium; most computing tasks would be better served by a combination of textual and visual interfaces (e.g. spreadsheets)
Studies of collaborative work practices showed that there are three types of users. She uses various terms, but I'll summarize here by calling them "end users", "enthusiasts" and "professionals". End users just want to get their work done, and dive into programming only up to a certain point, and they learn through enthusiasts; enthusiasts begin as end users but they enjoy computing per se, and dive deeper into programming helping end users with more advanced tasks (in the study of CAD environments, some companies even formalized the position of enthusiasts as tool makers); professionals are those who do more advanced programming that requires formal eduacation. End user programmable environments should cope with all three levels. The author argues that sometimes a clear distinction of those levels is useful (e.g. formula and macro languages in spreadsheets)},
  Timestamp                = {2014-09-25}
}

@InCollection{Nardi:1991:TLN:122825.122820,
  Title                    = {Computer-supported Cooperative Work and Groupware},
  Author                   = {Nardi, B. A. and Miller, J. R.},
  Publisher                = {Academic Press Ltd.},
  Year                     = {1991},

  Address                  = {London, UK, UK},
  Chapter                  = {Twinkling Lights and Nested Loops: Distributed Problem Solving and Spreadsheet Development},
  Editor                   = {Greenberg, Saul},
  Pages                    = {29--54},

  Acmid                    = {122820},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Computer_supported_Cooperative_Work_and_Groupware.pdf:PDF},
  ISBN                     = {0-12-299220-2},
  Numpages                 = {26},
  Owner                    = {hisham},
  Timestamp                = {2016-01-08},
  Url                      = {http://www.miramontes.com/writing/twinklinglights/}
}

@Manual{LabVIEWgettingstarted,
  Title                    = {Getting Started With {LabVIEW}},

  Address                  = {Austin, Texas},
  Author                   = {{National Instruments}},
  Edition                  = {321527E-01},
  Month                    = {nov},
  Organization             = {National Instruments},
  Year                     = {2001},

  Keywords                 = {LabVIEW},
  Owner                    = {hisham},
  Timestamp                = {2016-04-22},
  Url                      = {http://www.ni.com/pdf/manuals/321527e.pdf}
}

@Manual{Reaktor6Primary,
  Title                    = {{REAKTOR 6} - Building in Primary},

  Address                  = {Berlin, Germany},
  Author                   = {{Native Instruments}},
  Edition                  = {6.0.1},
  Month                    = {nov},
  Year                     = {2015},

  Owner                    = {hisham},
  Timestamp                = {2016-12-05}
}

@Article{Nichols:2009:CLU:1614390.1614392,
  Title                    = {Creating a Lightweight User Interface Description Language: An Overview and Analysis of the Personal Universal Controller Project},
  Author                   = {Nichols, Jeffrey and Myers, Brad A.},
  Journal                  = {ACM Trans. Comput.-Hum. Interact.},
  Year                     = {2009},

  Month                    = {nov},
  Number                   = {4},
  Pages                    = {17:1--17:37},
  Volume                   = {16},

  __markedentry            = {[hisham:1]},
  Abstract                 = {Over six years, we iterated on the design of a language for describing the functionality of appliances, such as televisions, telephones, VCRs, and copiers. This language has been used to describe more than thirty diverse appliances, and these descriptions have been used to automatically generate both graphical and speech user interfaces on handheld computers, mobile phones, and desktop computers. In this article, we describe the final design of our language and analyze the key design choices that led to this design. Through this analysis, we hope to provide a useful guide for the designers of future user interface description languages.},
  Acmid                    = {1614392},
  Address                  = {New York, NY, USA},
  Articleno                = {17},
  Doi                      = {10.1145/1614390.1614392},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Creating_a_Lightweight_User_Interface_Description_Language__An_Overview_and_Analysis_of_the_Personal_Universal_Controller_Project.pdf:PDF},
  ISSN                     = {1073-0516},
  Issue_date               = {November 2009},
  Keywords                 = {Pebbles, User interface description language (UIDL), appliances, automatic interface generation, consistency, handheld computers, mobile phone, model-based authoring, model-based user interfaces, personal digital assistants (PDAs), personal universal controller (PUC), remote control},
  Numpages                 = {37},
  Owner                    = {hisham},
  Publisher                = {ACM},
  Timestamp                = {2015-05-18},
  Url                      = {http://doi.acm.org/10.1145/1614390.1614392}
}

@Electronic{OASIS2011ODFFormula,
  Title                    = {{Open Document Format for Office Applications (OpenDocument) Version 1.2 - Part 2: Recalculated Formula (OpenFormula) Format}},
  Author                   = {{OASIS}},
  HowPublished             = {\url{http://docs.oasis-open.org/office/v1.2/os/OpenDocument-v1.2-os-part2.html}},
  Month                    = {9},
  Organization             = {{OASIS}},
  Url                      = {http://docs.oasis-open.org/office/v1.2/os/OpenDocument-v1.2-os-part2.html},
  Year                     = {2011},

  Abstract                 = {This document is part of the Open Document Format for Office Applications (OpenDocument) Version 1.2 specification.

It defines a formula language to be used in OpenDocument documents.},
  File                     = {:Users/hisham/ac/dr/reading/pdf/_Open_Document_Format_for_Office_Applications__OpenDocument__Version_1_2___Part_2__Recalculated_Formula__OpenFormula__Format_.pdf:PDF},
  Owner                    = {hisham},
  Review                   = {Includes a semi-formal description of the evaluation of array formulas in page 27.},
  Timestamp                = {2016-01-18}
}

@Electronic{OASIS2006OpenFormulaDraft,
  Title                    = {{OpenFormula Format for Office Applications (OpenFormula) - Rough Draft}},
  Author                   = {{OASIS}},
  HowPublished             = {\url{https://www.oasis-open.org/committees/download.php/16826/openformula-spec-20060221.html}},
  Month                    = {02},
  Url                      = {https://www.oasis-open.org/committees/download.php/16826/openformula-spec-20060221.html},
  Year                     = {2006},

  File                     = {:Users/hisham/ac/dr/reading/pdf/_OpenFormula_Format_for_Office_Applications__OpenFormula____Rough_Draft_.pdf:PDF},
  Owner                    = {hisham},
  Review                   = {draft for specification of .ods used in OpenDocument (OpenOffice, LibreOffice).
notably lacks specification of array formulas},
  Timestamp                = {2016-01-18}
}

@Article{Ousterhout:1998:SHP:619027.620930,
  Title                    = {Scripting: Higher-Level Programming for the 21st Century},
  Author                   = {Ousterhout, John K.},
  Journal                  = {Computer},
  Year                     = {1998},

  Month                    = {mar},
  Number                   = {3},
  Pages                    = {23--30},
  Volume                   = {31},

  Acmid                    = {620930},
  Address                  = {Los Alamitos, CA, USA},
  Doi                      = {10.1109/2.660187},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Scripting__Higher_Level_Programming_for_the_21st_Century.pdf:PDF},
  ISSN                     = {0018-9162},
  Issue_date               = {March 1998},
  Numpages                 = {8},
  Owner                    = {hisham},
  Publisher                = {IEEE Computer Society Press},
  Timestamp                = {2015-03-29},
  Url                      = {http://dx.doi.org/10.1109/2.660187}
}

@InProceedings{Parks95SDFvsCSDF,
  Title                    = {A comparison of synchronous and cycle-static dataflow},
  Author                   = {T. M. Parks and J. L. Pino and E. A. Lee},
  Booktitle                = {Conference Record of The Twenty-Ninth Asilomar Conference on Signals, Systems and Computers},
  Year                     = {1995},
  Month                    = {Oct},
  Pages                    = {204-210 vol.1},
  Volume                   = {1},

  __markedentry            = {[hisham:1]},
  Abstract                 = {We compare synchronous dataflow (SDF) and cyclo-static dataflow (CSDF), which are each special cases of a model of computation we call dataflow process networks. In SDF actors have static firing rules: they consume and produce a fixed number of data tokens in each firing. This model is well suited to multirate signal processing applications and lends itself to efficient static scheduling, avoiding the run-time scheduling overhead incurred by general implementations of process networks. In CSDF which is a generalization of SDF actors have cyclically changing firing rules. In some situations, the added generality of CSDF can unnecessarily complicate the scheduling. We show how higher-order functions can be used to transform a CSDF graph into a SDF graph, simplifying the scheduling problem. In other situations, CSDF has a genuine advantage over SDF: simpler precedence constraints. We show how this makes it possible to eliminate unnecessary computations and expose additional parallelism. We use digital sample rate conversion as an example to illustrate these advantages of CSDF.},
  Doi                      = {10.1109/ACSSC.1995.540541},
  ISSN                     = {1058-6393},
  Keywords                 = {data flow computing;data flow graphs;scheduling;signal sampling;CSDF graph;SDF graph;computation model;cycle-static dataflow;data tokens;dataflow process networks;digital sample rate conversion;higher-order functions;multirate signal processing applications;parallelism;precedence constraints;scheduling problem;static firing rules;static scheduling;synchronous dataflow;Communication channels;Computational modeling;Computer networks;Concurrent computing;Fires;Parallel processing;Processor scheduling;Signal processing;Streaming media;Video signal processing},
  Owner                    = {hisham},
  Timestamp                = {2017-03-12}
}

@Article{patterno2013eud,
  Title                    = {End User Development: Survey of an Emerging Field for Empowering People},
  Author                   = {Fabio Paternò},
  Journal                  = {{ISRN Software Engineering}},
  Year                     = {2013},
  Number                   = {532659},
  Pages                    = {11},
  Volume                   = {2013},

  Abstract                 = {The purpose of this paper is to introduce the motivations behind end user development, discuss its basic concepts and roots, and review the current state of art. Various approaches are discussed and classified in terms of their main features and the technologies and platforms for which they have been developed. Lastly, the paper provides an indication of interesting possibilities for further evolution.},
  Doi                      = {10.1155/2013.532659},
  Owner                    = {hisham},
  Timestamp                = {2016-02-04},
  Url                      = {http://downloads.hindawi.com/journals/isrn/2013/532659.pdf}
}

@Article{Patnaik198497,
  Title                    = {DFL: A Data Flow Language },
  Author                   = {L.M. Patnaik and Prabal Bhattacharya and R. Ganesh},
  Journal                  = {Computer Languages },
  Year                     = {1984},
  Number                   = {2},
  Pages                    = {97 - 106},
  Volume                   = {9},

  __markedentry            = {[hisham:1]},
  Abstract                 = {Many novel computer architectures like array and multiprocessors which achieve high performance through the use of concurrency exploit variations of the von Neumann model of computation. The effective utilization of the machines makes special demands on programmers and their programming languages, such as the structuring of data into vectors or the partitioning of programs into concurrent processes. In comparison, the data flow model of computation demands only that the principle of structured programming be followed. A data flow program, often represented as a data flow graph, is a program that expresses a computation by indicating the data dependencies among operators. A data flow computer is a machine designed to take advantage of concurrency in data flow graphs by executing data independent operations in parallel. In this paper, we discuss the design of a high level language (DFL: Data Flow Language) suitable for data flow computers. Some sample procedures in \{DFL\} are presented. The implementation aspects have not been discussed in detail since there are no new problems encountered. The language \{DFL\} embodies the concepts of functional programming, but in appearance closely resembles Pascal. The language is a better vehicle than the data flow graph for expressing a parallel algorithm. The compiler has been implemented on a \{DEC\} 1090 system in Pascal.},
  Doi                      = {http://dx.doi.org/10.1016/0096-0551(84)90017-1},
  File                     = {:Users/hisham/ac/dr/reading/pdf/DFL__A_Data_Flow_Language_.pdf:PDF},
  ISSN                     = {0096-0551},
  Keywords                 = {Data flow computer},
  Owner                    = {hisham},
  Timestamp                = {2016-01-19},
  Url                      = {http://www.sciencedirect.com/science/article/pii/0096055184900171}
}

@Book{pettersson2005compiling,
  Title                    = {Compiling Natural Semantics},
  Author                   = {Pettersson, M.},
  ISBN                     = {9783540488231},
  Publisher                = {Springer Berlin Heidelberg},
  Year                     = {2005},
  Series                   = {Lecture Notes in Computer Science},

  __markedentry            = {[hisham:1]},
  Abstract                 = {Natural Semantics has become a popular tool among programming language researchers for specifying many aspects of programming languages. However, due to the lack of practical tools for implementation, the natural semantics formalism has so far largely been limited to theoretical applications.
This book introduces the rational meta-language RML as a practical language for natural semantics specifications. The main part of the work is devoted to the problem of compiling natural semantics, actually RML, into highly efficient code. For this purpose, an effective compilation strategy for RML is developed and implemented in the rml2c compiler. This compiler ultimately produces low-level C code. Benchmarking results show that rml2c-produced code is much faster than code resulting from compilers based on alternative implementation approaches.},
  Owner                    = {hisham},
  Timestamp                = {2016-03-08},
  Url                      = {https://books.google.com.br/books?id=6gNtCQAAQBAJ}
}

@Electronic{DeadBatteries,
  Title                    = {Dead Batteries Included},
  Author                   = {Dusty Phillips},
  HowPublished             = {Radar},
  Month                    = {October},
  Organization             = {O'Reilly},
  Url                      = {http://radar.oreilly.com/2013/10/dead-batteries-included.html},
  Year                     = {2013},

  Abstract                 = {Recharging the Python standard library},
  Owner                    = {hisham},
  Review                   = {Article with the quote "the standard library is where modules go to die".},
  Timestamp                = {2016-12-07}
}

@InCollection{Piumarta:2008:OEO:1482373.1482375,
  Title                    = {Open, Extensible Object Models},
  Author                   = {Piumarta, Ian and Warth, Alessandro},
  Booktitle                = {Self-Sustaining Systems},
  Publisher                = {Springer-Verlag},
  Year                     = {2008},

  Address                  = {Berlin, Heidelberg},
  Editor                   = {Hirschfeld, Robert and Rose, Kim},
  Pages                    = {1--30},

  Abstract                 = {Programming languages often hide their implementation at a level of abstraction that is inaccessible to programmers. Decisions and tradeoffs made by the language designer at this level (single vs. multiple inheritance, mixins vs. Traits, dynamic dispatch vs. static case analysis, etc.) cannot be repaired easily by the programmer when they prove inconvenient or inadequate. The artificial distinction between implementation language and end-user language can be eliminated by implementing the language using only end-user objects and messages, making the implementation accessible for arbitrary modification by programmers. We show that three object types and five methods are sufficient to bootstrap an extensible object model and messaging semantics that are described entirely in terms of those same objects and messages. Raising the implementation to the programmers' level lets them design and control their own implementation mechanisms in which to express concise solutions and frees the original language designer from ever having to say "I'm sorry".},
  Acmid                    = {1482375},
  Doi                      = {10.1007/978-3-540-89275-5_1},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Open__Extensible_Object_Models.pdf:PDF},
  ISBN                     = {978-3-540-89274-8},
  Numpages                 = {30},
  Owner                    = {hisham},
  Review                   = {A simple object model that allows the end-user to modify its behavior.
Method lookups go through the object's vtable "lookup" method.
The vtable itself can be replaced and the end-user can implement their own lookup logic.
The authors demonstrate the implementation of JS-like objects and traits as extensions.
With inline cache and method cache, it beats the performance of switch-based tag checking.
Appendix includes a full implementation in 3 pages of C code.},
  Timestamp                = {2014-12-15},
  Url                      = {http://dx.doi.org/10.1007/978-3-540-89275-5_1}
}

@Electronic{PuckettePd,
  Title                    = {Pd Documentation},
  Author                   = {Puckette, Miller and others},
  HowPublished             = {\url{http://msp.ucsd.edu/Pd_documentation/index.html}},
  Url                      = {http://msp.ucsd.edu/Pd_documentation/index.html},
  Year                     = {2015},

  File                     = {:Users/hisham/ac/dr/reading/pdf/Pd_Documentation.pdf:PDF},
  Owner                    = {hisham},
  Review                   = {Documentation for Pure Data},
  Timestamp                = {2015-10-06}
}

@InProceedings{Rajanen:2015:PEO:2702123.2702441,
  Title                    = {Power, Empowerment and Open Source Usability},
  Author                   = {Rajanen, Mikko and Iivari, Netta},
  Booktitle                = {Proceedings of the 33rd Annual ACM Conference on Human Factors in Computing Systems},
  Year                     = {2015},

  Address                  = {New York, NY, USA},
  Pages                    = {3413--3422},
  Publisher                = {ACM},
  Series                   = {CHI '15},

  Acmid                    = {2702441},
  Doi                      = {10.1145/2702123.2702441},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Power__Empowerment_and_Open_Source_Usability.pdf:PDF},
  ISBN                     = {978-1-4503-3145-6},
  Keywords                 = {empowerment, open source software, power, usability},
  Location                 = {Seoul, Republic of Korea},
  Numpages                 = {10},
  Owner                    = {hisham},
  Timestamp                = {2015-05-18},
  Url                      = {http://doi.acm.org/10.1145/2702123.2702441}
}

@PhdThesis{Reekie1995,
  Title                    = {Realtime Signal Processing: Dataflow, Visual, and Functional Programming},
  Author                   = {Hideki John Reekie},
  School                   = {University of Technology at Sydney},
  Year                     = {1995},
  Month                    = {9},

  __markedentry            = {[hisham:1]},
  Abstract                 = {This thesis presents and justifies a framework for programming real-time signal processing systems. The framework extends the existing ``block-diagram'' programming model; it has three components: a very high-level textual language, a visual language, and the dataflow process network model of computation.

The dataflow process network model, although widely-used, lacks a formal description, and I provide a semantics for it. The formal work leads into a new form of actor. Having established the semantics of dataflow processes, the functional language Haskell is layered above this model, providing powerful features---notably polymorphism, higher-order functions, and algebraic program transformation---absent in block-diagram systems. A visual equivalent notation for Haskell, Visual Haskell, ensures that this power does not exclude the ``intuitive'' appeal of visual interfaces; with some intelligent layout and suggestive icons, a Visual Haskell program can be made to look very like a block diagram program. Finally, the functional language is used to further extend dataflow process networks, by simulating timed and dynamically-varying networks.

The thesis thus draws together a number of previously-separate ideas: a reasonable expectation of efficient execution using established dataflow compilation technology; a powerful and high-level programming notation; and a block-diagram style interface.},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Realtime_Signal_Processing__Dataflow__Visual__and_Functional_Programming.pdf:PDF},
  Owner                    = {hisham},
  Timestamp                = {2016-01-19},
  Url                      = {http://ptolemy.eecs.berkeley.edu/~johnr/papers/thesis.html}
}

@InProceedings{rompf_et_al:LIPIcs:2015:5029,
  Title                    = {{Go Meta! A Case for Generative Programming and DSLs in Performance Critical Systems}},
  Author                   = {Tiark Rompf and Kevin J. Brown and HyoukJoong Lee and Arvind K. Sujeeth and Manohar Jonnalagedda and Nada Amin and Georg Ofenbeck and Alen Stojanov and Yannis Klonatos and Mohammad Dashti and Christoph Koch and Markus P{\"u}schel and Kunle Olukotun},
  Booktitle                = {1st Summit on Advances in Programming Languages (SNAPL 2015)},
  Year                     = {2015},

  Address                  = {Dagstuhl, Germany},
  Editor                   = {Thomas Ball and Rastislav Bodik and Shriram Krishnamurthi and Benjamin S. Lerner and Greg Morrisett},
  Pages                    = {238--261},
  Publisher                = {Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
  Series                   = {Leibniz International Proceedings in Informatics (LIPIcs)},
  Volume                   = {32},

  Doi                      = {http://dx.doi.org/10.4230/LIPIcs.SNAPL.2015.238},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Go_Meta__A_Case_for_Generative_Programming_and_DSLs_in_Performance_Critical_Systems.pdf:PDF},
  ISBN                     = {978-3-939897-80-4},
  ISSN                     = {1868-8969},
  Keywords                 = {Performance, Generative Programming, Staging, DSLs},
  Owner                    = {hisham},
  Timestamp                = {2016-01-23},
  Url                      = {http://drops.dagstuhl.de/opus/volltexte/2015/5029},
  Urn                      = {urn:nbn:de:0030-drops-50295}
}

@Article{Sakal2012StrategicManagement,
  Title                    = {Errors in building and using electronic tables: Financial consequences and minimisation techniques},
  Author                   = {Marton Sakal and Lazar Rakovic},
  Journal                  = {International Journal on Strategic Management and Decision Support Systems in Strategic Management},
  Year                     = {2012},
  Number                   = {3},
  Pages                    = {29--35},
  Volume                   = {17},

  Abstract                 = {Spreadsheet programs are one of the widest-used types of modern-day programs, with a dominant, but not exclusive use in the business sphere. The experience of the past three decades has shown that errors in their utilization are constantly present, despite constant progress in the possibilities of electronic tables.

This article presents some of the errors in creating and using electronic tables that have caused serious financial consequences, and several development models aimed at minimizing such errors.},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Errors_in_building_and_using_electronic_tables__Financial_consequences_and_minimisation_techniques.pdf:PDF},
  Owner                    = {hisham},
  Review                   = {contains estimate of 500 million Excel users},
  Timestamp                = {2016-01-18},
  Url                      = {http://www.i-nth.com/resources/bibliography/192-errors-in-building-and-using-electronic-tables}
}

@Article{Sannella:1993:MVO:153493.153498,
  Title                    = {Multi-way Versus One-way Constraints in User Interfaces: Experience with the DeltaBlue Algorithm},
  Author                   = {Sannella, Michael and Maloney, John and Freeman-Benson, Bjorn and Borning, Alan},
  Journal                  = {Softw. Pract. Exper.},
  Year                     = {1993},

  Month                    = {may},
  Number                   = {5},
  Pages                    = {529--566},
  Volume                   = {23},

  __markedentry            = {[hisham:1]},
  Acmid                    = {153498},
  Address                  = {New York, NY, USA},
  Doi                      = {10.1002/spe.4380230507},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Multi_way_Versus_One_way_Constraints_in_User_Interfaces__Experience_with_the_DeltaBlue_Algorithm.pdf:PDF},
  ISSN                     = {0038-0644},
  Issue_date               = {May 1993},
  Keywords                 = {DeltaBlue, constraint satisfaction, constraints, local propagation, user interface implementation techniques},
  Numpages                 = {38},
  Owner                    = {hisham},
  Publisher                = {John Wiley \& Sons, Inc.},
  Timestamp                = {2016-01-21},
  Url                      = {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.14.2131&rep=rep1&type=pdf}
}

@InProceedings{Scaffidi:2005:ENE:1092357.1092394,
  Title                    = {Estimating the Numbers of End Users and End User Programmers},
  Author                   = {Scaffidi, Christopher and Shaw, Mary and Myers, Brad},
  Booktitle                = {Proceedings of the 2005 IEEE Symposium on Visual Languages and Human-Centric Computing},
  Year                     = {2005},

  Address                  = {Washington, DC, USA},
  Pages                    = {207--214},
  Publisher                = {IEEE Computer Society},
  Series                   = {VLHCC '05},

  Acmid                    = {1092394},
  Doi                      = {10.1109/VLHCC.2005.34},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Estimating_the_Numbers_of_End_Users_and_End_User_Programmers.pdf:PDF},
  ISBN                     = {0-7695-2443-5},
  Numpages                 = {8},
  Owner                    = {hisham},
  Timestamp                = {2016-01-18},
  Url                      = {http://dx.doi.org/10.1109/VLHCC.2005.34}
}

@InProceedings{Schachman:2012:API:2384592.2384594,
  Title                    = {Alternative Programming Interfaces for Alternative Programmers},
  Author                   = {Schachman, Toby},
  Booktitle                = {Proceedings of the ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software},
  Year                     = {2012},

  Address                  = {New York, NY, USA},
  Pages                    = {1--10},
  Publisher                = {ACM},
  Series                   = {Onward! 2012},

  __markedentry            = {[hisham:1]},
  Acmid                    = {2384594},
  Doi                      = {10.1145/2384592.2384594},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Alternative_Programming_Interfaces_for_Alternative_Programmers.pdf:PDF},
  ISBN                     = {978-1-4503-1562-3},
  Keywords                 = {art, constraint solver, direct manipulation, improvisation, program transformation, recursion},
  Location                 = {Tucson, Arizona, USA},
  Numpages                 = {10},
  Owner                    = {hisham},
  Timestamp                = {2015-05-18},
  Url                      = {http://doi.acm.org/10.1145/2384592.2384594}
}

@InProceedings{Schwarzer:2015:TCD:2764967.2764972,
  Title                    = {Throughput-optimizing Compilation of Dataflow Applications for Multi-Cores Using Quasi-Static Scheduling},
  Author                   = {Schwarzer, Tobias and Falk, Joachim and Gla\ss, Michael and Teich, J\"{u}rgen and Zebelein, Christian and Haubelt, Christian},
  Booktitle                = {Proceedings of the 18th International Workshop on Software and Compilers for Embedded Systems},
  Year                     = {2015},

  Address                  = {New York, NY, USA},
  Pages                    = {68--75},
  Publisher                = {ACM},
  Series                   = {SCOPES '15},

  __markedentry            = {[hisham:1]},
  Abstract                 = {Application modeling using dynamic dataflow graphs is well-suited for multi-core platforms. However, there is often a mismatch between the fine granularity of the application and the platform. Tailoring this granularity to the platform promises performance gains by (a) reducing dynamic scheduling overhead and (b) exploiting compiler optimizations. In this paper, we propose a throughput-optimizing compilation approach that uses Quasi-Static Schedules (QSSs) to combine actors of static dataflow subgraphs. Our proposed approach combines core allocation, QSSs, and actor binding in a Design Space Exploration (DSE), optimizing the throughput for a number of available cores. During the DSE, each implementation candidate is compiled to and evaluated on the target hardware---here an Intel i7 and an ARM Cortex-A9. Experimental results including synthetic benchmarks as well as a real-world control application show that our proposed holistic compilation approach outperforms classic DSEs that are agnostic of QSS as well as a DSE that employs QSS as a post-processing step. Amongst others, we show a case where the compilation approach obtains a speedup of 9.91 x for a 4-core implementation, while a classic DSE only obtains a speedup of 2.12 x.},
  Acmid                    = {2764972},
  Doi                      = {10.1145/2764967.2764972},
  ISBN                     = {978-1-4503-3593-5},
  Keywords                 = {Clustering, Compilation, Dataflow, Design Space Exploration, Multi-Core},
  Location                 = {Sankt Goar, Germany},
  Numpages                 = {8},
  Owner                    = {hisham},
  Review                   = {recent paper on quasi-static dataflow},
  Timestamp                = {2017-03-12},
  Url                      = {http://doi.acm.org/10.1145/2764967.2764972}
}

@TechReport{Sestoft06SpreadsheetCore,
  Title                    = {A Spreadsheet Core Implementation in C\#},
  Author                   = {Peter Sestoft},
  Institution              = {IT University of Copenhagen},
  Year                     = {2006},
  Month                    = {sep},
  Number                   = {TR-2006-91},
  Type                     = {IT University Technical Report Series},

  __markedentry            = {[hisham:1]},
  Abstract                 = {Spreadsheet programs are used daily by millions of people for tasks ranging from neatly organizing a list of addresses to complex economical simulations or analysis of biological data sets. Spreadsheet programs are easy to learn and convenient to use because they have a clear visual data model (tabular) and a simple efficient computation model (functional and side effect free). Spreadsheet programs are usually not held in high regard by professional software developers [15]. However, their implementation involves a large number of non-trivial design considerations and time-space tradeoffs. Moreover, the basic spreadsheet model can be extended, improved or otherwise ex
perimented with in many ways, both to test new technology and to provide new functionality in a context that could make a difference to a large number of users. Yet there does not seem to be a coherently designed, reasonably efficient open source spreadsheet implementation that is a suitable platform for experiments. Existing open source spreadsheet implementations such as Gnumeric and OpenOffice are rather complex, written in unmanaged languages such as C and C++, and the documentation of their internals is sparse. Commercial spreadsheet implementations such as Microsoft Excel neither expose their internal s through their source code nor through adequate documentation of data representations and functions.},
  File                     = {:Users/hisham/ac/dr/reading/pdf/A_Spreadsheet_Core_Implementation_in_C_Version_10_.pdf:PDF},
  ISSN                     = {1600–6100},
  Owner                    = {hisham},
  Timestamp                = {2017-01-16},
  Url                      = {http://www.itu.dk/people/sestoft/funcalc/ITU-TR-2006-91.pdf}
}

@Article{Shaer2009,
  Title                    = {A Specification Paradigm for the Design and Implementation of Tangible User Interfaces},
  Author                   = {Shaer, Orit and Jacob, Robert J.K.},
  Journal                  = {ACM Trans. Comput.-Hum. Interact.},
  Year                     = {2009},

  Month                    = {nov},
  Number                   = {4},
  Pages                    = {20:1--20:39},
  Volume                   = {16},

  __markedentry            = {[hisham:1]},
  Abstract                 = {Tangible interaction shows promise to significantly enhance computer-mediated support for activities such as learning, problem solving, and design. However, tangible user interfaces are currently considered challenging to design and build. Designers and developers of these interfaces encounter several conceptual, methodological, and technical difficulties. Among others, these challenges include: the lack of appropriate interaction abstractions, the shortcomings of current user interface software tools to address continuous and parallel interactions, as well as the excessive effort required to integrate novel input and output technologies. To address these challenges, we propose a specification paradigm for designing and implementing Tangible User Interfaces (TUIs), that enables TUI developers to specify the structure and behavior of a tangible user interface using high-level constructs which abstract away implementation details. An important benefit of this approach, which is based on User Interface Description Language (UIDL) research, is that these specifications could be automatically or semi-automatically converted into concrete TUI implementations. In addition, such specifications could serve as a common ground for investigating both design and implementation concerns by TUI developers from different disciplines.

Thus, the primary contribution of this article is a high-level UIDL that provides developers from different disciplines means for effectively specifying, discussing, and programming a broad range of tangible user interfaces. There are three distinct elements to this contribution: a visual specification technique that is based on Statecharts and Petri nets, an XML-compliant language that extends this visual specification technique, as well as a proof-of-concept prototype of a Tangible User Interface Management System (TUIMS) that semi-automatically translates high-level specifications into a program controlling specific target technologies.},
  Acmid                    = {1614395},
  Address                  = {New York, NY, USA},
  Articleno                = {20},
  Doi                      = {10.1145/1614390.1614395},
  File                     = {:Users/hisham/ac/dr/reading/pdf/A_Specification_Paradigm_for_the_Design_and_Implementation_of_Tangible_User_Interfaces.pdf:PDF},
  ISSN                     = {1073-0516},
  Issue_date               = {November 2009},
  Keywords                 = {Tangible interaction, tangible user interfaces, user interface description language, user interface management system},
  Numpages                 = {39},
  Owner                    = {hisham},
  Publisher                = {ACM},
  Timestamp                = {2015-05-18},
  Url                      = {http://doi.acm.org/10.1145/1614390.1614395}
}

@InCollection{Singh1992LDUI,
  Title                    = {Requirements for User Interface Programming Languages},
  Author                   = {Gurminder Singh},
  Booktitle                = {Languages for developing user interfaces},
  Publisher                = {AK Peters, Ltd.},
  Year                     = {1992},
  Chapter                  = {8},
  Editor                   = {Brad A. Myers},
  Pages                    = {115--124},

  Owner                    = {hisham},
  Review                   = {Argues for OO, concurrent languages for both UI and application semantics; treating time as a first-class entity; interpreted with dynamic linking
Requirements: OO; graphical primitives and widgets; I/O device programming; some real-time capability; concurrency.},
  Timestamp                = {2014-08-28}
}

@InCollection{Smith1992,
  Title                    = {A Component Architecture for Personal Computer Software},
  Author                   = {David Canfield Smith and Joshua Susser},
  Booktitle                = {Languages for developing user interfaces},
  Publisher                = {AK Peters, Ltd.},
  Year                     = {1992},
  Chapter                  = {3},
  Editor                   = {Brad A. Myers},
  Pages                    = {31--56},

  Owner                    = {hisham},
  Review                   = {Increasing software complexity
Breaking the complexity barrier: "the programming problem of the 90s will not be writing programs; it will be figuring out how to plug programs together."
A user scenario: allow users to modify the design of applications
Component Construction Kit: A component has 0+ inputs and 0+ outputs
20 components: programming tools
CCK palette; component server; simple inference engine connects components via semantic types ("keywords")
Applications: browser, debugger, inspector for Smalltalk; component inspector
Business model
What is wrong with today's applications?
1) Monolithic applications are not good for users: They don't do a lot. They do too much. They are expensive. They are inflexible. They limit the choices available.
2) Monolithic applications are not good for devs: They are hard to write. They are hard to debug. They are risky.
Component-based software: UNIX, Pinball Construction Set, Canvas, SuperPaint, Macintosh Control Panel devices, NeXT interface builder...},
  Timestamp                = {2014-08-28}
}

@InCollection{SmithUngar1992LDUI,
  Title                    = {The Use--Mention Perspective on Programming for the Interface},
  Author                   = {Randall B. Smith and David Ungar and Bay-Wei Chang},
  Booktitle                = {Languages for developing user interfaces},
  Publisher                = {AK Peters, Ltd.},
  Year                     = {1992},
  Chapter                  = {5},
  Editor                   = {Brad A. Myers},
  Pages                    = {79--90},

  Owner                    = {hisham},
  Review                   = {Use-mention distinction: language can refer to itself.
Examples of use with mention supported by direct manipulation interfaces:
* the modal approach: toggle between use and mention modes
* the affordance approach: tear-off handle in a menu, title bar. Problem: "meta-corner" in a "corner" widget?
* the tools approach},
  Timestamp                = {2014-08-28}
}

@Book{sottile2009introduction,
  Title                    = {Introduction to Concurrency in Programming Languages},
  Author                   = {Sottile, M.J. and Mattson, T.G. and Rasmussen, C.E.},
  ISBN                     = {9781420072143},
  Publisher                = {Taylor \& Francis},
  Year                     = {2009},
  Series                   = {Chapman \& Hall/CRC Computational Science},

  Owner                    = {hisham},
  Review                   = {Compares concurrent programming to cooking in page 10.},
  Timestamp                = {2015-01-14},
  Url                      = {https://books.google.com.br/books?id=J5-ckoCgc3IC}
}

@InProceedings{Sousa2012Dataflow,
  Title                    = {Dataflow Programming Concept, Languages and Applications},
  Author                   = {Tiago Boldt Sousa},
  Booktitle                = {{Doctoral Symposium on Informatics Engineering (DSIE'2012)}},
  Year                     = {2012},

  Address                  = {Porto},

  Abstract                 = {Dataflow Programming (DFP) has been a research topic of Software Engineering since the `70s. The paradigm models computer programs as a direct graph, promoting the application of data ow diagram principles to computation, opposing the more linear and classical Von Neumann model. DFP is the core to most visual programming languages, which claim to be able to provide end-user programming: with it's visual interface, it allows non-technical users to extend or create applications without programming knowledges. Also, DFP is capable of achieving parallelization of computation without introducing development complexity, resulting in an increased performance of applications built with it when using multi-core computers. This survey describes how visual programming languages built on top of DFP can be used for end-user programming and how easy it is to achieve concurrency by applying the paradigm, without any development overhead. DFP's open problems are discussed and some guidelines for adopting the paradigm are provided.},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Dataflow_Programming_Concept_Languages_and_Applications.pdf:PDF},
  Owner                    = {hisham},
  Timestamp                = {2016-11-29}
}

@Article{deSouza2001SemEngPrinciples,
  Title                    = {Semiotic engineering principles for evaluating end-user programming environments },
  Author                   = {C.S de Souza and S.D.J Barbosa and S.R.P da Silva},
  Journal                  = {Interacting with Computers },
  Year                     = {2001},
  Number                   = {4},
  Pages                    = {467 - 495},
  Volume                   = {13},

  Abstract                 = {End user programming (EUP) environments are difficult to evaluate empirically. Most users do not engage in programming, and those who do are often discouraged by the complexity of programming tasks. Often the difficulties arise from the programming languages in which users are expected to express themselves. But there are other difficulties associated with designing extensions and adjustments to artifacts that have been originally designed by others. This paper characterizes \{EUP\} as a semiotic design process, and presents two principles that can be used to illustrate the distinctions between the various kinds of techniques and approaches proposed in this field. The principles support a preliminary theoretical model of \{EUP\} and should thus facilitate the definition and interpretation of empirical evaluation studies. They also define some specific semiotic qualifications that more usable and applicable \{EUP\} languages could be expected to have. },
  Doi                      = {http://dx.doi.org/10.1016/S0953-5438(00)00051-5},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Semiotic_engineering_principles_for_evaluating_end_user_programming_environments_.pdf:PDF},
  ISSN                     = {0953-5438},
  Keywords                 = {Semiotic engineering},
  Owner                    = {hisham},
  Timestamp                = {2015-04-01},
  Url                      = {http://www.sciencedirect.com/science/article/pii/S0953543800000515}
}

@Book{deSouza:2005:SE,
  Title                    = {The Semiotic Engineering of Human-Computer Interaction (Acting with Technology)},
  Author                   = {de Souza, Clarisse Sieckenius},
  ISBN                     = {0262042207},
  Publisher                = {The MIT Press},
  Year                     = {2005},

  Owner                    = {hisham},
  Timestamp                = {2015-04-07}
}

@Article{Spinellis01unixtools,
  Title                    = {Unix Tools as Visual Programming Components in a GUI-builder Environment},
  Author                   = {Diomidis Spinellis},
  Journal                  = {Software---Practice and Experience},
  Year                     = {2001},
  Volume                   = {32},

  Abstract                 = {Development environments based on ActiveX controls and JavaBeans are marketed as "visual programming" platforms; in practice their visual dimension is limited to the design and implementation of an application's graphical user interface (GUI). The availability of sophisticated GUI development environments and visual component development frameworks is now providing viable platforms for implementing visual programming within general-purpose platforms, i.e. for the specification of non-GUI program functionality using visual representations. We describe how specially-designed reflective components can be used in an industry-standard visual programming environment to graphically specify sophisticated data transformation pipelines that interact with GUI elements. The components are based on Unix-style filters repackaged as ActiveX controls. Their visual layout on the development environment canvas is used to specify the connection topology of the resultant pipeline. The process of converting filter-style programs as visual controls is automated using a domain-specific language. We demonstrate the approach through the design and the visual implementation of a GUI-based spelling checker.},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Unix_tools_as_visual_programming_components_in_a_GUI_builder_environment.pdf:PDF},
  Owner                    = {hisham},
  Review                   = {Wrap Unix-style commands into ActiveX controls so that pipelines can be drawn in a GUI canvas.
Gives the classic Unix "spell checker pipeline" as an example.},
  Timestamp                = {2015-04-14}
}

@InCollection{Stav2013,
  Title                    = {Using Meta-modelling for Construction of an End-User Development Framework},
  Author                   = {Stav, Erlend and Floch, Jacqueline and Khan, MohammadUllah and Sætre, Rune},
  Booktitle                = {End-User Development},
  Publisher                = {Springer Berlin Heidelberg},
  Year                     = {2013},
  Editor                   = {Dittrich, Yvonne and Burnett, Margaret and Mørch, Anders and Redmiles, David},
  Pages                    = {72-87},
  Series                   = {Lecture Notes in Computer Science},
  Volume                   = {7897},

  __markedentry            = {[hisham:]},
  Abstract                 = {A main activity in meta-design is the creation of design spaces allowing problem owners to act as system developers. Meta-design is a conceptual framework; it does not provide concrete design space solutions or engineering guidelines for constructing tools that support design spaces. This paper discusses the applicability of a model-driven engineering approach for the realization of an end-user service composition framework, in line with the conceptual meta-design framework. We report our experience of using meta-modelling techniques as supported by the Eclipse Modelling Framework (EMF) family of tools. In our work we found that meta-models are well-suited to formalize the composition language, and the core parts of the EMF framework are useful to represent the language elements and user-made compositions both at design and runtime. Although EMF-based tools exist for creating visual editors, we found that in our case these did not map well to the visual notation we selected for our end-users.},
  Doi                      = {10.1007/978-3-642-38706-7_7},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Using_Meta_modelling_for_Construction_of_an_End_User_Development_Framework.pdf:PDF},
  ISBN                     = {978-3-642-38705-0},
  Keywords                 = {End-User Development; Meta-Design; Meta-Modelling; Model driven Engineering; Eclipse Modeling Framework},
  Language                 = {English},
  Owner                    = {hisham},
  Review                   = {(Read for Clarisse's EUP class)
Meta-modeling: technique to define a modeling language in MDE (model-driven engineering) approaches
Research questions:
Q. How applicable is meta-modeling when designing a framework for constructing services for end-users?
A. Meta-modeling was useful to discuss the realization of the composition language and for the end-user notation 
My comment: in other words, it helped bringing formalization to the project
Q. Is it possible to construct environments for composition with existing MDE technologies such as EMF (Eclipse Modeling Framework)?
A. EMF was useful for desktop tools and there was some reuse with Android; integration with GWT was difficult
My comment: tool only works well for uses that were foreseen during its design.
Q. What are the architectural implications of meta-modeling and MDE technologies?
A. Use of the same architecture in different environments.
My comment: reuse is easier when things are better specified.},
  Timestamp                = {2014-12-15},
  Url                      = {http://dx.doi.org/10.1007/978-3-642-38706-7_7}
}

@Article{Suhler1990103,
  Title                    = {TDFL: A task-level data flow language},
  Author                   = {Paul A. Suhler and Jit Biswas and Kim M. Korner and James C. Browne},
  Journal                  = {Journal of Parallel and Distributed Computing },
  Year                     = {1990},
  Number                   = {2},
  Pages                    = {103 - 115},
  Volume                   = {9},

  __markedentry            = {[hisham:1]},
  Abstract                 = {The Task-Level Dataflow Language is a graphical language for architecture-independent parallel programming and is intended for the writing of new programs and the adaptation of existing ones. It is the first coarse-grained dataflow language that supports dynamic modification of program graphs. It provides a systematic use of program constructs to support particular programming styles, such as nondeterminism, iteration, and replication. It has been used successfully in a course on parallel programming. },
  Doi                      = {http://dx.doi.org/10.1016/0743-7315(90)90039-R},
  File                     = {:Users/hisham/ac/dr/reading/pdf/TDFL__A_task_level_data_flow_language.pdf:PDF},
  ISSN                     = {0743-7315},
  Owner                    = {hisham},
  Timestamp                = {2016-01-19},
  Url                      = {http://www.sciencedirect.com/science/article/pii/074373159090039R}
}

@Article{Sui:2008:ART:1374752.1374755,
  Title                    = {An Automated Refactoring Tool for Dataflow Visual Programming Language},
  Author                   = {Sui, Yang Yi and Lin, Jun and Zhang, Xiao Tuo},
  Journal                  = {SIGPLAN Not.},
  Year                     = {2008},

  Month                    = apr,
  Number                   = {4},
  Pages                    = {21--28},
  Volume                   = {43},

  __markedentry            = {[hisham:1]},
  Abstract                 = {Refactoring tools are extremely important to prevent errors and reduce consumed time. But these tools only support text-based languages, especially in Object Oriented languages. In order to accommodate the situation that Dataflow Visual Programming Languages (DFVPLs) are more and more popular, an automated refactoring tool for DFVPL was proposed. DFVPL was divided into two layers---visual layer and dataflow layer. Two layers mutually evolved, which ensured correctness of visual elements and dataflow semantic during refactoring. Some algorithms like middle graph generation; terminal auto-generation and terminal auto-modification were proposed to implement the changes of two layers. This tool has been proved correct and efficient by some refactoring instances. In addition, we discussed some famous DFVPL like LabVIEW to expose lacking of automated refactoring tool forced refactoring by hand to be time-consuming and error-prone.},
  Acmid                    = {1374755},
  Address                  = {New York, NY, USA},
  Doi                      = {10.1145/1374752.1374755},
  File                     = {:Users/hisham/ac/dr/reading/pdf/An Automated Refactoring Tool for Dataflow Visual Programming Language.pdf:PDF},
  ISSN                     = {0362-1340},
  Issue_date               = {April 2008},
  Keywords                 = {dataflow, dataflow visual programming language, refactoring, software engineering},
  Numpages                 = {8},
  Owner                    = {hisham},
  Publisher                = {ACM},
  Timestamp                = {2017-03-08},
  Url                      = {http://doi.acm.org/10.1145/1374752.1374755}
}

@Article{tanimoto1990liveness,
  Title                    = {{VIVA}: a visual language for image processing},
  Author                   = {S. L. Tanimoto},
  Journal                  = {{ Journal of Visual Languages and Computing}},
  Year                     = {1990},
  Pages                    = {127--139},
  Volume                   = {1},

  __markedentry            = {[hisham:]},
  Abstract                 = {Visual languages have been developed to help new programmers express algorithms easily. They also help to make experienced programmers more productive by simplifying the organization of a program through the use of visual representations. However, visual languages have not reached their full potential because of several problems including the following: difficulty of producing visual representations for the more abstract computing constructs; the lack of adequate computing power to update the visual representations in response to user actions; the immaturity of the subfield of visual programming and need for additional breakthroughs and standardization of existing 
mechanisms. Visualization of Vision Algorithms (VIVA) is a proposed visual language for image processing. Its main purpose is to serve as an effective teaching tool for students of image processing. Its design also takes account of several secondary goals, including the completion of a software platform for research in human/image interaction, the creation of a vehicle for studying algorithms and architectures for parallel image processing, and the establishment of a presentation medium for image-processlng algorithms.},
  File                     = {:Users/hisham/ac/dr/reading/pdf/VIVA__A_Visual_Language_for_Image_Processing.pdf:PDF},
  Owner                    = {hisham},
  Review                   = {Introduces a categorization for four liveness levels:
1 - Informative: flowchart as ancillary description
2 - Informative and significant: executable flowchart
3 - Informative, significant and responsive: edit-triggered updates
4 - Informative, significant, responsive and live: stream-driven updates},
  Timestamp                = {2017-01-10}
}

@InProceedings{Todd:2004:MGU:976310.976322,
  Title                    = {What Makes a Good User Interface Pattern Language?},
  Author                   = {Todd, E. and Kemp, E. and Phillips, C.},
  Booktitle                = {Proceedings of the Fifth Conference on Australasian User Interface - Volume 28},
  Year                     = {2004},

  Address                  = {Darlinghurst, Australia, Australia},
  Pages                    = {91--100},
  Publisher                = {Australian Computer Society, Inc.},
  Series                   = {AUIC '04},

  __markedentry            = {[hisham:1]},
  Abstract                 = {A developer of user interfaces (UI) should be able to employ a user interface pattern language to design acceptable user interfaces. But, what makes a good pattern language? Three types of validation were identified as requiring consideration: the validity of the individual patterns, the internal validation of the pattern language and the external validation of the pattern language. This paper investigates internal validity. A set of six tests that a developer can use to test the internal validity of a pattern language has been identified.},
  Acmid                    = {976322},
  File                     = {:Users/hisham/ac/dr/reading/pdf/What_Makes_a_Good_User_Interface_Pattern_Language_.pdf:PDF},
  Keywords                 = {pattern language validation, pattern languages, user interface design},
  Location                 = {Dunedin, New Zealand},
  Numpages                 = {10},
  Owner                    = {hisham},
  Timestamp                = {2015-05-18},
  Url                      = {http://dl.acm.org/citation.cfm?id=976310.976322}
}

@Article{Treleaven:1982:DDC:356869.356873,
  Title                    = {Data-Driven and Demand-Driven Computer Architecture},
  Author                   = {Treleaven, Philip C. and Brownbridge, David R. and Hopkins, Richard P.},
  Journal                  = {ACM Computing Surveys},
  Year                     = {1982},

  Month                    = mar,
  Number                   = {1},
  Pages                    = {93--143},
  Volume                   = {14},

  Abstract                 = {Novel data-driven and demand-driven computer architectures are under development in a
large number of laboratories in the United States, Japan, and Europe. These computers
are not based on the traditional von Neumann organization; instead, they are attempts to
identify the next generation of computer. Basically, in data-driven (e.g., data-flow)
computers the availability of operands triggers the execution of the operation to be
performed on them, whereas in demand-driven (e.g, reduction) computers the
reqmrement for a result triggers the operation that will generate it.
Although there are these two distinct areas of research, each laboratory has developed
its own individual model of computation, stored program representation, and machine
organization. Across this spectrum of designs there is, however, a significant sharing of
concepts. The aim of this paper is to identify the concepts and relationships that exist
both within and between the two areas of research. It does thin by examining data-driven
and demand-driven architecture at three levels: computation organization, (stored)
program organization, and machine organLzation. Finally, a survey of various novel
computer architectures under development is given.},
  Acmid                    = {356873},
  Address                  = {New York, NY, USA},
  Doi                      = {10.1145/356869.356873},
  ISSN                     = {0360-0300},
  Issue_date               = {March 1982},
  Numpages                 = {51},
  Owner                    = {hisham},
  Publisher                = {ACM},
  Timestamp                = {2017-01-12},
  Url                      = {http://doi.acm.org/10.1145/356869.356873}
}

@Article{2013arXiv1307.7261T,
  Title                    = {{The Power of Spreadsheet Computations}},
  Author                   = {{Tyszkiewicz}, J.},
  Journal                  = {ArXiv e-prints},
  Year                     = {2013},

  Month                    = {jul},

  Abstract                 = {We investigate the expressive power of spreadsheets. We consider spreadsheets which contain only formulas, and assume that they are small templates, which can be filled to a larger area of the grid to process input data of variable size. Therefore we can compare them to well-known machine models of computation. We consider a number of classes of spreadsheets defined by restrictions on their reference structure. Two of the classes correspond closely to parallel complexity classes: we prove a direct correspondence between the dimensions of the spreadsheet and amount of hardware and time used by a parallel computer to compute the same function. As a tool, we produce spreadsheets which are universal in these classes, i.e. can emulate any other spreadsheet from them. In other cases we implement in the spreadsheets in question instances of a polynomial-time complete problem, which indicates that the the spreadsheets are unlikely to have efficient parallel evaluation algorithms. Thus we get a picture how the computational power of spreadsheets depends on their dimensions and structure of references.},
  Adsnote                  = {Provided by the SAO/NASA Astrophysics Data System},
  Adsurl                   = {http://adsabs.harvard.edu/abs/2013arXiv1307.7261T},
  Archiveprefix            = {arXiv},
  Eprint                   = {1307.7261},
  Keywords                 = {Computer Science - Programming Languages, K.8.1, F.1.2, F.1.1},
  Owner                    = {hisham},
  Primaryclass             = {cs.PL},
  Review                   = {Models a P-complete program (CVP) in a spreadsheet, considering the consecutive copies of the fill operation as computation steps, demonstrating the equivalence to a PRAM machine.},
  Timestamp                = {2016-03-22}
}

@InProceedings{Tyszkiewicz:2010:SRD:1807167.1807191,
  Title                    = {Spreadsheet As a Relational Database Engine},
  Author                   = {Tyszkiewicz, Jerzy},
  Booktitle                = {Proceedings of the 2010 ACM SIGMOD International Conference on Management of Data},
  Year                     = {2010},

  Address                  = {New York, NY, USA},
  Pages                    = {195--206},
  Publisher                = {ACM},
  Series                   = {SIGMOD '10},

  Abstract                 = {Spreadsheets are among the most commonly used applications for data management and analysis. Perhaps they are even among the most widely used computer applications of all kinds. However, the spreadsheet paradigm of computation still lacks sufficient analysis.

In this paper we demonstrate that a spreadsheet can play the role of a relational database engine, without any use of macros or built-in programming languages, merely by utilizing spreadsheet formulas. We achieve that by implementing all operators of relational algebra by means of spreadsheet functions.

Given a definition of a database in SQL, it is therefore possible to construct a spreadsheet workbook with empty worksheets for data tables and worksheets filled with formulas for queries. From then on, when the user enters, alters or deletes data in the data worksheets, the formulas in query worksheets automatically compute the actual results of the queries. Thus, the spreadsheet serves as data storage and executes SQL queries, and therefore acts as a relational database engine.

The paper is based on Microsoft Excel (TM), but our constructions work in other spreadsheet systems, too. We present a number of performance tests conducted in the beta version of Excel 2010. Their conclusion is that the performance is sufficient for a desktop database with a couple thousand rows.},
  Acmid                    = {1807191},
  Doi                      = {10.1145/1807167.1807191},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Spreadsheet_As_a_Relational_Database_Engine.pdf:PDF},
  ISBN                     = {978-1-4503-0032-2},
  Keywords                 = {performance, relational algebra, relational databases, spreadsheets, sql},
  Location                 = {Indianapolis, Indiana, USA},
  Numpages                 = {12},
  Owner                    = {hisham},
  Review                   = {An RDBMS modeled entirely with spreadsheet formulas, with no macros required.},
  Timestamp                = {2015-11-25},
  Url                      = {http://doi.acm.org/10.1145/1807167.1807191}
}

@InProceedings{Ungar2010,
  Title                    = {Harnessing emergence for manycore programming: early experience integrating ensembles, adverbs, and object-based inheritance},
  Author                   = {Ungar, David and Adams, Sam S},
  Booktitle                = {Proceedings of the ACM international conference companion on Object oriented programming systems languages and applications companion},
  Year                     = {2010},
  Organization             = {ACM},
  Pages                    = {19--26},

  Abstract                 = {We believe that embracing nondeterminism and harnessing emergence have great potential to simplify the task of programming manycore processors. To that end, we have designed and implemented Ly, pronounced "Lee", a new parallel programming language built around two new concepts: (i) ensembles which provide for parallel execution and replace all collections and (ii) iterators, and adverbs, which modify the parallel behavior of messages sent to ensembles. The broad issues around programming in this fashion still need investigation, but, after our initial Ly programming experience, we have identified some specific issues that must be addressed in integrating these concepts into an object-based language, including empty ensembles, partial message understanding, non-local returns from ensemble members, and unintended ensembles.},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Harnessing_emergence_for_manycore_programming__early_experience_integrating_ensembles__adverbs__and_object_based_inheritance.pdf:PDF},
  Owner                    = {hisham},
  Review                   = {"Ensembles": collections to which messages are sent in parallel.
Ly: an experimental programming language to explore this.
"Adverbs": modifiers to how messages are handled by ensembles ("totally", "pairwise", "serially")
Many open design decisions related to object inheritance, and the logic for dispatching methods.},
  Timestamp                = {2014-09-09},
  Url                      = {http://dl.acm.org/citation.cfm?id=1869546}
}

@InProceedings{Uustalu:2005:EDP:2099708.2099712,
  Title                    = {The Essence of Dataflow Programming},
  Author                   = {Uustalu, Tarmo and Vene, Varmo},
  Booktitle                = {Proceedings of the Third Asian Conference on Programming Languages and Systems},
  Year                     = {2005},

  Address                  = {Berlin, Heidelberg},
  Pages                    = {2--18},
  Publisher                = {Springer-Verlag},
  Series                   = {APLAS'05},

  Abstract                 = {We propose a novel, comonadic approach to dataflow (stream-based) computation. This is based on the observation that both general and causal stream functions can be characterized as coKleisli arrows of comonads and on the intuition that comonads in general must be a good means to structure context-dependent computation. In particular, we develop a generic comonadic interpreter of languages for context-dependent computation and instantiate it for stream-based computation. We also discuss distributive laws of a comonad over a monad as a means to structure combinations of effectful and context-dependent computation. We apply the latter to analyse clocked dataflow (partial stream based) computation.},
  Acmid                    = {2099712},
  Doi                      = {10.1007/11575467_2},
  File                     = {:Users/hisham/ac/dr/reading/pdf/The_Essence_of_Dataflow_Programming.pdf:PDF},
  ISBN                     = {3-540-29735-9, 978-3-540-29735-2},
  Keywords                 = {dataflow, comonads},
  Location                 = {Tsukuba, Japan},
  Numpages                 = {17},
  Owner                    = {hisham},
  Review                   = {Demonstrates that the semantics of dataflow operators can be specified through comonads.},
  Timestamp                = {2014-08-27},
  Url                      = {http://dx.doi.org/10.1007/11575467_2}
}

@InProceedings{VandenBergh:2011:CCA:1996461.1996491,
  Title                    = {CAP3: Context-sensitive Abstract User Interface Specification},
  Author                   = {Van den Bergh, Jan and Luyten, Kris and Coninx, Karin},
  Booktitle                = {Proceedings of the 3rd ACM SIGCHI Symposium on Engineering Interactive Computing Systems},
  Year                     = {2011},

  Address                  = {New York, NY, USA},
  Pages                    = {31--40},
  Publisher                = {ACM},
  Series                   = {EICS '11},

  __markedentry            = {[hisham:1]},
  Abstract                 = {Despite the fact many proposals have been made for abstract user interface models it was not given a detailed context in which it should or could be used in a user-centered design process. This paper presents a clear role for the abstract user interface model in user-centered and model-based development, provides an overview of the stakeholders that may create and/or use abstract user interface models and presents a modular abstract user interface modeling language, CAP3, that makes relations with other models explicit and builds on the foundation of existing abstract user interface models. The proposed modeling notation is supported by a tool and applied to some case studies from literature and in some projects. It is also validated based on state-of-the-art knowledge on domain-specific modeling languages and visual notations and some case studies.},
  Acmid                    = {1996491},
  Doi                      = {10.1145/1996461.1996491},
  File                     = {:Users/hisham/ac/dr/reading/pdf/CAP3__Context_sensitive_Abstract_User_Interface_Specification.pdf:PDF},
  ISBN                     = {978-1-4503-0670-6},
  Keywords                 = {abstract user interface, cap3, graphical notation, modeling language, user interface design},
  Location                 = {Pisa, Italy},
  Numpages                 = {10},
  Owner                    = {hisham},
  Timestamp                = {2015-05-18},
  Url                      = {http://doi.acm.org/10.1145/1996461.1996491}
}

@InCollection{VanderZanden1992LDUI,
  Title                    = {An Active-Value--Spreadsheet Model for Interactive Languages},
  Author                   = {Brad {Vander Zanden}},
  Booktitle                = {Languages for developing user interfaces},
  Publisher                = {AK Peters, Ltd.},
  Year                     = {1992},
  Chapter                  = {12},
  Editor                   = {Brad A. Myers},
  Pages                    = {183--210},

  Owner                    = {hisham},
  Review                   = {Models of interactive computing must evolve toward distributed control: spreadsheet model.
Multi-way relationships via multi-way constraint solver.
Spreadsheet-object model.
Features necessary for an interactive language: incremental computation; parallelism; async input handling; data-driven and declarative format; formal specification; rapid prototyping amenable to specification via tools.
Active-value--spreadsheet model: extends spreadsheet-object model with:
* structural relationships: lower-level than CIP. Action-procedures which allow side effects
* multi-way constraints: solvable via graph traversal algorithms
Guards in constraints to specify behavior: right = left + width. Changing right may be "move" or "resize".
Comparisons:
OOP: Naive message propagation in OOP can cause an explosion of update messages.
CIP: equally expressive. AVS can be more efficient, CIP more declarative.
Constraint Language Programming: can they support large-scale interactive applications?},
  Timestamp                = {2014-08-28}
}

@Electronic{Vercoe2014CSound,
  Title                    = {The Canonical Csound Reference Manual, Version 6.00.1},
  Author                   = {Barry Vercoe and others},
  HowPublished             = {http://www.csounds.com/manual/html/index.html},
  Month                    = {jan},
  Organization             = {MIT Media Lab},
  Url                      = {http://www.csounds.com/manual/html/index.html},
  Year                     = {2015},

  File                     = {:Users/hisham/ac/dr/reading/pdf/The_Canonical_Csound_Reference_Manual__Version_6_00_1.pdf:PDF},
  Owner                    = {hisham},
  Review                   = {Manual of CSound.},
  Timestamp                = {2015-01-13}
}

@TechReport{TUD-SERG-2015-003,
  Title                    = {{DynSem}: a {DSL} for Dynamic Semantics Specification},
  Author                   = {Vlad Vergu and Pierre Neron and Eelco Visser},
  Institution              = {{Delft University of Technology}},
  Year                     = {2015},

  Address                  = {Delft},
  Number                   = {TUD-SERG-2015-003},

  __markedentry            = {[hisham:1]},
  Abstract                 = {The formal definition the semantics of a programming language and its implementation are typ-
ically separately defined, with the risk of divergence such that properties of the formal semantics
are not properties of the implementation. In this paper, we present DynSem, a domain-specific
language for the specification of the dynamic semantics of programming languages that aims at
supporting both formal reasoning and efficient interpretation. DynSem supports the specification
of the operational semantics of a language by means of statically typed conditional term reduction
rules. DynSem supports concise specification of reduction rules by providing implicit build and
match coercions based on reduction arrows and implicit term constructors. DynSem supports
modular specification by adopting implicit propagation of semantic components from I-MSOS,
which allows omitting propagation of components such as environments and stores from rules
that do not affect those. DynSem supports the declaration of native operators for delegation
of aspects of the semantics to an external definition or implementation. DynSem supports the
definition of auxiliary meta-functions, which can be expressed using regular reduction rules and
are subject to semantic component propagation. DynSem specifications are executable through
automatic generation of a Java-based AST interpreter.},
  Owner                    = {hisham},
  Timestamp                = {2016-03-08},
  Url                      = {http://swerl.tudelft.nl/twiki/pub/Main/TechnicalReports/TUD-SERG-2015-003.pdf}
}

@InProceedings{VonThun2001,
  Title                    = {Joy: Forth's functional cousin},
  Author                   = {Von Thun, Manfred},
  Booktitle                = {Proceedings from the 17th EuroForth Conference},
  Year                     = {2001},

  Abstract                 = {The language Joy is a purely functional programming language. Whereas all other functional programming languages are based on the application of functions to arguments, Joy is based on the composition of functions. All such functions take a stack as argument and produce a stack as value. [...] This paper is intended as an introduction for Forth programmers.},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Joy__Forth_s_functional_cousin.pdf:PDF},
  Keywords                 = {concatenative},
  Owner                    = {hisham},
  Review                   = {Joy is a purely functional, concatenative programming language.
Data types: numbers, sets, strings, lists (recursive)
Quotations and combinators
Recursive combinators ("linrec": linear recursive pattern)
Joy algebra: equivalence of Joy programs.},
  Timestamp                = {2014-08-27},
  Url                      = {http://www.complang.tuwien.ac.at/anton/euroforth/ef01/thomas01a.pdf}
}

@Book{wadge1985lucid,
  Title                    = {Lucid, the Data Flow Programming Language},
  Author                   = {Wadge, W.W. and Ashcroft, E.A.},
  ISBN                     = {9780127296500},
  Publisher                = {Academic Press},
  Year                     = {1985},
  Series                   = {APIC Studies in Data Processing Series},

  File                     = {:Users/hisham/ac/dr/reading/pdf/Lucid__the_Data_Flow_Programming_Language.pdf:PDF},
  Lccn                     = {lc84015685},
  Owner                    = {hisham},
  Review                   = {Introduction to Lucid
Discussion on what is dataflow},
  Timestamp                = {2016-01-11},
  Url                      = {http://www.cse.unsw.edu.au/~plaice/archive/WWW/1985/B-AP85-LucidDataflow.pdf}
}

@Article{Wakeling:2007:SFP:1194875.1194878,
  Title                    = {Spreadsheet Functional Programming},
  Author                   = {Wakeling, David},
  Journal                  = {Journal of Functional Programming},
  Year                     = {2007},

  Month                    = {jan},
  Number                   = {1},
  Pages                    = {131--143},
  Volume                   = {17},

  Abstract                 = {The functional programming community has shown some interest in spreadsheets, but surprisingly no one seems to have considered making a standard spreadsheet, such as Excel, work with a standard functional programming language, such as Haskell. In this paper, we show one way that this can be done. Our hope is that by doing so, we might get spreadsheet programmers to give functional programming a try.},
  Acmid                    = {1194878},
  Address                  = {New York, NY, USA},
  Doi                      = {10.1017/S0956796806006186},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Spreadsheet_Functional_Programming.pdf:PDF},
  ISSN                     = {0956-7968},
  Issue_date               = {January 2007},
  Numpages                 = {13},
  Owner                    = {hisham},
  Publisher                = {Cambridge University Press},
  Review                   = {Integrates a Haskell interpreter as an Excel function.
UI hack: Haskell functions can be input from the Excel interface as cell comments.},
  Timestamp                = {2014-12-09},
  Url                      = {http://journals.cambridge.org/action/displayFulltext?type=1&fid=642608&jid=JFP&volumeId=17&issueId=01&aid=642604}
}

@InBook{Walker2002:linear,
  Title                    = {Advanced Topics in Types and Programming Languages},
  Author                   = {Walker, David},
  Chapter                  = {Substructural Type Systems},
  Editor                   = {Pierce, Benjamin C.},
  Pages                    = {3--43},
  Publisher                = {MIT Press},
  Year                     = {2002},

  __markedentry            = {[hisham:1]},
  Booktitle                = {Advanced Topics in Types and Programming Languages},
  Owner                    = {hisham},
  Timestamp                = {2014-12-22}
}

@Article{Whiting:1994:HDL:612489.612574,
  Title                    = {A History of Data-Flow Languages},
  Author                   = {Whiting, Paul G. and Pascoe, Robert S. V.},
  Journal                  = {IEEE Ann. Hist. Comput.},
  Year                     = {1994},

  Month                    = {dec},
  Number                   = {4},
  Pages                    = {38--59},
  Volume                   = {16},

  Abstract                 = {Data-flow refers both to a language-level paradigm of computation and to a family of processor architectures based on this paradigm. This article elaborates data-flow language issues and the evolution of data-flow languages. In considering limits to the expressive power of these languages, underlying architectural issues are discussed. Although the article attempts to present a complete history of data-flow languages, it concentrates on those languages that specifically belong to this class and have been implemented for a data-flow machine. In many cases, the distinctions between issues of language semantics and machine architecture are unclear. Usually we have found that this reflects the evolution of data-flow, and the close association between language and architecture development. In some sections of the article, it may appear that there is an imbalance in the amount of detail presented when compared with other sections. This imbalance is proportional to the publications and the amount of information readily available for the topics.},
  Acmid                    = {612574},
  Address                  = {Piscataway, NJ, USA},
  Doi                      = {10.1109/85.329757},
  File                     = {:Users/hisham/ac/dr/reading/pdf/A_History_of_Data_Flow_Languages.pdf:PDF},
  ISSN                     = {1058-6180},
  Issue_date               = {December 1994},
  Numpages                 = {22},
  Owner                    = {hisham},
  Publisher                = {IEEE Educational Activities Department},
  Timestamp                = {2016-01-21},
  Url                      = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=329757}
}

@PhdThesis{Wipliez2010,
  Title                    = {Compilation infrastructure for dataflow programs},
  Author                   = {Matthieu Wipliez},
  School                   = {INSA de Rennes},
  Year                     = {2010},

  Abstract                 = {The work presented in this thesis takes place in a context of growing demand for better video quality (High-Definition TV, home cinema...) and unprecedented concern for  power consumption. The limitations and lack of flexibility of current video standards make it increasingly long and complicated to implement standards, particularly on embedded systems. A new standard called Reconfigurable Video Coding aims to solve these problems by describing video decoders with dynamic dataflow programs.

A dataflow program is a program represented as a directed graph where vertices are computational units (or actors) and edges represent the flow of data between vertices. A Model of Computation (MoC) defines thesemantics of dataflow programs as a subset of the most general Dataflow Process Network (DPN) model. There are different MoCs that offer different trade-offs between expressiveness and compile-time predictability. For instance, the SDF model is the most restrictive subset of DPN with respect to expressiveness, but it is also the most predictable: it is possible to map and schedule SDF graphs onto multi-processors at compile-time while minimizing memory consumption. A dynamic dataflow program that respects the unrestricted DPN model, however, is not schedulable at compile-time and memory consumption may not be bounded in all cases.

The work described in this thesis is a compilation infrastructure for dataflow programs. The dataflow programs considered are dynamic dataflow programs, and the thesis shows how actors of these programs can be represented in a simple, high-level Intermediate Representation (IR). The IR of actors can be automatically analyzed by a classification method presented in the thesis, which annotates the actors that can behave according to a MoC that is more restricted than the general DPN model. The infrastructure is also capable of transforming such actors at a higher-level of description. Finally, the thesis shows how dynamic dataflow programs can be transformed to several languages, from C to hardware description languages, and presents results about the performance of the generated code.},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Compilation infrastructure for dataflow programs.pdf:PDF},
  Owner                    = {hisham},
  Review                   = {incudes an example with classification between static, cyclo-static, quasi-static, dynamic and time-dependent actors in a MPEG decoder},
  Timestamp                = {2017-03-12}
}

@Article{Yazar2015,
  Title                    = {Design of Dataflow},
  Author                   = {Yazar, Tu{\u{g}}rul},
  Journal                  = {Nexus Network Journal},
  Year                     = {2015},
  Number                   = {1},
  Pages                    = {311--325},
  Volume                   = {17},

  __markedentry            = {[hisham:1]},
  Abstract                 = {Design scripting is initially based on secondary syntactic mechanisms that control sequential executions of code. This model of computation, called control flow programming, was introduced to designers as the only way of creating algorithms. Dataflow represents a widespread alternative to control flow by utilizing concurrent streams of data. Dataflow programming languages are also considered to be pedagogical tools in fields where the coders are not expert computer programmers. In the last decade, new parametric modeling tools introduced this conception to design scripting, shifting its practical and educational foundations. Dataflow programming represents a promising platform for studying contemporary parametric modeling techniques in design, while architects and designers increasingly use it as their algorithmic sketchbooks. This paper describes a purpose to reflect this shift in design education, pursuing four pedagogical patterns derived from in-class experiments: ``explication'', ``kit of components'', ``objectification'', and ``re-generation''.},
  Doi                      = {10.1007/s00004-014-0222-8},
  ISSN                     = {1522-4600},
  Owner                    = {hisham},
  Review                   = {Architecture paper about dataflow. Author is an Architecture academic working on Computational Design.},
  Timestamp                = {2017-03-08},
  Url                      = {http://dx.doi.org/10.1007/s00004-014-0222-8}
}

@TechReport{Yoder94spreadsheetdataflow,
  Title                    = {Observations on spreadsheet languages, intension and dataflow},
  Author                   = {Alan G. Yoder and David L. Cohn},
  Institution              = {University of Notre Dame},
  Year                     = {1994},
  Number                   = {TR-94-22},
  Type                     = {Technical Report},

  __markedentry            = {[hisham:1]},
  File                     = {:Users/hisham/ac/dr/reading/pdf/Observations_on_Spreadsheet_Languages_Intension_and_dataflow.pdf:PDF},
  Owner                    = {hisham},
  Timestamp                = {2017-01-16},
  Url                      = {ftp://www.cse.nd.edu/pub/Reports/1994/tr-94-22.ps}
}

@Electronic{Zmolnig2014pd,
  Title                    = {How to write an External for {Pure Data}},

  Address                  = {Graz, Austria},
  Author                   = {Iohannes M. Zm{\"o}lnig},
  HowPublished             = {\url{http://iem.at/pd/externals-HOWTO/}},
  Month                    = {March},
  Organization             = {Institut f{\"u}r Elektronische Musik und Akustik - {IEM}},
  Url                      = {http://iem.at/pd/externals-HOWTO/},
  Year                     = {2014},

  Abstract                 = {Pd is a graphical real-time computer-music system that follows the tradition of IRCAMs ISPW-max.

Although plenty of functions are built into Pd, it is sometimes a pain or simply impossible to create a patch with a certain functionality out of the given primitives and combinations of these.

Therefore, Pd can be extended with self made primitives (“objects”) that are written in complex programming-languages, like C/C++.

This document aims to explain how to write such primitives in C, the popular language that was used to realize Pd.},
  File                     = {:Users/hisham/ac/dr/reading/pdf/How_to_write_an_External_for__Pure_Data_.pdf:PDF},
  Keywords                 = {pure data},
  Owner                    = {hisham},
  Review                   = {manual for writing C extensions in Pure Data. Offers insights on the semantics of Pure Data objects and its evaluation model.},
  Timestamp                = {2015-10-07}
}

@Electronic{YahooPipes,
  Title                    = {Yahoo! Pipes Documentation},
  Month                    = {April},
  Url                      = {http://pipes.yahoo.com/pipes/docs},
  Year                     = {2015},

  Owner                    = {hisham},
  Timestamp                = {2015-04-15}
}

@Misc{cve-shellshock,
  Title                    = {{CVE}-2014-6271},
  HowPublished             = {CVE List Master Copy, {MITRE}},
  Month                    = {September},
  Note                     = {\url{https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271}},
  Year                     = {2014},

  Abstract                 = {GNU Bash through 4.3 processes trailing strings after function definitions in the values of environment variables, which allows remote attackers to execute arbitrary code via a crafted environment, as demonstrated by vectors involving the ForceCommand feature in OpenSSH sshd, the mod_cgi and mod_cgid modules in the Apache HTTP Server, scripts executed by unspecified DHCP clients, and other situations in which setting the environment occurs across a privilege boundary from Bash execution, aka "ShellShock." NOTE: the original fix for this issue was incorrect; CVE-2014-7169 has been assigned to cover the vulnerability that is still present after the incorrect fix.},
  Day                      = {09},
  File                     = {:Users/hisham/ac/dr/reading/pdf/_CVE__2014_6271.pdf:PDF},
  Institution              = {MITRE},
  Key                      = {CVE-2014-6271},
  Owner                    = {hisham},
  Timestamp                = {2014-12-17},
  Url                      = {https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271}
}

@Manual{AdobePDF-2000,
  Title                    = {Adobe Portable Document Format, version 1.3},
  Edition                  = {2nd},
  Organization             = {{Adobe Systems Incorporated}},
  Year                     = {2000},

  File                     = {:Users/hisham/ac/dr/reading/pdf/Adobe_Portable_Document_Format__version_1_3.pdf:PDF},
  Owner                    = {hisham},
  Review                   = {Specification of PDF
Comparison with PostScript language in page 19:
Mentions that programming constructs were removed.},
  Timestamp                = {2015-02-13},
  Url                      = {http://acroeng.adobe.com/PDFReference/PDF_1.3/PDF%20Reference%201.3.pdf}
}

