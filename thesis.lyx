#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass extbook
\begin_preamble

\def\dstart{\hbox to \hsize{\vrule depth 4pt\hrulefill\vrule depth 4pt}}
\def\dend{\hbox to \hsize{\vrule height 4pt\hrulefill\vrule height 4pt}}

\input{PdInterpreter_preamble.tex}
\input{XlInterpreter_preamble.tex}
\input{LvInterpreter_preamble.tex}
\end_preamble
\options hyphens
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type numerical
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 3cm
\topmargin 3cm
\rightmargin 3cm
\bottommargin 3cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
fix all ~[references]
\end_layout

\begin_layout Plain Layout
Would be nice:
\end_layout

\begin_layout Plain Layout
implement [trigger] in Pure Data?
\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{titlepage}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\shape smallcaps
\size larger
PUC-Rio
\shape default
\size default

\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\shape smallcaps
\size large
Departamento de Informática
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset VSpace 0.5cm
\end_inset


\shape smallcaps
\size large
PhD Thesis
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset CommandInset line
LatexCommand rule
offset "0.2ex"
width "100col%"
height "0.5mm"

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset VSpace 2mm
\end_inset


\series bold
\size huge
Dataflow Semantics for End-User
\end_layout

\begin_layout Plain Layout
\align center

\series bold
\size huge
Programmable Applications
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset CommandInset line
LatexCommand rule
offset "0.2ex"
width "100col%"
height "0.5mm"

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset VSpace 0.5cm
\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\size large
\emph on
Author:
\end_layout

\begin_layout Plain Layout

\size large
Hisham Hashem Muhammad
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "40col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\align right

\size large
\emph on
Advisor:
\emph default

\begin_inset Newline newline
\end_inset

Roberto Ierusalimschy
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset VSpace 5cm
\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\size large
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\end_inset

January 19th, 2016
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{titlepage}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\emph on
This page intentionally contains only this sentence.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Chapter*
Abstract
\end_layout

\begin_layout Standard
End-user programming refers to programming performed by end-users who are
 not professionals in software development but are specialists in other
 domains.
 Scripting is one way to add programmability to applications as an advanced,
 peripheral feature.
 Another alternative is to make an end-user language central to the application'
s UI, as is the case with spreadsheet formulas: programming becomes indistinguis
hable from using the application proper.
 Scripting has evolved from ad hoc "little languages" into reusable embeddable
 languages, which benefit from the advances of programming language research.
 The state of UI-level end-user programming languages, however, lags behind:
 those are still developed ad hoc and tied to their domains.
 We claim that end-user languages should also be developed constructing
 domain-specific UIs on top of reusable core semantics, much like scripting
 is now done presenting domain-specific abstractions of top of reusable
 scripting languages.
 For this, however, an understanding of the underlying programming model
 is necessary.
 In this work, we model the semantics of existing end-user programming languages
 of different domains, such as spreadsheets and multimedia, aiming to better
 understand their commonalities and shortcomings.
 Our focus is on the dataflow paradigm, since this paradigm is representative
 of a number of applications where end-user programmability takes center
 stage.
 Based on this understanding, our goal is to provide a better understanding
 of dataflow semantics in the context of end-user programming and propose
 guidelines for the development of dataflow languages for end-user programmable
 applications.
 
\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Section
Motivation
\end_layout

\begin_layout Standard

\emph on
End-user programming
\emph default
 is a term that refers to programming activities performed by end-users,
 who are not specialists in professional software development but are specialist
s in other domains, in the context of software developed for their domain
 of interest 
\begin_inset CommandInset citation
LatexCommand cite
key "Burnett2014EUD"

\end_inset

.
 Early focus of end-user programming was in 
\emph on
scripting
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "Ousterhout:1998:SHP:619027.620930"

\end_inset

: embedding a programming language into an application so that users can
 write programs that drive the application, or at least parts of it.
 Some examples are Visual Basic for Applications in the Microsoft Office
 productivity suite and AutoLISP in AutoCAD.
 However, most end-user programming happens using languages not regarded
 by their users as programming languages proper, such as spreadsheets and
 graphical node editors 
\begin_inset CommandInset citation
LatexCommand cite
key "MyersReport1992LDUI"

\end_inset

.
 For this reason, the latter term 
\begin_inset Quotes eld
\end_inset

end-user development
\begin_inset Quotes erd
\end_inset

 took over, which avoids having to answer the question of what is and what
 isn't programming.
\end_layout

\begin_layout Standard
Still, those languages are indeed domain-specific languages (DSLs), even
 if they often have restricted expressivity and if their syntaxes (often
 a mix of textual elements and graphics) do not make it clear that they
 are programming languages.
 In particular, there are applications where the language becomes indistinguisha
ble from the user interface (UI), and using the software means using the
 language.
 Examples of scenarios where this happens are spreadsheets such as Excel
 
\begin_inset CommandInset citation
LatexCommand cite
key "Nardi1993"

\end_inset

, where using the spreadsheet means using the formula language, and the
 node graph environment of Pure Data, a multimedia application developed
 primarily for music 
\begin_inset CommandInset citation
LatexCommand cite
key "PuckettePd"

\end_inset

.
 Here, we will call these languages 
\emph on
UI-level languages
\emph default
: programming languages that are apparent to the user as the main UI of
 the application (not to be confused with languages for constructing GUIs).
\end_layout

\begin_layout Standard
There is, therefore, a spectrum of possibilities on how deeply to integrate
 programmability into end-user applications.
 It can range from being an optional feature for advanced users, as is often
 the case with scripting, to being at the core of the application experience,
 as is the case with UI-level languages.
\end_layout

\begin_layout Standard
The programming language community has given much attention to the scripting
 end of the spectrum of end-user programming.
 Scripting in applications has evolved through three stages:
\end_layout

\begin_layout Itemize
The first stage was the use of so-called 
\begin_inset Quotes eld
\end_inset

little languages
\begin_inset Quotes erd
\end_inset

 of the 1970s and 1980s 
\begin_inset CommandInset citation
LatexCommand cite
key "Bentley:1986:little"

\end_inset

—examples are small single-purpose languages such as 
\family typewriter
eqn
\family default
 and 
\family typewriter
pic
\family default
 in Unix 
\begin_inset CommandInset citation
LatexCommand citep
key "Dougherty1987unix"

\end_inset

, and SCUMM for scripting adventure-style games 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Originally created by Lucasfilm Games as 
\begin_inset Quotes eld
\end_inset

Script Creation Utility for 
\emph on
Maniac Mansion
\emph default

\begin_inset Quotes erd
\end_inset

 to be used in a single game; later used in dozens of games, licensed to
 several companies and even reimplemented as a free-software engine (
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.scummvm.org
\end_layout

\end_inset

).
 This illustrates the 
\begin_inset Quotes eld
\end_inset

accidental
\begin_inset Quotes erd
\end_inset

 nature of scripting languages from that era.
\end_layout

\end_inset

;
\end_layout

\begin_layout Itemize
Then, powerful domain-specific languages emerged, such as GraForth, WordBasic
 in Microsoft Word and AutoLISP in AutoCAD—these languages often adapted
 the design of existing general-purpose programming languages, producing
 application-specific dialects;
\end_layout

\begin_layout Itemize
Finally, once scripting was identified as a general style of programming
 
\begin_inset CommandInset citation
LatexCommand cite
key "Ousterhout:1998:SHP:619027.620930"

\end_inset

, we saw the introduction of general-purpose scripting languages such as
 Tcl, Python and Lua—these languages have embeddable implementations, allowing
 them to be linked as libraries and reused in many applications.
 Some of these languages became popular in particular domains in spite of
 not having been specifically designed for those fields: several graphics
 programs use Python as a scripting language, and Lua is particularly successful
 in the game industry.
\end_layout

\begin_layout Standard
The UI end of the spectrum, however, lags behind.
 The state of end-user UI-level languages now is similar to that of scripting
 languages in the 1980s: most applications develop their own custom 
\begin_inset Quotes eld
\end_inset

little languages
\begin_inset Quotes erd
\end_inset

 for end-user programming, tightly coupled to their UIs.
 At best, ideas are reused from similar efforts, as evidenced by several
 visual programming languages inspired by Scratch (Stencyl, AppInventor,
 Snap, Pocket Code), the various node/graph editors in multimedia applications
 (Nuke, Max/MSP, Blender, Rhino 3D, Antimony, Unreal Engine), and the formula
 languages for different spreadsheets.
\end_layout

\begin_layout Standard
The semantics of these UI-level languages, in particular, are often ill-specifie
d.
 This has wide-ranging consequences, affecting both users and developers.
 Users are struck by subtle incompatibilities even when different applications
 share the same basic metaphors, as is the case with different spreadsheet
 applications.
 Developers end up 
\begin_inset Quotes eld
\end_inset

reinventing the wheel
\begin_inset Quotes erd
\end_inset

, producing designs that are not informed by PL research, often subject
 to pitfalls that could have been avoided had the language been designed
 based on established grounds.
\end_layout

\begin_layout Section
Problem statement
\end_layout

\begin_layout Standard
While nowadays scripting is integrated into applications by reusing proven
 embeddable languages which benefit from the advances of programming language
 research, end-user UI-level languages are still developed ad hoc, often
 by developers who are specialists in the domain of the application (e.g.
 computer graphics, music, statistics, finance), but not in language design
 and implementation.
 This distinction manifests itself in many ways, ranging from unclear semantics
 and little possibility of knowledge reuse from the part of users, down
 to lack of application interoperability and performance issues.
 Programming language research is brought to the fold afterwards, when trying
 to find ways to integrate missing functionality or trying to fix issues
 with the design or implementation 
\begin_inset CommandInset citation
LatexCommand cite
key "Jones03User-centred,DinamicaVM"

\end_inset

.
\end_layout

\begin_layout Standard
By focusing on the presentation and direct manipulation of data, many UI-level
 languages adopt to some extent the dataflow paradigm 
\begin_inset CommandInset citation
LatexCommand cite
key "Johnston:2004:ADP:1013208.1013209"

\end_inset

, as it seems a natural fit for programmatic manipulation of data in user
 interfaces.
 Thus, the problem domain we focus our attention on is that of dataflow
 UI-level languages, as these are representative of a number of languages
 where end-user programmability takes center stage, and the problem we address
 in particular is that of ad hoc semantics in dataflow programmable UIs.
\end_layout

\begin_layout Standard
We identify the need for UI-level dataflow languages to go through a similar
 movement that occurred with scripting languages.
 Scripting languages evolved from ad hoc languages into standard reusable
 languages that integrate properly: they can be embedded in an application
 and can be extended with constructs for dealing with the application's
 domain.
\end_layout

\begin_layout Standard
This research attempts to provide developers of end-user programmable applicatio
ns with a semantics for dataflow, designed for integrating between a program's
 interface and its underlying back-end.
 The research question, therefore, is this: 
\emph on
if dataflow languages in end-user applications were designed for reuse in
 different applications, what would their semantics be like?
\end_layout

\begin_layout Standard
We begin with a background review of the fields of end-user programming
 and dataflow languages in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Background"

\end_inset

.
 Then, we sharpen our focus to define dataflow UI-level languages in Chapter
 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Dataflow-UI-langs"

\end_inset

, which is the class of languages we will be working from there on.
 We analyze existing UI-level dataflow languages, and produce semantics
 for a number of them, understanding their features and shortcomings.
 These are presented as case studies in Chapters 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Pure-Data"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Spreadsheets"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:LabVIEW"

\end_inset

.
 Informed by the design of those existing application-specific languages,
 we propose in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:A-Dataflow-Engine"

\end_inset

 a semantics for an embeddable and reusable dataflow UI-level language.
 Finally, in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Conclusion"

\end_inset

 we present the conclusion, in which we review our contributions.
\end_layout

\begin_layout Chapter
Background
\begin_inset CommandInset label
LatexCommand label
name "chap:Background"

\end_inset


\end_layout

\begin_layout Section
End-user programming
\end_layout

\begin_layout Standard

\emph on
End-user programming
\emph default
 is a term that describes the involvement of users in the addition of functional
ity to their applications via programming 
\begin_inset CommandInset citation
LatexCommand citep
key "Burnett2014EUD"

\end_inset

.
 For this to be possible, applications have to be designed with programmability
 in mind: they should allow new functionality to be built based on the combinati
on of existing ones, and there has to be linguistic support in the application
 so that the user may express this new functionality.
\end_layout

\begin_layout Subsection
Roles of programming in end-user applications
\end_layout

\begin_layout Standard
Depending on the application's design, end-user programming may take a 
\emph on
peripheral
\emph default
 or a 
\emph on
central
\emph default
 role in its use.
 We define them as such:
\end_layout

\begin_layout Itemize
Programming is 
\emph on
peripheral
\emph default
 to an end-user application if users can make effective use of the application
 with variable degrees of complexity, producing from simple to complex end-resul
ts (e.g.
 documents, queries, etc.), without ever resorting explicitly to the programming
 capabilities of the application.
\end_layout

\begin_layout Itemize
Programming is 
\emph on
central
\emph default
 to an end-user application if users must interact explicitly with the programmi
ng capabilities of the application in order to make any non-trivial use
 of it, even when producing simple end-results.
 In other words, using the application 
\emph on
is
\emph default
 using the application's programming language.
\end_layout

\begin_layout Standard
Examples of peripheral support for end-user programming are macro recorders
 and embedded scripting languages.
 Macro recording allows the user to automate sequences of steps, but offers
 little in the way of abstraction.
 Embedded scripting languages offer a programmable view to the application,
 by extending the application with the full power of a Turing-complete programmi
ng language.
 Still, we categorize these features as peripheral to the user of the applicatio
n, because most users can produce content in the application while ignoring
 its programmable aspects.
\end_layout

\begin_layout Standard
The LibreOffice Writer word processor and the Gimp image editor are examples
 of scriptable applications, where programming takes a peripheral role.
 A user can produce a text document with a very complex layout in LibreOffice
 Writer or an intricate multi-layered drawing in Gimp without ever touching
 their scripting abilities.
 A Gimp user may benefit implicitly from the scripting abilities of the
 application by using bundled filters and effects available in the application
 toolset that are implemented as scripts, but from the user's perspective
 these tools could just as well be built into the application's core.
 One could conceive an application where all tools are implemented as scripts;
 still, if the user could use these tools as black boxes without ever touching
 the programming language, this means the role of programming is not central
 from an end-user perspective.
 For this reason, we state that the interaction with the programming facilities
 needs to be explicit in order to characterize the activity as end-user
 programming.
\end_layout

\begin_layout Standard
A prominent example of an application where end-user programming takes a
 central role is the spreadsheet.
 A spreadsheet has an open-ended design in which users can create new solutions
 for their domains, expressed as calculations in a formula language.
 Programming is central in the sense that the programmable aspect of the
 application, the formula language, is unavoidable for any use beyond the
 trivial case of entering constants into cells: using the formula language
 is equivalent to using the spreadsheet.
\end_layout

\begin_layout Subsection
The three-layer architecture in end-user programmable applications
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sub:three-layer"

\end_inset


\end_layout

\begin_layout Standard
When programming support is added in a peripheral role to an application,
 it is usually to provide advanced flexibility beyond what the base feature
 set of the application offers: composition of features to automate workflows,
 iteration to avoid repetitive tasks, interaction with the operating system.
 Visual Basic for Applications (VBA), embedded in Microsoft Office programs,
 is an example of this.
\end_layout

\begin_layout Standard
This kind of addition also makes sense in applications where this base feature
 set is provided as a programming language in a central role.
 This means an application may feature programming in both central and periphera
l roles.
 Modern spreadsheets such as Excel are an example of this.
 For advanced uses, spreadsheets also offer scripting support: 
\begin_inset Quotes eld
\end_inset

macros
\begin_inset Quotes erd
\end_inset

, in spreadsheet parlance, are extension functions implemented as scripts
 (in Excel, these scripts are implemented in VBA).
 These extended functions can then be used in the formula language.
\end_layout

\begin_layout Standard
A three-layer general architecture like this, with an end-user language
 on top, a scripting language in the middle, and the core implementation
 of the application at the bottom, is a common pattern we identify in several
 successful examples of applications where end-user programming is the central
 form of interaction.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="6">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\emph on
End user
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
formulas
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
macro recorder
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
node editor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Unix shell
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
level editor
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\emph on
Domain dev
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
macros
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
textual macros
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
scripting
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
shell script
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
game scripting
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\emph on
Core app
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
spreadsheet
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
word processor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
3D app
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
C utilities
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
video game
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Three-layers"

\end_inset

Nardi's three types of programmers and three-layer architectures in end-user
 programmable systems
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In 
\begin_inset Quotes eld
\end_inset

A Small Matter of Programming
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Nardi1993"

\end_inset

, Bonnie Nardi reports on studies that identified three types of people
 who are engaged in programming at different levels: the 
\emph on
end-user
\emph default
, who may be a sophisticated user in their own domain but who does not particula
rly care about programming and just wants to use the computer as a tool
 to solve problems from their domain; the 
\emph on
domain developer
\emph default
 (called a 
\begin_inset Quotes eld
\end_inset

local developer
\begin_inset Quotes erd
\end_inset

 in 
\begin_inset CommandInset citation
LatexCommand citep
key "Nardi:1991:TLN:122825.122820"

\end_inset

, 
\begin_inset Quotes eld
\end_inset

translator
\begin_inset Quotes erd
\end_inset

 in 
\begin_inset CommandInset citation
LatexCommand citep
key "Mackay:1990:PSC:99332.99356"

\end_inset

, 
\begin_inset Quotes eld
\end_inset

tinkerer
\begin_inset Quotes erd
\end_inset

 in 
\begin_inset CommandInset citation
LatexCommand citep
key "MacLean:1990:USP:97243.97271"

\end_inset

), who started as an end-user but acquired an appreciation towards programming
 and is therefore more predisposed to dive into the possibilities offered
 by a programmable system; and finally, the professional, who had formal
 training in programming.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Three-layers"

\end_inset

 maps these kinds of users to examples of three-language architectures used
 by end-user-programmable applications.
\end_layout

\begin_layout Standard
The existence of different roles among a community of users continues to
 be observed 
\begin_inset CommandInset citation
LatexCommand citep
key "draxler2011managing"

\end_inset

, and the alignment between these three different user profiles and three
 architectural layers does not seem to be coincidental.
 We believe that this three-tier architecture is necessary in end-user programma
ble applications that feature programmability as a central feature in their
 design.
 The main user-facing language should be closer to the domain abstractions
 than a full-fledged general-purpose scripting language: while a language
 like Python is appropriate for scripting a 3D editor like Blender, a Python
 command line would never be appropriate as the editor's primary interface.
 The scripting language exists, thus, as a feature that provides support
 for when the user's goals outgrow the possibilities of the UI-level language.
\end_layout

\begin_layout Subsection
Scripting languages
\end_layout

\begin_layout Standard
Scripting languages complement UI-level languages in end-user programmable
 applications.
 They allow advanced users (or even programming professionals) to provide
 extensions to the UI-level language when needed.
 Common examples of such extensions are adding custom functions to a spreadsheet
's formula language, or designing richer game interactions than those available
 out-of-the-box in a game level editor.
\end_layout

\begin_layout Standard
This is, in a sense, an alternative look at the role of scripting.
 Ever since Ousterhout's seminal paper 
\begin_inset CommandInset citation
LatexCommand citep
key "Ousterhout:1998:SHP:619027.620930"

\end_inset

, scripting languages are primarily regarded in relation to the core application
s that sit below them: they are regarded as higher-level alternatives to
 system programming languages, and as 
\begin_inset Quotes eld
\end_inset

glue
\begin_inset Quotes erd
\end_inset

 languages that connect lower-level components.
 Here, we focus on higher-level programmability of applications.
 In this context, scripting exists to serve the needs of the end-user language
 that sits above it, providing unconstrained, Turing-complete extensibility
 to a UI-level language that remains focused on domain-specific elements.
 For example, while a scripting language for a 3D editor may deal in terms
 of typical programmer constructs such as records, lists and associative
 arrays, its end-user UI-level language should deal in terms of domain construct
s such as 3D objects, textures and lighting sources.
\end_layout

\begin_layout Standard
The evolution of scripting languages points in the direction we indicate
 here.
 When we look at the development history of successful scripting languages
 such as Python and Lua, we see that these languages started out with clear
 goals of being easy to program, but over the years their development focus
 tends to favor adding constructs for advanced programmers.
 Lua grew from having a single numeric type to having distinct floating-point
 and integer numbers with bitwise operators, and gained advanced features
 such as coroutines and lexically-scoped closures.
 Python gradually shifted its focus away from adding libraries with ready-made
 components and into improving core language constructs.
 In contrast, end-user programmable applications like LabVIEW and Max/MSP
 advertise the number of new library functions added on each new release.
\end_layout

\begin_layout Standard
This marks a culture shift in scripting languages.
 The forerunner of modern scripting languages, Tcl, was seen as inseparable
 from its UI library to the point that the language was often mistakenly
 called 
\begin_inset Quotes eld
\end_inset

Tcl/Tk
\begin_inset Quotes erd
\end_inset

.
 Nowadays, the Python community favors adding libraries through the PIP
 package manager rather than merging them into the core language
\begin_inset Foot
status open

\begin_layout Plain Layout
Python developer Kenneth Reitz quipped that the 
\begin_inset Quotes eld
\end_inset

standard library is where modules go to die
\begin_inset Quotes erd
\end_inset

, as standardizing libraries tends to slow down their evolution for the
 sake of backward compatibility 
\begin_inset CommandInset citation
LatexCommand citep
key "DeadBatteries"

\end_inset

.
\end_layout

\end_inset

.
 We see similar trends in all scripting languages, with their fledgling
 package managers: Perl and CPAN, Ruby and RubyGems, JavaScript and npm,
 Lua and LuaRocks.
\end_layout

\begin_layout Standard
Scripting languages today are seen less as a deliberately simplified tool
 for 
\begin_inset Quotes eld
\end_inset

non-programmers
\begin_inset Quotes erd
\end_inset

 and more as as a class of languages focused on rapid development, sharing
 some features such as dynamic type systems, automatic memory management
 and dynamic code loading.
 As these languages evolve and these features prove useful for programming
 in general, they are gaining ground in many fields beyond those originally
 identified with 
\begin_inset Quotes eld
\end_inset

scripting
\begin_inset Quotes erd
\end_inset

.
 Still, scripting—in the sense of embedding the power of a full programming
 language to provide advanced control of applications—remains an essential
 aspect of end-user programming.
\end_layout

\begin_layout Section
Dataflow programming
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Dataflow
\begin_inset Quotes erd
\end_inset

 in an umbrella term that refers to computation evaluation dictated by the
 flow of data, the relationship between inputs and outputs in the program,
 rather than explicit programmer-dictated flow of control.
 The term 
\begin_inset Quotes eld
\end_inset

dataflow language
\begin_inset Quotes erd
\end_inset

 has been used to refer to various families of languages over time.
 We review some of these languages here to get an outlook of what we mean
 by the term.
\end_layout

\begin_layout Standard
Dataflow programs correspond to directed graphs, where nodes represent operation
s on data, and arcs represent connections through which data tokens can
 be sent from node to node.
 Operations have inputs (incoming edges receiving data) and outputs (outgoing
 edges sending data).
 An operation executes when all its inputs receive data tokens.
 The operation computes its function, and then 
\begin_inset Quotes eld
\end_inset

fires
\begin_inset Quotes erd
\end_inset

 the result through one or more outputs, making data available to other
 nodes.
 The order of evaluation, thus, depends exclusively on the flow of data,
 hence the name.
 In contrast, control-flow
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
We use 
\begin_inset Quotes eld
\end_inset

dataflow
\begin_inset Quotes erd
\end_inset

 spelled without a hyphen as this is an established term in the literature
 to refer to a particular class of languages; 
\begin_inset Quotes eld
\end_inset

control-flow
\begin_inset Quotes erd
\end_inset

, on ther other hand, is hyphenated as it refers merely to the notion of
 a flow of control.
\end_layout

\end_inset

 oriented languages are those that feature explicit sequencing constructs
 written by the programmer: all imperative languages fall in this group.
 In a pure dataflow language, evaluation order is implicit and arbitrary,
 and there is full referential transparency 
\begin_inset CommandInset citation
LatexCommand citep
key "Dennis85Models"

\end_inset

.
 Purely functional languages certainly fit this description.
 What came to be known as the dataflow paradigm, however, is a particular
 style of representing these data relationships, in particular the focus
 on the flow of data, and how to represent it in the face of iteration or
 recursion.
 In any case, just like not all functional languages are pure, neither are
 all dataflow languages.
\end_layout

\begin_layout Subsection
A brief history of dataflow
\end_layout

\begin_layout Standard
Early history of dataflow languages is closely tied to that of dataflow
 computers.
 In the 1970s, dataflow hardware architectures, with large number of processing
 elements interconnected to form dataflow graphs, were considered as an
 alternative to the von Neumann model 
\begin_inset CommandInset citation
LatexCommand citep
key "Whiting:1994:HDL:612489.612574"

\end_inset

.
 Given that the dataflow model would be inherently parallel in its design,
 it was hoped that this would overcome the difficulties of writing concurrent
 software and the CPU-memory bottleneck in Von Neumann machines.
 Programming dataflow computers required new languages, as it was particuarly
 hard to map traditional imperative languages to these architectures efficiently.
 
\end_layout

\begin_layout Standard
The motivations of the many dataflow languages created over the years, both
 textual and graphical, varied widely.
 In 1973, Kosinski presented DFL 
\begin_inset CommandInset citation
LatexCommand citep
key "Kosinski:1973:DFL:390014.808289"

\end_inset

, a graphical language for operating systems programming, and he motivated
 the dataflow approach by requirements of paralellism and modularity.
 Lucid 
\begin_inset CommandInset citation
LatexCommand citep
key "Ashcroft:1977:LNL:359636.359715"

\end_inset

 is an early example of a textual dataflow language, with a stated goal
 of making a language amenable to proof reasoning that remained friendly
 to imperative programmers.
 Their approach was to make a functional-style language that included iteration
 constructs.
 Programs are written in single-assignment style; in iterations, variable
 updates are written as 
\family typewriter
\series bold
next
\series default
 
\emph on
var
\emph default
 = 
\emph on
exp
\family default
\emph default
, where occurrences of variable 
\family typewriter
\emph on
var
\family default
\emph default
 in expression 
\family typewriter
\emph on
exp
\family default
\emph default
 represent its value in in the previous iteration.
\end_layout

\begin_layout Standard
Since the 1990s, the focus of dataflow languages moved away from performance
 and paralellism and into software engineering territory, with a particular
 growth in the field of dataflow visual programming languages 
\begin_inset CommandInset citation
LatexCommand citep
key "Johnston:2004:ADP:1013208.1013209"

\end_inset

, of which the most prominent example in the industry is LabVIEW 
\begin_inset CommandInset citation
LatexCommand citep
key "labview"

\end_inset

, a commercial application for industrial automation first released in 1986
 and marketed to this day, where the graphical language is tightly integrated
 with the development and execution environment.
 More recently, research on dataflow shifted its focus once again towards
 parallelism 
\begin_inset CommandInset citation
LatexCommand citep
key "Lin2008Parameterized,Gupta:2011:DES:2155620.2155628,Gantel2011dataflowReconfigurable,Barkati:2013:SPA:2543581.2543591"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
nowadays: reactive systems? 
\begin_inset Quotes eld
\end_inset

flow
\begin_inset Quotes erd
\end_inset

 stuff (tensorflow, flow, google dataflow)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Static and dynamic dataflow models
\begin_inset CommandInset label
LatexCommand label
name "sub:Static-and-dynamic"

\end_inset


\end_layout

\begin_layout Standard
It is often desirable for dataflow programming models to allow the representatio
n of iteration, in which a subgraph executes multiple times.
 If we consider that the only rule for firing a node is that its all inputs
 have data ready for consumption, it is conceivable that the early part
 of a new iteration could begin executing before the previous iteration
 has finished to run, in a pipeline style of execution.
 Further, if the iterations of a loop have no data dependencies between
 them, it should be possible to run all iterations of a loop in parallel.
 These possibilities, however, complicate both the processing and memory
 models.
\end_layout

\begin_layout Standard
A simple restriction that causes a major simplification to the dataflow
 model is to add another rule for firing nodes: a node is fired only if
 all its input ports have data tokens ready for consumption and if its output
 ports have no data tokens pending for consumption by further nodes.
 This model is called the 
\emph on
static
\emph default
 dataflow model.
 In the static dataflow model, memory management is simple, as each arc
 in the graph represents one storage unit for a data token 
\begin_inset CommandInset citation
LatexCommand citep
key "Dennis85Models"

\end_inset

.
 Synchronous languages such as Lustre 
\begin_inset CommandInset citation
LatexCommand cite
key "Lustre"

\end_inset

 and Lucid 
\begin_inset CommandInset citation
LatexCommand cite
key "Ashcroft:1977:LNL:359636.359715"

\end_inset

 implement static dataflow models.
\end_layout

\begin_layout Standard
For exploiting the full possibilities of dataflow parallelism, 
\emph on
dynamic
\emph default
 models were devised.
 In common, they all lift the restriction that the output ports need to
 be empty for a node to execute.
 A straightforward interpretation of this model is that arcs now represents
 buffers with multiple data tokens between nodes.
 Management of memory and processing units becomes more complicated, as
 it becomes necessary to tag tokens with bookkeping data, for managing concurren
t flows of different iterations.
 Tagged-token models support parallel loops by associating to each input
 value a tag, indicating which iteration that value is a part of.
 A node 
\series bold

\begin_inset Formula $f$
\end_inset


\series default
 with input ports 
\begin_inset Formula $p_{1},p_{2}...p_{n}$
\end_inset

 will feature 
\begin_inset Formula $n$
\end_inset

 queues 
\begin_inset Formula $q_{1},q_{2}...q_{n}$
\end_inset

, containing tagged values of the form 
\begin_inset Formula $(v,i)$
\end_inset

, indicating a value 
\begin_inset Formula $v$
\end_inset

 for iteration 
\begin_inset Formula $i$
\end_inset

.
 The graph will fire 
\begin_inset Formula $f(v_{1},v_{2}...v_{n})$
\end_inset

 only when it is able to extract from the queues a complete set of tokens
 
\begin_inset Formula $\{(v_{x},i)\in q_{x}|1\le x\le n\}$
\end_inset

 with the same tag 
\begin_inset Formula $i$
\end_inset

.
\end_layout

\begin_layout Standard
There is a number of architectural challenges for implementing dynamic dataflow
 models efficiently: several models were proposed, and this continues to
 be an area of active research 
\begin_inset CommandInset citation
LatexCommand citep
key "kavi2015dataflow"

\end_inset

.
 The choice of dataflow execution model is not only an implementation issue.
 For one, it affects language design, as typical tagged-token models use
 explicit looping constructs, which mark points where loop iteration tags
 in tokens should be incremented or reset 
\begin_inset CommandInset citation
LatexCommand citep
key "Dennis85Models"

\end_inset

.
\end_layout

\begin_layout Subsection
Data-driven and demand-driven dataflow
\begin_inset CommandInset label
LatexCommand label
name "sub:Data-driven-and-demand-driven"

\end_inset


\end_layout

\begin_layout Standard
Another major design decision when choosing a dataflow model is whether
 to use data-driven or demand-driven evaluation.
 These modes of evaluation correspond to what in programming languages is
 conventionally called, respectively, eager (or strict) and lazy evaluation.
\end_layout

\begin_layout Standard
Data-driven evaluation maps to eager evaluation: the availability of input
 data triggers the evaluation of nodes that are connected to them, producing
 data for nodes connected further ahead in the graph.
\end_layout

\begin_layout Standard
Demand-driven evaluation maps to lazy evaluation: the request of an output
 causes a node connected to it to be triggered.
 If that node's input ports have data, the node will execute, producing
 the output.
 If inputs are not available, the nodes to which these inputs are connected
 are then triggered, cascading the triggering backwards until inputs are
 available.
 Once inputs are available, nodes are evaluated and their result values
 propagate forward via their output ports.
 This way, only the parts of the graph which produce output data execute.
\end_layout

\begin_layout Standard
These terms come from the field of computer architecture, when dataflow
 machines were proposed as alternatives to the von Neumann model.
 In 
\begin_inset CommandInset citation
LatexCommand citep
key "Treleaven:1982:DDC:356869.356873"

\end_inset

, Treleaven classified architectures as 
\begin_inset Quotes eld
\end_inset

data-driven
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

demand-driven
\begin_inset Quotes erd
\end_inset

, but also called data-driven architectures 
\begin_inset Quotes eld
\end_inset

data-flow computers
\begin_inset Quotes erd
\end_inset

 and demand-driven architectures 
\begin_inset Quotes eld
\end_inset

reduction computers
\begin_inset Quotes erd
\end_inset

.
 Nowadays, both models are considered styles of dataflow 
\begin_inset CommandInset citation
LatexCommand citep
key "Hils1991datavis,Avron1994"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
https://books.google.com.br/books?id=dS4b3i36qsEC&pg=PA505&lpg=PA505&dq=lucid+deman
d-driven+dataflow&source=bl&ots=bMTKoHR-RQ&sig=6rgUvPGf4ZbKWEesYnhyWEi4lHY&hl=en
&sa=X&redir_esc=y#v=onepage&q=lucid%20demand-driven%20dataflow&f=false
\end_layout

\begin_layout Plain Layout
* eazyflow?
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Uni and bi-directional flow
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
todo: reorganize this to match the title
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A field that is closely related to dataflow languages is that of constraint-base
d systems, but as we will see, these concepts are not equivalent and it
 is important to establish the distinction here.
 Constraints allow the specification of relationships between values—for
 example, one may specify the equation 
\family typewriter
9*C = 5*(F - 32)
\family default
 about variables 
\family typewriter
C
\family default
 and 
\family typewriter
F
\family default
 representing a temperature in Celsius and Fahrenheit, and if either 
\family typewriter
C
\family default
 or 
\family typewriter
F
\family default
 is updated to a new value, the other one is recomputed so that the equation
 of the constraint continues to hold.
 Constraint systems can be classified as one-way or multi-way: one-way constrain
ts are systems where each value is defined by one equation, so that constraints
 can be solved by propagation as performed by spreadsheet recalculation;
 multi-way constraints are those where any variable of an equation can trigger
 an update and where the constraints for a variable can be expressed via
 a system of equations 
\begin_inset CommandInset citation
LatexCommand citep
key "Sannella:1993:MVO:153493.153498"

\end_inset

.
\end_layout

\begin_layout Standard
One-way constraints are a restricted case of multi-way constraints; traditionall
y, dataflow systems can be seen as an example of one-way constraint systems
 
\begin_inset CommandInset citation
LatexCommand citep
key "Demetrescu:2014:RIP:2688877.2623200"

\end_inset

.
 For this reason, the term 
\begin_inset Quotes eld
\end_inset

constraint system
\begin_inset Quotes erd
\end_inset

 is more often understood to refer to systems based on multi-way constraints:
 in 
\begin_inset CommandInset citation
LatexCommand citep
key "Abelson:1996:SIC:547755"

\end_inset

, for example, it is stated that 
\begin_inset Quotes eld
\end_inset

nondirectionality of computation is the distinguishing feature of constraint-bas
ed systems
\begin_inset Quotes erd
\end_inset

.
 The power of a multi-way constraint system depends on the power of the
 solver used to satisfy its systems of equations.
 For example, Cassowary 
\begin_inset CommandInset citation
LatexCommand citep
key "Badros:2001:CLA:504704.504705"

\end_inset

 is a widely used constraint solver supporting linear equations and inequalities.
 Since we want to focus on core language semantics rather than solver algorithms
, our work will restrict itself to traditional dataflow languages, or, in
 other words, those with one-way constraints only.
 From a dataflow point of view, a constraint update is a modification of
 the structure of the dataflow graph.
\end_layout

\begin_layout Chapter
Design alternatives for dataflow UI-level languages 
\begin_inset CommandInset label
LatexCommand label
name "chap:Dataflow-UI-langs"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
chaptermark{Design alternatives}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Research on the dataflow paradigm has seen a decrease in activity since
 the early 1990s.
 The revolution of visual languages inspired by GUI systems that was expected
 by some never came to pass, as object-oriented programming systems remained
 textual.
 Massively-parallel dataflow hardware architectures proved difficult to
 implement efficiently and are now historical artifacts—modern GPUs obtain
 massive parallelism via vector processing based on imperative machine code.
\end_layout

\begin_layout Standard
Practical use of dataflow languages, however, has not gone away, and it
 is arguably more widespread than ever.
 Dataflow is the paradigm of choice in a large number of programmable end-user
 applications.
 Dataflow-based UIs, especially visual ones based on box-line graph representati
ons, make it easy for the user to inspect intermediate results and therefore
 understand what is going on in the application 
\begin_inset CommandInset citation
LatexCommand citep
key "Hils1992DFVPLSurvey"

\end_inset

, making the relationships between data more concrete to the user.
\end_layout

\begin_layout Standard
So, dataflow languages continue to be created and used successfully, but
 mostly away from the sphere of research.
 A closer look at this class of languages, especially from the perspective
 of end-user programming, is long overdue.
 In this chapter, we begin to explore the design space of dataflow languages
 by presenting a series of design alternatives that come up in their constructio
n.
\end_layout

\begin_layout Section
Hils's classification of design alternatives
\begin_inset CommandInset label
LatexCommand label
name "sec:Hils's-classification"

\end_inset


\end_layout

\begin_layout Standard
In 
\begin_inset CommandInset citation
LatexCommand citep
key "Hils1992DFVPLSurvey"

\end_inset

, Daniel Hils presented an extensive survey of dataflow visual languages
 (both domain-specific and general-purpose) and produced a list of design
 alternatives through which those languages can be classified in various
 axes.
 Here, we reuse and expand upon this list while shifting our focus from
 dataflow visual languages to what we call dataflow UI-level languages.
 We felt it was necessary to coin this term and to make a distinction from
 the more common term 
\begin_inset Quotes eld
\end_inset

dataflow visual languages
\begin_inset Quotes erd
\end_inset

 for two reasons.
 
\end_layout

\begin_layout Standard
First, we include 
\begin_inset Quotes eld
\end_inset

UI-level
\begin_inset Quotes erd
\end_inset

 because we want to focus only on dataflow languages which take 
\emph on
center
\emph default
 stage as the 
\emph on
application interface
\emph default
; in other words, those languages that are central to the UI, and not an
 optional component.
 Being languages that are integrated into an application of a specific domain,
 this classification excludes general-purpose programming languages.
\end_layout

\begin_layout Standard
Second, we avoid the term 
\begin_inset Quotes eld
\end_inset

visual
\begin_inset Quotes erd
\end_inset

 because we want to cover the entire spectrum of languages that fall within
 our focus, without having to worry whether a language is visual or not.
 Notably missing from Hils's work is the most widely used application-specific
 dataflow language—the spreadsheet formula language.
 Granted, the relationship between data cells in a spreadsheet is presented
 symbolically rather than visually, but it is remarkable how, apart from
 this fact, spreadsheets would fit every other aspect of that study.
 Our work is concerned with semantics and not syntax; the visual presentation
 of a language is a syntactic feature.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Design dimension
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Design alternatives
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Box-line representation
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no; yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Iteration
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no; limited; yes (cycles); yes (construct)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Subprogram abstraction
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no; yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Selector/distributor
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no; yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Flow of data
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
uni-directional; bi-directional
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sequence construct
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no; yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Type checking
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no; yes (limited); yes (all types)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Higher-order functions
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no; yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Execution mode
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
data-driven; demand-driven
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Liveness level
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 (informative); 2 (significant); 3 (responsive); 4 (live)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Hils-design-options"

\end_inset

Hils's design dimensions for dataflow visual languages 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Apart from this distinction on the criteria for selecting languages, the
 list of design alternatives can be directly reused in our work.
 Hils's original list of design alternatives, summarized in Table, 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Hils-design-options"

\end_inset

, can be described as follows:
\end_layout

\begin_layout Itemize

\emph on
box-line representation
\emph default
: whether the language is presented as a visual graph depicting nodes as
 boxes and edges as connected by lines or as some other visual approach,
 such as hierarchical frames (this is the only syntactic aspect discussed,
 but we retain it in the table for completeness);
\end_layout

\begin_layout Itemize

\emph on
iteration
\emph default
: whether the language supports iteration, either through graph cycles or
 explicit constructs for iterated execution of subgraphs (here we expand
 on the original yes-no classification to consider the kind of iteration
 facility and also if some limited form of iteration is available in languages
 which do not allow iterating arbitrary subgraphs);
\end_layout

\begin_layout Itemize

\emph on
subprogram abstraction
\emph default
: whether the language supports abstracting subgraphs as reusable subprograms
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
In Hils's original article this item was called 
\begin_inset Quotes eld
\end_inset

procedural abstraction
\begin_inset Quotes erd
\end_inset

; we changed the term to avoid confusion.
\end_layout

\end_inset

;
\end_layout

\begin_layout Itemize

\emph on
selector and/or distributor
\emph default
: whether the language includes classic dataflow constructs for directing
 the routing of data through a control input.
 A selector is a function 
\begin_inset Formula $\sigma(v_{1},...,v_{n},k)=v_{k}$
\end_inset

, i.e.
 the 
\begin_inset Formula $k$
\end_inset

-th input is forwarded to the node's only output; a distributor is a function
 
\begin_inset Formula $\pi(k,v)$
\end_inset

, where value 
\begin_inset Formula $v$
\end_inset

 is fired to the node's 
\begin_inset Formula $k$
\end_inset

-th output;
\end_layout

\begin_layout Itemize

\emph on
sequential execution construct
\emph default
: whether the language breaks away from pure dataflow by providing an explicit
 construct for specifying the order of evaluation of actions, independently
 from data dependencies;
\end_layout

\begin_layout Itemize

\emph on
type checking
\emph default
: in Hils's classification, this entry discussed whether the arcs in the
 dataflow graph are typed—in other words, whether the graph is statically
 typed.
 Statically-typed graphs provide checking when constructing the graph, disallowi
ng incorrect connections.
 A dynamically-typed graph may still have typed tokens, resulting in type
 errors at runtime only.
 Note that this is different from static and dynamic dataflow models (as
 discussed in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Static-and-dynamic"

\end_inset

);
\end_layout

\begin_layout Itemize

\emph on
higher-order functions
\emph default
: whether the language supports nodes that take functions as arguments.
 None of the languages studied in this work support this, and in 
\begin_inset CommandInset citation
LatexCommand citep
key "Hils1992DFVPLSurvey"

\end_inset

 this feature was only present in general-purpose languages and in Hils's
 own scientific visualization language DataVis 
\begin_inset CommandInset citation
LatexCommand citep
key "Hils1991datavis"

\end_inset

;
\end_layout

\begin_layout Itemize

\emph on
execution mode
\emph default
: whether the language is data-driven or demand-driven, as discussed in
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Data-driven-and-demand-driven"

\end_inset

;
\end_layout

\begin_layout Itemize

\emph on
liveness level
\emph default
: a classification developed by Tanimoto 
\begin_inset CommandInset citation
LatexCommand citep
key "tanimoto1990liveness"

\end_inset

 with a four-level scale of liveness for visual programming tools.
 In level 1, 
\begin_inset Quotes eld
\end_inset

informative
\begin_inset Quotes erd
\end_inset

, the visual representation is a non-executable auxiliary representation
 (like flowchart documentation for textual programs).
 In level 2, 
\begin_inset Quotes eld
\end_inset

informative and significant
\begin_inset Quotes erd
\end_inset

, the visual representation is the executable program, but program editing
 and execution are separate activities.
 In level 3, 
\begin_inset Quotes eld
\end_inset

informative, significant and responsive
\begin_inset Quotes erd
\end_inset

, editing the visual representation triggers updates to the evaluation of
 the program; there are no separate edit and execution modes.
 In level 4, 
\begin_inset Quotes eld
\end_inset

informative, significant, responsive and live
\begin_inset Quotes erd
\end_inset

, the system updates continuously, updating the visual representation in
 response to data updates, and not only to user inputs.
 The liveness level affects the evaluation rules of the language, since
 levels 3 and 4 allow changing the dataflow graph dynamically.
\end_layout

\begin_layout Section
An extension to Hils's classification 
\begin_inset CommandInset label
LatexCommand label
name "sec:An-extension-to-Hils"

\end_inset


\end_layout

\begin_layout Standard
In addition to the axes of comparison proposed by Hils, we identified a
 number of additional criteria to compare these languages.
 This new list of design alternatives for dataflow languages both informed
 and was informed by the study of existing end-user applications and their
 languages that we will present in the following chapters.
 We hereby present an extension to the classification proposed by Hils,
 summarized in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Additional-design-dimensions"

\end_inset

, which we believe helps comparing end-user applications of different domains
 and shines a light on the semantic aspects of their underlying programming
 languages.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Design dimension
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Design alternatives
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Dataflow model
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
static; dynamic
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N-to-1 inputs
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no; yes (auto-merge); yes (queueing)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Time-dependent firing
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no; yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Rate-based evaluation
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no; synchronous; cyclo-static; quasi-static; dynamic
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Separate program and UI
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no; yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Indirect connections
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no; yes (static); yes (runtime-evaluated)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Textual sub-language
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no; yes (functional); yes (imperative)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Additional-design-dimensions"

\end_inset

Additional design dimensions for dataflow end-user languages
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Dataflow model
\end_layout

\begin_layout Standard
Apart from the classification between data-driven and domain-driven dataflow,
 perhaps the most important distinction in terms of semantics for a dataflow
 language is whether its dataflow model is static or dynamic, according
 to definitions presented in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Static-and-dynamic"

\end_inset

.
\end_layout

\begin_layout Standard
The choice between static and dynamic dataflow models embodies typical computing
 trade-offs.
 The static model, with a single data token present per edge, is simpler,
 and thus easier to implement and also keeps memory use under control.
 The dynamic model, while more complex, may produce a more efficient execution,
 maximizing the opportunities for exploiting parallelism.
\end_layout

\begin_layout Standard
The question of which one is easier to understand, especially in the context
 of end-user programming, is not at all obvious.
 On the one hand, the static model is conceptually simpler and program execution
 may be easier to introspect.
 On the other hand, to the user's point of view the restrictions may seem
 arbitrary: in a number of situations the user may justifiably want to specify
 cycles (iterative financial calculations, audio-delay feedback, etc.); the
 dynamic model may present a more free-form experience for the user.
 Still, misusing cycles is an easy way for the user to make their program
 go haywire.
\end_layout

\begin_layout Subsection
N-to-1 inputs
\end_layout

\begin_layout Standard
A practical question that is closely related to the dataflow model is whether
 the language allows what we will call 
\begin_inset Quotes eld
\end_inset

N-to-1 inputs
\begin_inset Quotes erd
\end_inset

 into a node.
 A node in a dataflow graph represents a unit of functional execution and
 may have multiple inputs, akin to a function 
\begin_inset Formula $f(a,b,c)$
\end_inset

 with multiple input arguments.
 The question here is whether the language allows multiple edges connecting
 to a 
\emph on
single
\emph default
 input port in a node—in our analogy, that would mean having multiple incoming
 values for argument 
\begin_inset Formula $a$
\end_inset

 available at the time of executing 
\begin_inset Formula $f$
\end_inset

.
\end_layout

\begin_layout Standard
Traditional static dataflow models usually forbid N-to-1 inputs.
 When two input signals are to be entered to a single input port, an explicit
 
\begin_inset Quotes eld
\end_inset

merge
\begin_inset Quotes erd
\end_inset

 node needs to be added, which applies some logic to decide which of the
 inputs is forwarded to the node.
 
\end_layout

\begin_layout Standard
When N-to-1 inputs are allowed, the language needs a policy for dealing
 with them.
 Languages employing a dynamic model featuring input queues may naturally
 allow data from different sources into a single queue.
 In static dataflow models, N-to-1 inputs may be allowed by making the merge
 operation implicit.
\end_layout

\begin_layout Standard
It is interesting to note that depending on the representation of the dataflow
 graph, N-to-1 inputs can be not only semantically disallowed, but be made
 impossible to express syntactically.
 In a typical textual language, one simply cannot pass two different variables
 at once to the first argument of a function.
 That is the case, for example, in spreadsheet formula languages.
\end_layout

\begin_layout Subsection
Time and rate-based evaluation
\end_layout

\begin_layout Standard
An aspect of program evaluation that is not much a design decision as much
 as it is a domain-dependent requirement is the need to take time into account.
 If a programmable application needs to process events which happen in a
 time-dependent manner or according to fixed rates, that needs to be reflected
 in its language.
 Still, when this necessity arises there is still a design space to be explored
 on how to handle it.
\end_layout

\begin_layout Standard
There are two ways to consider the issue of time.
 One is that of rate-based execution, which refers to the need of consuming
 or producing data at a certain frequency.
 The other is that of time-dependent nodes, that is, nodes that behave different
ly depending on the time when they were fired
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Wipliez2010"

\end_inset

.
\end_layout

\begin_layout Standard
The handling of rate-dependent data often brings performance concerns.
 Outside of the world of end-user programming, the signal-processing community
 has been using dataflow models for decades for handling data streams efficientl
y, while taming the complexity of dynamic dataflow models.
 
\emph on
Static dataflow
\emph default
 models have not only bounded memory, but their scheduling can also be determine
d ahead-of-time, allowing for efficient compilation.
 However, handling one token at a time is a severe limitation for stream
 processing.
 
\emph on
Synchronous dataflow
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Lee1987synchdataflow"

\end_inset

 is an extension of the model in which the number of data samples produced
 or consumed by each node on each invocation is specified a priori.
 It still allows compile-time memory and scheduling analysis.
 
\emph on
Cyclo-static dataflow
\emph default

\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Bilsen1995cyclo"

\end_inset

 is another extension which extends the expressiveness of the synchronous
 model while retaining its analysis properties.
 In it, the consumption and production rates for a node can vary over time,
 respecting a predetermined cycle.
 A number of other models have also been proposed to further extend the
 model of computation: 
\emph on
quasi-static
\emph default
 models such as boolean-controlled dataflow
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Buck:1993:SDD:921086"

\end_inset

 and parameterized dataflow
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Bhattacharya:2001:PDM:2197975.2202339"

\end_inset

 attempt to restrict dynamic scheduling to data-dependent nodes while statically
 scheduling the rest of the graph, with further enhancements continuing
 to be an area of research
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Falk:2013:RQS:2442116.2442124,Schwarzer:2015:TCD:2764967.2764972"

\end_inset

.
\end_layout

\begin_layout Standard
Time-dependency is closely related to rate-dependency, since predictable
 rates at a known clock speed results in predictable times, but rate-based
 evaluation may also be motivated by concerns other than time, such as memory
 efficiency as buffer sizes can be are minimized with optimized schedules.
 Time-dependent execution refers to all sorts of dependency on time, such
 as nodes that return the current time, delay nodes that pause for a given
 number of microseconds, and so on.
 Supporting this kind of nodes has its own set of concerns as it can bring
 a level of indeterminacy to the evaluation, affecting scheduling.
\end_layout

\begin_layout Standard
In the context of end-user programming, an application with rate-dependent
 data processing may combine rate-based and non-rate-based events (e.g.
 handling audio streams and button clicks).
 The interaction between these two worlds in the evaluation engine of the
 language also needs to be taken into account.
\end_layout

\begin_layout Subsection
Separate programming and use views
\end_layout

\begin_layout Standard
Another design decision that is worth observing in an end-user programmable
 application is whether it presents separate interface views for editing
 the dataflow program and for using the resulting user-written program,
 or if use of the program happens in the same interface where it is edited.
 By 
\begin_inset Quotes eld
\end_inset

separate interface views
\begin_inset Quotes erd
\end_inset

 we mean here completely distinct presentations: for example, one 
\begin_inset Quotes eld
\end_inset

edit
\begin_inset Quotes erd
\end_inset

 view presenting a box-line diagram as the user constructs their program
 and a 
\begin_inset Quotes eld
\end_inset

use
\begin_inset Quotes erd
\end_inset

 view presenting a form when they use it.
\end_layout

\begin_layout Standard
Note that this is different from the question having separate 
\begin_inset Quotes eld
\end_inset

edit
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

use
\begin_inset Quotes erd
\end_inset

 modes in the first place, which is the distinction between Tanimoto's liveness
 levels 2 and 3 
\begin_inset CommandInset citation
LatexCommand citep
key "tanimoto1990liveness"

\end_inset

.
 These design aspects are orthogonal: an application may present separate
 
\begin_inset Quotes eld
\end_inset

edit
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

use
\begin_inset Quotes erd
\end_inset

 modes within a single UI paradigm, characterizing liveness level 2; or
 it could feature distinct UIs for use and editing and yet allow those to
 be used simultaneously and in a responsive, non-modal, manner matching
 liveness level 3 or 4.
\end_layout

\begin_layout Standard
While strictly speaking the existence of separate views for development
 and use is a matter of presentation, and hence with immediate effects on
 syntax, we claim that this design decision is most closely related to a
 language's pragmatics: having the 
\begin_inset Quotes eld
\end_inset

source program
\begin_inset Quotes erd
\end_inset

 always visible or not is a clear indicator of the language's intended mode
 of use.
 A language which conflates the use and programming interfaces clearly intends
 the user and programmer to be one and the same, while a language with separate
 interfaces for these two scenarios may also steer people towards different
 roles.
 Most important to our concerns, here, is whether this design choice for
 the application affects the overall design of its programming language.
\end_layout

\begin_layout Standard
It is also important to note that having separate UIs for creating the user-deve
loped program and using it doesn't mean that the language is at a lower
 layer according to the architecture discussed in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:three-layer"

\end_inset

.
 The language continues to be UI-level as long as the main interface for
 producing documents in the application consists of the environment for
 interacting with the language.
 This does not change if once the user is done composing the document (that
 is, writing the program), they switch to another UI mode for using it.
\end_layout

\begin_layout Subsection
Indirect connections
\begin_inset CommandInset label
LatexCommand label
name "sub:Indirect-connections"

\end_inset


\end_layout

\begin_layout Standard
Dataflow programs are constructed as graphs, and applications using this
 model need to employ some representation to depict nodes and their connections.
 The explicitness of relationships between units of computations is arguably
 a big part of the appeal of dataflow for end-user programming.
 However, as programs grow in size, graph representations can grow unwieldy.
 Scalability in visual representations is a concern, embodied in the folk
 aphorism known as the 
\begin_inset Quotes eld
\end_inset

Deutsch limit
\begin_inset Quotes erd
\end_inset

, which states that visual languages cannot have effectively more than 50
 visual primitives on screen at the same time 
\begin_inset CommandInset citation
LatexCommand citep
key "complangvisual"

\end_inset

.
 A way around this issue is to introduce indirect connections.
 This presents a trade-off, however: while it reduces visual clutter, it
 does away with the aforementioned explicitness of relationships.
 
\end_layout

\begin_layout Standard
This is not only a matter of representation, and this becomes clearer when
 we consider the most popular example of indirect connection in textual
 languages: a pointer.
 Indirect connections whose targets are determined at runtime, such as pointers
 and references, increase the expressive power of the language.
 This can also have far-reaching impacts to its semantics.
 For one, node scheduling can no longer be performed statically.
 In opposition, if the target of an indirect connection is constant, this
 indirect connection is not unlike a connector in old flowcharts, used to
 transfer flow from one page to the next.
\end_layout

\begin_layout Subsection
Textual sub-language
\end_layout

\begin_layout Standard
The final dimension of design we enumerated is the presence or absence of
 a textual sub-language included within the UI-level language presented
 to the user.
\end_layout

\begin_layout Standard
The presence of textual sub-languages is a common pattern, even in visual
 languages.
 A typical use for them is representing mathematical expressions, since
 textual syntax based on mathematics such as 
\family typewriter
a - b + 5
\family default
 is natural and even some computer conventions such as 
\family typewriter
*
\family default
 and 
\family typewriter
/
\family default
 for multiplication and division have become broadly understood.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
One might argue that even in typical programming languages, the sub-grammar
 of mathematical expressions (including relational and logical operators)
 is an embedded domain-specific language of its own, as it usually contains
 a number of syntactic rules that do not apply anywhere else in the language,
 such as infix operators and precedence rules, and that are often similar
 even in languages which otherwise vary widely.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We are also interested in the paradigm of this textual sub-language, as
 it is indicative of the level of integration with the dataflow language
 as a whole.
 A functional sub-language is a natural match to the host dataflow language,
 representing solely a syntactic shortcut.
 If the textual sub-language includes imperative features, however, this
 necessarily means that it goes beyond dataflow and extends the core language's
 semantics.
\end_layout

\begin_layout Section
Non-dataflow UI-level languages
\end_layout

\begin_layout Standard
To make the boundaries of our scope clearer, it is worth dedicating a few
 words to UI-level languages that fall outside of the dataflow model.
\end_layout

\begin_layout Standard
Since end-user applications tend to be in general document-centric, with
 the user interface dominated by the 
\begin_inset Quotes eld
\end_inset

current document
\begin_inset Quotes erd
\end_inset

 and the interaction focusing on manipulating this document, it is natural
 that data-oriented approaches become appealing choices when one wants to
 enable end-user programming.
 However, we do not claim that dataflow languages are the best model of
 programmable interaction for all kinds of end-user applications.
\end_layout

\begin_layout Standard
For example, applications employing a storytelling paradigm 
\begin_inset CommandInset citation
LatexCommand cite
key "Leshed:2008:CAS:1357054.1357323,Monteiro:2013:GBF:2577101.2577124"

\end_inset

 benefit from a control-oriented model.
 In these scenarios, the fundamental building block for the user's programming
 experience is the 
\emph on
sequencing 
\emph default
construct: 
\begin_inset Quotes eld
\end_inset

this happens, then that happens
\begin_inset Quotes erd
\end_inset

.
 Sequencing is notably absent in the pure dataflow model.
 However, as we will see in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:LabVIEW"

\end_inset

, a dataflow language may include it to simplify operations involving timing.
\end_layout

\begin_layout Standard
It is possible to combine data and control flow in graphs.
 That is the case of Blueprints
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://docs.unrealengine.com/latest/INT/Engine/Blueprints/
\end_layout

\end_inset


\end_layout

\end_inset

, the graphical language used for gameplay scripting in the Unreal game
 engine.
 There are different kinds of edges in the graph, representing either data
 connections in dataflow style, or control-flow sequencing.
 Typical Blueprints programs, however, are of an imperative nature, and
 the resulting graph resembles a traditional flowchart.
 This kind of language, therefore, falls beyond our intended scope in the
 discussion of dataflow semantics.
\end_layout

\begin_layout Section
Case studies
\end_layout

\begin_layout Standard
In the following chapters, we will present in-depth case studies analyzing
 the semantics of three end-user programmable applications:
\end_layout

\begin_layout Itemize
Pure Data, a multimedia application focused on audio synthesis widely used
 by the computer music community;
\end_layout

\begin_layout Itemize
the spreadsheet formula language, as used in Excel, LibreOffice and Google
 Sheets;
\end_layout

\begin_layout Itemize
LabVIEW, an engineering application focused on data acquisition.
\end_layout

\begin_layout Standard
Those languages were chosen because of their relevancy, their distinct domains,
 and because they cover different points of the language design space in
 many aspects.
 We modelled their semantics by implementing definitional interpreters for
 them in Haskell, written in the style of structural operational semantics.
 Each interpreter is written as a set of evaluation functions, one for each
 language construct.
 As a whole, this set serves as a specification of the language being interprete
d.
 These functions take as inputs the current state of the execution environment
 and a language construct to be evaluated, and return the new state of the
 environment after evaluation of the construct.
\end_layout

\begin_layout Standard
The interpreters do not intend to be a complete specification of each language,
 but aim to capture the notable features of their semantics.
 We will discuss the languages in terms of the various design dimensions
 presented in this chapter.
 We will see to which extent these languages are purely declarative, how
 time affects the flow graph, the semantics of iteration constructs, their
 support for abstraction, and so on.
 In these studies, we identify what are the common patterns that are present,
 assessing to which extent those languages are 
\begin_inset Quotes eld
\end_inset

variations on a theme
\begin_inset Quotes erd
\end_inset

.
 We also pinpoint aspects where their ad hoc designs show.
\end_layout

\begin_layout Standard
The underlying goal is to understand what is the required functionality
 expected by applications for dataflow-based interfaces and how different
 languages solve similar problems.
 Also, having these interpreters side-by-side allows us to reason on the
 designs of those languages under similar terms.
\end_layout

\begin_layout Section
Discussion: On the use of definitional interpreters
\end_layout

\begin_layout Standard
Providing the definition of a language under discussion through the use
 of a definitional interpreter written in another language is a classic
 technique for describing semantics.
 In his classic 1972 paper, Reynolds 
\begin_inset CommandInset citation
LatexCommand citep
key "Reynolds:1972:DIH:800194.805852"

\end_inset

 describes the process of writing definitional interpreters, introducing
 the idea of defunctionalization and an early description of continuations.
 Both techniques were put to use in our interpreters.
\end_layout

\begin_layout Standard
Writing an interpreter for language, at first glance, seems like a way to
 unavoidably consider its entire semantics, since all constructs need to
 be describe in the precise language of computer code.
 However, as observed by Reynolds, the primary concern when writing a definition
al interpreter is being aware of which aspects of the language used to implement
 the interpreter (which Reynolds calls the 
\emph on
defining
\emph default
 language) leak into the semantics of the language to be interpreted (called
 the 
\emph on
defined
\emph default
 language).
 Using a construct of the defining language to implement the same construct
 in the defined language gives us a working implementation, but fails to
 describe what the semantics of the construct are.
\end_layout

\begin_layout Standard
In our interpreters, we made conscious decisions of which semantic aspects
 to leak and which not.
 Aspects which are not related to the dataflow evaluation logic are orthogonal
 to our discussion and not of particular interest, so were simply reused
 from our defining language Haskell: the addition of numbers, for example,
 is simply the addition as in Haskell, with the same overflow rules, etc.
 Aspects which are crucial to the dataflow logic were carefully separated:
 Haskell's lazy evaluation semantics do not leak into our defined languages
 (interpreters are defunctionalized, so both eager and lazy evaluation are
 explicitly implemented).
 We also avoided the more sophisticated features of Haskell such as monads
 and type classes, using the language as much as possible as a form of executabl
e 
\begin_inset Formula $\lambda$
\end_inset

-calculus (albeit one with a considerable amount of notational convenience).
 We hope that this will also prove beneficial for the reader unfamiliar
 with Haskell.
 At the same time, we consider a description written in a programming language
 to be more in line with the interdisciplinary nature of this work, as opposed
 to one written in the notation of operational semantics used by the programming
 language theory community.
\end_layout

\begin_layout Standard
It is important to stress here that a definitional interpreter is not written
 as a 
\begin_inset Quotes eld
\end_inset

prototype
\begin_inset Quotes erd
\end_inset

 interpreter.
 A prototype is typically a concise implementation of a subset of a program,
 written to give an idea of how the final product would work.
 Our concern in a definitional interpreter is with the precise specification
 of the defined language, and while we are implementing subsets of languages,
 we sacrifice concision whenever precision is important.
 The end result is quite different from a typical prototype.
 In particular, no care is given to performance: time, for example, is implement
ed by simulating the clock and incrementing it manually, resulting in a
 deterministic and precise description of events.
\end_layout

\begin_layout Standard
Finally, using an executable interpreter provides us with an easy way to
 test our implementation (and hence our definition) with larger, somewhat
 more practical examples.
\end_layout

\begin_layout Chapter
Case study: Pure Data
\begin_inset CommandInset label
LatexCommand label
name "chap:Pure-Data"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Plain Layout
descrever PD no início
\end_layout

\end_inset

Pure Data 
\begin_inset CommandInset citation
LatexCommand cite
key "PuckettePd"

\end_inset

 (also known as Pd) is a graphical language originally designed for music
 and later expanded for multimedia in general via extension packages.
 It is widely used in the computer music community 
\begin_inset CommandInset citation
LatexCommand citep
key "Burlet:2015:ESE:2820518.2820554"

\end_inset

, and is the free software successor of the successful commercial product
 Max/MSP
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://cycling74.com/products/max/
\end_layout

\end_inset


\end_layout

\end_inset

, created by the same author.
\end_layout

\begin_layout Section
Overview of the language
\end_layout

\begin_layout Standard
In this section, we give a presentation of the application, which doubles
 as an overview of its UI-level language.
 When a user opens Pure Data, they are greeted with a main window which
 contains the main menu and a blank log panel.
 The user's first step is to create a new file or open an existing one,
 which then opens a canvas window where the dataflow graph representing
 audio synthesis operations is edited and used.
\end_layout

\begin_layout Subsection
Nodes and values
\end_layout

\begin_layout Standard
In Pure Data, a program, called a 
\emph on
patch
\emph default
 in Pd jargon
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
In this section, terms in Pd jargon are presented in italics.
\end_layout

\end_inset

, is represented as a graph of nodes (operations) and edges (the flow of
 data between them).
 The user creates nodes of different kinds in a canvas an 
\end_layout

\begin_layout Standard
Data flowing between nodes may be either discrete messages (numbers, strings,
 or lists of these base types) or audio data.
 Nodes in Pure Data have 
\emph on
creation arguments
\emph default
, input ports (
\emph on
inlets
\emph default
) and output ports (
\emph on
outlets
\emph default
).
 The creation arguments are the initial contents of nodes, given by the
 programmer via a simple textual language.
 A node is of one these types:
\end_layout

\begin_layout Itemize

\emph on
atom box
\emph default
 - represents a value which can be edited by the user while in 
\emph on
run mode
\emph default
; editing the value (typing a new number or via the mouse scroll wheel)
 sends the updated value through its output port;
\end_layout

\begin_layout Itemize

\emph on
message box
\emph default
 - can be clicked by the user while in run mode, producing one or more messages;
\end_layout

\begin_layout Itemize

\emph on
graphical objects
\emph default
 - receive data and represent it visually, for example, as a plot;
\end_layout

\begin_layout Itemize
plain 
\emph on
objects
\emph default
 - represent Pd functions.
 There are two kinds of Pd functions: those that operate on discrete messages
 only, and those that operate on audio streams (denoted with a 
\begin_inset Quotes eld
\end_inset


\family typewriter
~
\family default

\begin_inset Quotes erd
\end_inset

 suffix in their names); accordingly, inlets and outlets are also identified
 as handling messages, audio or both.
 An object implementing an audio-processing function may have both message
 and audio inlets and outlets.
 A non-audio object may only send and receive messages.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename puredata_first_example.png
	scale 80

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:puredata"

\end_inset

A patch demonstrating the oscillator node 
\family typewriter
osc~
\family default
, based on an example from the Pure Data documentation.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:puredata"

\end_inset

 gives an illustrative example of a Pure Data patch.
 Thin lines are message connections, thicker lines are audio connections;
 their types are determined by their outlets.
 Boxes with a slanted top-right corner are atom boxes, editable in 
\begin_inset Quotes eld
\end_inset

run mode
\begin_inset Quotes erd
\end_inset

; boxes with a recessed right side are clickable message boxes.
\end_layout

\begin_layout Standard
This program produces a 880Hz sine wave (via the the [
\family typewriter
osc~
\family default
] object), which has its amplitude multiplied ([
\family typewriter
*~
\family default
]) according to a linear function ([
\family typewriter
line~
\family default
]) prior to be sent to the DSP
\begin_inset Foot
status open

\begin_layout Plain Layout
Digital Signal Processing
\end_layout

\end_inset

 output ([
\family typewriter
dac~
\family default
], as in 
\begin_inset Quotes eld
\end_inset

Digital-to-Analog Converter
\begin_inset Quotes erd
\end_inset

).
 The sine wave is also sampled at a rate of 500Hz ([
\family typewriter
metro 500
\family default
]) into a visual representation ([
\family typewriter
tabwrite~ view
\family default
]).
 The user may interact with the program by setting a new frequency to the
 oscillator (typing in new values in the atom box that initially contains
 
\begin_inset Quotes eld
\end_inset


\family typewriter
880
\family default

\begin_inset Quotes erd
\end_inset

), by clicking the message boxes that reconfigure the linear function ([
\family typewriter
0 100
\family default
], which will configure [
\family typewriter
line~
\family default
] to produce a slope from its current value to 0 over the course of 100ms,
 or 
\begin_inset Quotes eld
\end_inset


\family typewriter
0.1 1000
\family default

\begin_inset Quotes erd
\end_inset

, which will cause the value to slide to 0.1 over 1s) or by toggling the
 update of the graph by sending the value [
\family typewriter
0
\family default
] or [
\family typewriter
1
\family default
] to [
\family typewriter
metro 500
\family default
], done here via an indirect connection for demonstration purposes, sending
 the value through a receiver object declared as [
\family typewriter
receive toggle
\family default
].
 We will expand on these concepts below.
\end_layout

\begin_layout Subsection
Graph evaluation
\end_layout

\begin_layout Standard
Pure Data has two modes of execution, an 
\emph on
edit mode
\emph default
 in which the graph structure can be edited, and a 
\emph on
run mode
\emph default
 in which input values can be produced by interacting with the graph.
 The DSP engine can be toggled on or off independently of the mode of execution.
 Most importantly, the dataflow program is running at all times: the user
 can create nodes in the graph, switch to run mode, trigger a loop that
 produces audio waves, return to edit mode and modify the graph while the
 loop is still running.
\end_layout

\begin_layout Standard
Execution in Pure Data is synchronous.
 The tree of DSP nodes is processed periodically, updating their buffers
 and propagating audio data.
 A complete propagation of audio is called a 
\emph on
DSP tick
\emph default
, during which only audio nodes are processed.
 When an input or timing event happens, the entire cascade of messages produced
 is processed in sequence, before the next DSP tick 
\begin_inset CommandInset citation
LatexCommand cite
key "PuckettePd"

\end_inset

.
 This means that excessive processing of messages may produce noticeable
 audio drop-outs, but the audio buffer with a user-specified size mitigates
 this.
 
\end_layout

\begin_layout Standard
It is possible to wire nodes in the Pd interface so that cycles in the graph
 are created.
 If those graphs involve audio wires, the resulting loops in the audio processin
g chain are detected and propagation is halted.
 When cycles happen in the message flow, messages may also produce infinite
 loops, but being dynamic they cannot be detected a priori: those are caught
 during run mode, reporting a stack overflow.
 
\end_layout

\begin_layout Subsection
Messages and the textual sub-language
\end_layout

\begin_layout Standard
Nodes in Pure Data are similar to spreadsheet cells, in the sense that they
 are primarily containers for a textual language.
 Once the user selects 
\begin_inset Quotes eld
\end_inset

Object
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

Message
\begin_inset Quotes erd
\end_inset

 in the 
\begin_inset Quotes eld
\end_inset

Put
\begin_inset Quotes erd
\end_inset

 menu, a new node with the corresponding shape appears in the canvas and
 the keyboard focus switches to it immediately.
 The user then types in the contents of the node, based on which Pure Data
 determines its number of inlets and outlets, which appear as connectors
 at the top and bottom of the node's box.
 For example, in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:puredata"

\end_inset

 node [
\family typewriter
metro 500
\family default
] has inlets (with only the left one connected) and outlet; node [
\family typewriter
dac~ 1
\family default
] has only one inlet and no outlets.
\end_layout

\begin_layout Standard
When editing the graph, apart from connecting outlets to inlets and positioning
 nodes, everything else is done with the textual language.
 It is a very basic imperative command language, more similar to the language
 of primitive interactive shells than that of typical programming languages.
 When a command is entered in an object box, the first token represents
 the internal function to be executed (e.g.
 [
\family typewriter
osc~
\family default
], [
\family typewriter
metro
\family default
]) and the remaining tokens are arguments to that function.
 In message boxes, multiple commands may be entered, separated by a semicolon.
 The first command is always a message to be sent through the outlet of
 the message box, in subsequent commands, the first token is the receiver
 and the remaining tokens are messages.
 Values received in inlets are available for token substitution using numbered
 variables such as 
\family typewriter
$1
\family default
.
\end_layout

\begin_layout Standard
The system of messaging via named receivers allows the program to send data
 between nodes that are not explicitly linked via connections.
 The relationship between a message and a receiver can be thought of as
 an implicit edge in the dataflow graph.
 Since the textual language of messages supports variable arguments fed
 via input ports, receiver destinations can change during execution: this
 makes the dataflow graph, in effect, mutable at runtime.
 This, however, is limited to discrete messages, and only the destination
 of a message can be changed at runtime, and not the identifier a receiver
 is 
\begin_inset Quotes eld
\end_inset

listening
\begin_inset Quotes erd
\end_inset

 to.
 The flow of audio data cannot be re-routed while in run mode, but disconnection
s can be simulated multiplying a signal by 0.
\end_layout

\begin_layout Standard
A precise definition of the language semantics will be given in Section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Interpreter-Pure-Data"

\end_inset

, but to give a feel of the language we will describe two examples from
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:puredata"

\end_inset

.
 The first example is the simplest use of message boxes: message box [
\family typewriter
0 100
\family default
] simply sends tokens 
\family typewriter
0
\family default
 and 
\family typewriter
100
\family default
 to [
\family typewriter
line~
\family default
] when clicked.
 The second example demonstrates variable substitution and indirect connections.
 When the user clicks message boxes [
\family typewriter
0
\family default
] or [
\family typewriter
1
\family default
], this feeds the value to message box [
\family typewriter
;pd dsp $1;toggle $1
\family default
], which contains three commands.
 The first command is empty, indicating there is nothing to be sent to the
 outlet port.
 The second command is sent to receiver 
\family typewriter
pd
\family default
, which is Pure Data's internal receiver—here it is used to enable and disable
 the audio engine.
 The third command sends the value 
\family typewriter
0
\family default
 or 
\family typewriter
1
\family default
 to the user-defined receiver 
\family typewriter
toggle
\family default
.
\end_layout

\begin_layout Subsection
Node triggering
\begin_inset CommandInset label
LatexCommand label
name "sub:Node-triggering"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="3">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top" width="30col%">
<column alignment="center" valignment="top" width="30col%">
<column alignment="center" valignment="top" width="30col%">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename puredata_inlets_cold.png
	scale 80

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename puredata_inlets_bad.png
	scale 80

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename puredata_inlets_good.png
	scale 80

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(a)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(b)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(c)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Inlets"

\end_inset

Behavior of hot and cold inlets in Pure Data
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To avoid triggering functions with multiple arguments many times, as the
 input arguments arrive through different paths of the graph, Pure Data
 has the notion of 
\emph on
hot
\emph default
 and 
\emph on
cold
\emph default
 input ports.
 Only the hot inlet triggers the node; data arriving to a cold inlet stays
 buffered there and is only consumed when a hot input port is triggered.
 This allows, for example, to create a 
\begin_inset Quotes eld
\end_inset


\family typewriter
float
\family default

\begin_inset Quotes erd
\end_inset

 node that increments its value every time it is triggered, by sending its
 output to an increment node (
\begin_inset Quotes eld
\end_inset


\family typewriter
+ 1
\family default

\begin_inset Quotes erd
\end_inset

) and sending the result back via a secondary, cold inlet (see Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Inlets"

\end_inset

(a)).
 This will 
\emph on
not
\emph default
 create an infinite loop, because the result of the increment will only
 be consumed next time the hot inlet of the node is triggered.
\end_layout

\begin_layout Standard
Due to the way Pure Data handles messages, for some node types the order
 in which connections are performed in its interface can change the semantics
 of the resulting graph, so that two visually identical graphs can produce
 different results, depending on the order in which the lines between nodes
 were drawn in the UI.
 This behavior is documented as a possible user pitfall in the documentation
 
\begin_inset CommandInset citation
LatexCommand cite
key "PuckettePd"

\end_inset

.
 The example in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Inlets"

\end_inset

(b) was taken directly from the documentation, which says: 
\begin_inset Quotes eld
\end_inset

Here, I connected the left inlet before connecting the right hand one (although
 this is not evident in the appearance of the patch)
\begin_inset Quotes erd
\end_inset

.
 In fact, disconnecting node [
\family typewriter
6
\family default
] from [
\family typewriter
+
\family default
] and connecting the left inlet first makes it work as intended, updating
 the bottom box with the double of the top box as we edit the value at the
 top.
 The documentation suggests as a workaround disambiguating the graph by
 using the object [
\family typewriter
t
\family default
] (shorthand for [
\family typewriter
trigger
\family default
]), which triggers its outlets from right to left, as depicted in Figure
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Inlets"

\end_inset

(c).
\end_layout

\begin_layout Section
An interpreter modeling the semantics of Pure Data
\begin_inset CommandInset label
LatexCommand label
name "sec:Interpreter-Pure-Data"

\end_inset


\end_layout

\begin_layout Standard
We produced an executable model of the core semantics of Pure Data 
\begin_inset CommandInset citation
LatexCommand cite
key "PuckettePd,Zmolnig2014pd"

\end_inset

 written in Haskell, which includes stateful nodes for multiple data types,
 message and audio objects, identifier-based message passing and the intra-node
 language for message objects.
\end_layout

\begin_layout Standard
Our model implements a simulation of the run mode, in which the graph is
 fixed and input events are fed into it.
 It replicates the synchronous behavior of Pure Data, processing cascades
 of message events and DSP ticks for propagating audio buffers.
 It does not implement 
\begin_inset Quotes eld
\end_inset

abstractions
\begin_inset Quotes erd
\end_inset

 (which is Pure Data jargon for loading subprograms from separate files),
 and dollar-expansion in object boxes, which is only used when loading abstracti
ons.
 Still, our model is complete and precise enough so that the numeric values
 produced in audio buffers can be converted to a sound file format and played
 back.
\end_layout

\begin_layout Standard
This entire section describing the interpreter was written in Literate Haskell
 
\begin_inset CommandInset citation
LatexCommand citep
key "Hinze2015lhs2tex"

\end_inset

, and is a description of the entire interpreter, including its complete
 listings.
 The text was written so that it should be understandable without a detailed
 reading of the source code, but the sources are nevertheless included for
 completeness and as supporting material for the interested reader.
 The source code in 
\family typewriter
.lhs
\family default
 format (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
LaTeX{}
\end_layout

\end_inset

 with embedded Haskell) is also available at 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://hisham.hm/thesis/
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
setlength{
\backslash
mathindent}{0pt}
\end_layout

\begin_layout Plain Layout


\backslash
input{PdInterpreter_text.tex}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Demonstration
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement b
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename puredata_example.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Pure-Data-example"

\end_inset

A Pure Data patch equivalent to the example code in Appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "appendix:Pure-Data"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "appendix:Pure-Data"

\end_inset

, the present a practical demonstration of the interpreter in use.
 We run the patch depicted in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Pure-Data-example"

\end_inset

.
 In includes atom boxes, objects and message boxes, and features message
 and audio processing, variable expansion, indirect messages and delayed
 execution.
 Running the interpreter emulates Pure Data's 
\begin_inset Quotes eld
\end_inset

use
\begin_inset Quotes erd
\end_inset

 mode: the graph cannot be modified, but atom boxes can receive new values
 and message boxes can be clicked, producing events.
 The interpreter simulates this interactive experience by receiving as inputs
 a list of interaction events with timestamps.
\end_layout

\begin_layout Standard
Appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "appendix:Pure-Data"

\end_inset

 also includes a main wrapper function that launches the interpreter and
 converts its output to .WAV format.
 The resulting audio file produced by the execution of the above graph by
 the interpreter when given a specific series of inputs can be played at
 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://hisham.hm/thesis/
\end_layout

\end_inset


\end_layout

\begin_layout Section
Discussion: Syntax and semantics in visual languages
\begin_inset CommandInset label
LatexCommand label
name "sec:Discussion:-Syntax-and-semantics"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top" width="40col%">
<column alignment="center" valignment="top" width="40col%">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename max_correct.png
	scale 50

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename max_incorrect.png
	scale 50

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(a)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(b)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Max-problem"

\end_inset

Impact of semantically significant layout in Max/MSP: Two graphs with identical
 sets of nodes and edges producing different results.
 Image adapted from 
\begin_inset CommandInset citation
LatexCommand citep
key "Gold2009MaxPoster"

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset

The design of end-user programmable applications is a field that spans both
 the worlds of end-user application design and of programming language design.
 These two areas are often distant from each other.
 The programming language design community is most often concerned with
 professionals, and most end-user programs made by application developers
 nowadays are not programmable.
 These different groups naturally tend to be biased towards different aspects
 of design.
\end_layout

\begin_layout Standard
This separation happens to the detriment of end-user programming language
 design.
 Research in visual languages, in particular, is almost by definition focused
 primarily on syntax, given the area itself is defined by a style of representat
ion.
 But while the programming language community may be guilty of sometimes
 dismissing matters of syntax
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
As a historical aside, the dismissal of syntax has a long history in the
 programming language community.
 This sentiment is perhaps best symbolized by the popularity of the term
 
\begin_inset Quotes eld
\end_inset

syntactic sugar
\begin_inset Quotes erd
\end_inset

.
 While the term has gained a slightly more neutral connotation over the
 years to refer to syntactic constructs whose behavior can be replicated
 using more fundamental constructs of a language, the original coinage of
 the expression by Peter Landin already set the dismissive tone by calling
 it 
\begin_inset Quotes eld
\end_inset


\emph on
mere 
\begin_inset Quotes eld
\end_inset

syntactic sugar
\begin_inset Quotes erd
\end_inset


\emph default

\begin_inset Quotes erd
\end_inset

 in its very first occurrence 
\begin_inset CommandInset citation
LatexCommand citep
key "Landin1964mechanical"

\end_inset

.
 The influential Lisp community further cemented the pejorative bias associated
 to the term, as seen in a footnote remark by Abelson et al.
 in the classic 
\emph on
Structure and Interpretation of Computer Programs
\emph default
 
\begin_inset CommandInset citation
LatexCommand citep
key "Abelson:1996:SIC:547755"

\end_inset

 (where they also proclaim their 
\begin_inset Quotes eld
\end_inset

disdain for syntax
\begin_inset Quotes erd
\end_inset

 literally) and by Perlis in his 
\emph on
Epigrams on Programming
\emph default
 
\begin_inset CommandInset citation
LatexCommand citep
key "Perlis:1982:SFE:947955.1083808"

\end_inset

.
 While humorous, these comments reflect an established culture that continues
 to be reinforced 
\begin_inset CommandInset citation
LatexCommand citep
key "Wadler1996law,Tratt2005syntax"

\end_inset

.
 It is remarkable that, while this view tends to be more associated to the
 theoretical side of the programming language community, we see among mathematic
ians a prolific use of notational shorthands (the so-called 
\begin_inset Quotes eld
\end_inset

syntactic sugar
\begin_inset Quotes erd
\end_inset

) and, most importantly, an acknowledgement of the evolution of notation
 as being pivotal in the history of mathematics 
\begin_inset CommandInset citation
LatexCommand citep
key "Cajori1909math"

\end_inset

.
\end_layout

\end_inset

 and perpetuating arguably poor syntax in the name of familiarity
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Wadler1996law,Tratt2005syntax"

\end_inset

, the neglect of semantics in the design of the syntax of end-user applications
 has much graver consequences.
\end_layout

\begin_layout Standard
As we saw in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Node-triggering"

\end_inset

, Pure Data specifies the right-to-left order in outlets are processed,
 but the order in which messages are fired from various connections of a
 single outlet depend on the order the connections were made, making it
 possible to produce two visually identical graphs with different behavior.
 This is a major flaw in the language's syntax, and one that could be easily
 fixed by exposing in the syntax the ordered nature of the outgoing connections.
 Two possible solutions would be to draw the connector lines next to each
 other (and not starting from the same point) making the outlet wider as
 needed, or to make connection lines visually distinct (e.g.
 attaching a number to the lines, or simply painting them with different
 colors according to their sort order).
\end_layout

\begin_layout Standard
In Max/MSP, the commercial variant of Pure Data, it is not possible to produce
 two identical graphs with two behavior, but the solution chosen by its
 developers may be even worse.
 Max/MSP establishes that the order of message propagation follows that
 of the visual layout of a patch, that is, the coordinates on the canvas
 of nodes
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citep
key "Gold2011MaxMSP"

\end_inset

.
 This means that moving nodes around, without changing their connections,
 can alter the behavior of the graph, leading to situations like the one
 depicted in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Max-problem"

\end_inset

: two graphs with identical sets of nodes and edges producing different
 results.
 It is fair to assume that this counters any intuition a user may have about
 the interpretation of a diagram.
\end_layout

\begin_layout Standard
If syntax evolves at a slow pace in the world of textual languages, it may
 well be because it has reached a 
\begin_inset Quotes eld
\end_inset

local maximum
\begin_inset Quotes erd
\end_inset

 in the design space, where current syntaxes are 
\begin_inset Quotes eld
\end_inset

good enough
\begin_inset Quotes erd
\end_inset

 and it would take a major leap to move into something different.
 In the world of visual languages, it seems clear that we have not yet reached
 this point.
\end_layout

\begin_layout Chapter
Case study: spreadsheets
\begin_inset CommandInset label
LatexCommand label
name "chap:Spreadsheets"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Popularity
\end_layout

\end_inset

The spreadsheet is arguably the most successful end-user programmable applicatio
n 
\begin_inset CommandInset citation
LatexCommand citep
key "Scaffidi:2005:ENE:1092357.1092394"

\end_inset

.
 Microsoft Excel is the most successful product of this kind, as part of
 Microsoft Office, a productivity suite with over 1.2 billion users 
\begin_inset CommandInset citation
LatexCommand citep
key "Microsoft2014ByTheNumbers"

\end_inset

.
\end_layout

\begin_layout Standard
The importance of this class of applications as well as concerns with the
 reliability of spreadsheets produced by users
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Losses caused by spreadsheet errors are calculated in the scale of millions
 of dollars 
\begin_inset CommandInset citation
LatexCommand citep
key "Sakal2012StrategicManagement"

\end_inset

.
\end_layout

\end_inset

 have inspired academic work in areas such as debugging 
\begin_inset CommandInset citation
LatexCommand citep
key "Barowy:2014:CDD:2660193.2660207"

\end_inset

, testing 
\begin_inset CommandInset citation
LatexCommand citep
key "Carver:2006:EET:1159733.1159775"

\end_inset

 and expressivity 
\begin_inset CommandInset citation
LatexCommand citep
key "Jones03User-centred"

\end_inset

 of spreadsheets.
 Often, these works involve modeling the spreadsheet application in order
 to reason about it.
 Formal models of spreadsheets applied to research work usually simplify
 considerably their semantics of execution, assuming a model of computation
 with no specifications for error conditions and without advanced features
 such as indirect references 
\begin_inset CommandInset citation
LatexCommand citep
key "Abraham:2006:TIS:1140335.1140346,Cunha:2009:SRD:1480945.1480972"

\end_inset

.
\end_layout

\begin_layout Standard
Real-world spreadsheets, however, are nothing but simple.
 Their design has evolved over the years, but to this day, spreadsheets
 follow the design paradigm of VisiCalc, created in 1979 for the Apple II.
 The user interface of a spreadsheet is dominated by a grid view, inspired
 by physical paper spreadsheets.
 Each cell of this grid presents a value, which may be calculated by a formula,
 which may reference values calculated by other cells.
 In the 1980s and 1990s several applications competed for this market, of
 which VisiCalc failed to maintain dominance.
 Lotus 1-2-3, Quattro Pro, Multiplan and Excel all introduced new features,
 such as instant recalculation, formula auto-fill (where the user can produce
 new formulas by dragging the cursor from one cell, producing formulas in
 new cells following a predictable pattern), multiple worksheets, and so
 on.
 As they adopted each other's features, the design of spreadsheet applications
 coalesced to that of Excel today, and by the 2000s the competition among
 proprietary spreadsheets was essentially over.
 The only popular alternatives to Excel that emerged since then did not
 gain adoption due to their feature set, but due to non-functional characteristi
cs: LibreOffice Calc
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Originally StarCalc, a proprietary spreadsheet that was part of StarOffice,
 a productivity suite developed in the 1990s by German company StarDivision.
 This company was bought by Sun Microsystems, which open-sourced StarOffice
 as OpenOffice.
 LibreOffice emerged as a fork of OpenOffice after Oracle's acquisition
 of Sun.
\end_layout

\end_inset

 became the main free software spreadsheet; Google Sheets is the most popular
 web-based spreadsheet.
 For both products (and their users), compatibility with Excel is a major
 concern.
 Reproducing the semantics of Excel, therefore, ought to be considered a
 major goal for these projects.
\end_layout

\begin_layout Standard
For a long time, there was no specification whatsoever of the semantics
 of Excel, or even of its file format.
 It was only in 2006, 21 years after the initial release of Excel, that
 a specification was published detailing its file format 
\begin_inset CommandInset citation
LatexCommand citep
key "ISO29500_OfficeOpenXML"

\end_inset

, due to political push towards open formats.
 Its semantics, however, remain vague.
 Unsurprisingly, as we will see below, these major competitors fail to implement
 full compatibility with Excel's formula language.
 Interestingly, even Excel Online
\begin_inset Foot
status open

\begin_layout Plain Layout
Available at 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://office.live.com/start/Excel.aspx
\end_layout

\end_inset


\end_layout

\end_inset

, also produced by Microsoft as a response to Google Sheets, fails to implement
 the semantics of the formula language correctly.
\end_layout

\begin_layout Section
The formula language
\end_layout

\begin_layout Standard
We studied the formula language as implemented by five spreadsheet applications:
\end_layout

\begin_layout Itemize
Microsoft Excel 2010, the spreadsheet market leader, matching the standardized
 document for the .xlsx format 
\begin_inset CommandInset citation
LatexCommand citep
key "ISO29500_OfficeOpenXML"

\end_inset

, which is still current at the time of this writing;
\end_layout

\begin_layout Itemize
LibreOffice Calc 5, the leading free software spreadsheet, whose behavior
 also matches the latest specification documents for its file format 
\begin_inset CommandInset citation
LatexCommand citep
key "OASIS2011ODFFormula"

\end_inset

;
\end_layout

\begin_layout Itemize
Google Sheets, a prominent web-based spreadsheet; 
\end_layout

\begin_layout Itemize
Microsoft Excel Online, Microsoft's own web-based version of Excel;
\end_layout

\begin_layout Itemize
Microsoft Excel for Android version 16.0.7127.1010, Microsoft's mobile version
 of Excel.
\end_layout

\begin_layout Standard
All five implementations have incompatibilities to various levels, but they
 are similar enough so that they can be understood as dialects of the same
 language.
 The exposition below presents this formula language as implemented by these
 spreadsheets, discussing it from a programming language design perspective.
 We focus primarily on Excel, since the other applications mostly follow
 its design, but we highlight their variations whenever they appear.
 In particular, Microsoft Excel for Android presents very close behavior
 to that of Excel Online.
 Whenever mobile Excel is not explicitly mentioned, the reader can assume
 that its behavior matches that of Excel Online.
\end_layout

\begin_layout Standard
Given both Google Sheets and Excel Online are server-based applications,
 their behavior may change at any time, so all observations about them are
 current at the time of writing.
\begin_inset Note Note
status open

\begin_layout Plain Layout
make screencasts
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Syntax
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Expression language, First-class functional language
\end_layout

\end_inset

Nowadays, all spreadsheet products use roughly the same formula language:
 the user of any spreadsheet user will be familiar with expressions such
 as 
\family typewriter
=A5+SUM(B10:B20)
\family default
.
 From a programming point of view, spreadheets have been described as a
 
\begin_inset Quotes eld
\end_inset

first-order functional languages
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand citep
key "Abraham:2006:TIS:1140335.1140346"

\end_inset

.
 The formula language is a language of expressions, with a number of predefined
 operators, such as 
\family typewriter
+
\family default
 (addition), 
\family typewriter
&
\family default
 (string concatenation), as well as a large number of built-in functions,
 such as 
\family typewriter
SQRT
\family default
 and 
\family typewriter
SUM
\family default
.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Typical syntax
\end_layout

\end_inset

At first glance, it is not unlike the sub-language of expressions with infix
 operators and function calls contained in a number of programming languages.
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
English
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Portuguese
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Numbers
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
6.2831
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
6,2831
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Function names
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
SQRT(9)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
RAIZ(9)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Argument separators
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
SUM(6,0.2831)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
SOMA(6;0,2831)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Literal matrices
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
{1,2;3,4}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
{1;2
\backslash
3;4}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Function arguments
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
CELL("type",A1)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
CÉL("tipo",A1)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Syntactic-localization"

\end_inset

Syntactic changes in localized versions of Excel: all but the last one can
 be automatically converted by the application.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The syntax of the language changes across translated versions of Excel.
 The names of functions are localized: for example, 
\family typewriter
SUM()
\family default
 becomes 
\family typewriter
SOMA()
\family default
 in the Portuguese version.
 Also, in many languages the comma is used as a decimal separator for numbers,
 forcing other uses of commas to be replaced by semicolons, and semicolons
 to be replaced by backslashes.
 Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Syntactic-localization"

\end_inset

 lists those differences.
 The application stores function names internally in English, so these and
 other operator changes are automatically translated when a file by opened
 in another version of Excel.
 This automatic conversion, unfortunately, is not complete.
 Some functions use a set of predefined strings as a kind of enumeration,
 such as 
\family typewriter
CELL("type", A1)
\family default
.
 These arguments were translated in localized versions of the functions,
 and these break when loaded in a different language: a function written
 in a Portuguese version of Excel as 
\family typewriter
CÉL("tipo", A1)
\family default
 becomes 
\family typewriter
CELL("tipo", A1)
\family default
 when loaded in an English version of Excel, which produces an error.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
This does happen in practice: 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.e-dicas.pt/2012/06/formula-de-excel-para-obter-nome-do.html
\end_layout

\end_inset

; this site has a translator service for arguments of CELL and INFO: 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://en.excel-translator.de/translator/
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="5">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Microsoft
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LO
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Google
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Excel
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Excel
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Calc
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sheets
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Online
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Refer to a sheet
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
Sheet2!B1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
Sheet2.B1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
Sheet2!B1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
Sheet2!B1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Array formulas
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
{=
\family default
\emph on
fn
\family typewriter
\emph default
}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
{=
\family default
\emph on
fn
\family typewriter
\emph default
}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
=ARRAYFORMULA(
\family default
\emph on
fn
\family typewriter
\emph default
)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N/A
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nested arrays
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Error
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Error
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Flattened 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Error
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Some-syntactic-incompatibilities"

\end_inset

Some syntactic incompatibilities between spreadsheets
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Even at a syntactic level, we found that while the studied applications
 have similar formula languages, they were all incompatible to each other.
 The surface similarity is certainly meant to lower the learning curve for
 users who are moving from one application to the other, but beyond the
 basics, incompatibilities show.
 Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Some-syntactic-incompatibilities"

\end_inset

 lists some of these incompatibilities.
 It is notable that even though only a mere three features are listed, no
 two columns in the table are alike.
\end_layout

\begin_layout Subsection
Values and types
\end_layout

\begin_layout Standard
The formula language is typed and it features scalar and matrix values.
 Scalar values may be of type boolean, error, string or number.
 Matrices are bidimensional, with unidimensional arrays as a particular
 case, and may contain scalar values of heterogenous types, but matrices
 cannot contain other matrices.
 Google Sheets accepts nested matrix syntax, but matrices are in effect
 flattened: 
\family typewriter
{1,{2,3},4}
\family default
 is syntactically valid but it is equivalent to 
\family typewriter
{1,2,3,4}
\family default
.
 In all other three spreadsheets, nested matrix literals produce a syntax
 error.
\end_layout

\begin_layout Standard
The matrix notation with curly brackets can be only used to represent literals.
 It is not a general matrix constructor, and can only contain scalar literals,
 and not subexpressions: while 
\family typewriter
{1,2,3}
\family default
 is valid, both 
\family typewriter
{1+1}
\family default
 and 
\family typewriter
{A1}
\family default
 are not.
\end_layout

\begin_layout Standard
Most contexts feature automatic coercions, but not all.
 The expression 
\family typewriter
="1"+"2"
\family default
 returns the number 
\family typewriter
3
\family default
, as does 
\family typewriter
=SQRT("9")
\family default
.
 But functions taking arrays of numbers, such as 
\family typewriter
SUM
\family default
, skip all string values.
 Therefore, given cells A1 to A3 containing 
\family typewriter
1
\family default
, 
\family typewriter
2
\family default
 and 
\family typewriter
"100"
\family default
, we have that 
\family typewriter
=A1+A2+A3
\family default
 returns 
\family typewriter
103
\family default
, and 
\family typewriter
=SUM(A1:A3)
\family default
 returns 
\family typewriter
3
\family default
.
 Oddly, it does coerce boolean values, so, replacing A1 with 
\family typewriter
TRUE
\family default
 in the previous example still yields the same results for both formulas.
\end_layout

\begin_layout Standard
Formula expressions may contain and manipulate scalars and matrices, including
 matrix literals, but cells can only represent scalar values.
 Each cell in the grid may be either empty or have contents entered by the
 user.
 
\emph on
Cell contents
\emph default
 may be either nothing, a formula or a scalar literal value entered (attempting
 to enter a matrix literal causes it to be simply interpreted as a string).
 A cell also has a result value, based on its contents.
 
\emph on
Cell values
\emph default
 may be either nothing (coerced to either 
\family typewriter
0
\family default
 or 
\family typewriter
""
\family default
 as necessary) or a scalar value produced from the calculation of the formula.
 Cells may also have formatting metadata that are only relevant to the UI
 presentation of values, but are not distinct types: for example, percentages
 and dates are still values of type number; colors and fonts are also formatting
 metadata of a cell.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="5">
<features rotate="0" tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Microsoft
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LO
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Google
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Excel
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Excel
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Calc
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sheets
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Online
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
=TYPE({1})
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
64
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
64
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
64
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
=TYPE({1,1})
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
64
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
64
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
64
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
64
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
=TYPE(1+{1,2})
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
64
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
64
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
64
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
=TYPE({1,2}/0)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
64
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
64
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
64
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
=TYPE(Z99)
\family default
\size default
\emph on
 (Empty)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
Err:502
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
=TYPE(A1)
\family default
\size default
\emph on
 (Self)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
0 
\family default
\size default
\emph on
(Warning)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
Err:502
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
#REF!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
0
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:TYPE-function"

\end_inset

Behavior of the 
\family typewriter
TYPE
\family default
 function in spreadsheets
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Whenever a scalar value is expected and a matrix value is given, the value
 at position 
\begin_inset Formula $(1,1)$
\end_inset

 of the matrix is returned.
 The UI of a spreadsheet displays cell values by default.
 Some functions, however, operate on cell contents—that is, there are functions
 
\emph on
f
\emph default
 so that 
\emph on
f
\family typewriter
\emph default
(10)
\family default
 and 
\emph on
f
\family typewriter
\emph default
(A1)
\family default
 with 
\family typewriter
A1=10
\family default
 produce different results.
 An example is the function 
\family typewriter
TYPE
\family default
, which returns the data type of the cell contents as a number.
 Given a cell as an argument, 
\family typewriter
TYPE
\family default
 returns 
\family typewriter
1
\family default
 if the cell contains a number literal, 
\family typewriter
2
\family default
 for strings and 
\family typewriter
4
\family default
 for booleans.
 If the cell contains a formula, it returns 
\family typewriter
8
\family default
 regardless of the data type of the formula's result, unless the formula
 results in an error, in which case it returns 
\family typewriter
16
\family default
, or if it contains a matrix literal, in which case it returns 
\family typewriter
64
\family default
 whether the expression results in an error or not.
 When given an expression as an argument, 
\family typewriter
TYPE
\family default
 returns the type of the value of the evaluated expression.
 This complicated behavior, which is not implemented consistently among
 spreadsheets (Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:TYPE-function"

\end_inset

 shows some incompatibilities), illustrates how poorly data types are presented
 to users in spreadsheets.
\end_layout

\begin_layout Section
Evaluation model
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center

\size small
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
B
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
=B2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
=IF(5<A1;A2;B1)+B2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
10
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

(a) A simple spreadsheet.
 A1 evaluates to 10, B1 evaluates to 19
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset


\size default

\begin_inset Graphics
	filename excel_evaluation.eps
	width 75col%

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

(b) The same spreadsheet represented as a dataflow graph
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
The usual representation of a spreadsheet with a grid layout and a textual
 formula language, and its conceptual dataflow graph displaying data dependencie
s.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Our study of the semantics of Excel has uncovered other oddities: 
\end_layout

\begin_layout Standard
Built-in functions 
\family typewriter
IF()
\family default
 and 
\family typewriter
CHOOSE()
\family default
 are evaluated lazily (
\family typewriter
IF(1<2, 10, 0/0)
\family default
 returns 
\family typewriter
10
\family default
 and 
\family typewriter
0/0
\family default
 is never evaluated), but functions 
\family typewriter
AND()
\family default
 and 
\family typewriter
OR()
\family default
 are not.
 These two functions do not perform short-circuiting: 
\family typewriter
OR(TRUE, 10)
\family default
 returns 
\family typewriter
TRUE
\family default
 but 
\family typewriter
OR(TRUE, 0/0)
\family default
 returns 
\family typewriter
#DIV/0!
\family default
, an error value.
 To check that the evaluation disciplines of 
\family typewriter
IF
\family default
 and 
\family typewriter
AND
\family default
/
\family typewriter
OR
\family default
 are indeed different, we escaped the purely functional formula language
 by writing a BASIC macro that produces a side-effect, popping up a dialog
 box.
 In both Excel and LibreOffice, the spreadsheets supporting BASIC macros,
 
\family typewriter
OR(TRUE, PopDialogBox())
\family default
 pops a dialog box but 
\family typewriter
IF(1<2, 10, PopDialogBox())
\family default
 does not.
 Google Sheets supports JavaScript macros, and while its API explicitly
 blocks IO side-effects such as dialog boxes in formula macros, we were
 able to reproduce this test by writing a recursive function that causes
 a stack overflow, with similar results.
 Excel Online does not support running macros of any kind.
\end_layout

\begin_layout Standard
Errors are propagated as the formula is evaluated from left to right.
 This behavior is relevant to language compatibility since errors can be
 detected by functions such as 
\family typewriter
ISNA()
\family default
, which returns 
\family typewriter
TRUE
\family default
 for 
\family typewriter
#N/A
\family default
 and 
\family typewriter
FALSE
\family default
 for any other error or non-error values.
 Given cells 
\family typewriter
A1
\family default
 containing 
\family typewriter
=1/0
\family default
 (evaluates to 
\family typewriter
#DIV/0
\family default
) and 
\family typewriter
A2
\family default
 containing 
\family typewriter
#N/A
\family default
, 
\family typewriter
ISNA(A1+A2)
\family default
 evaluates to 
\family typewriter
FALSE
\family default
 and 
\family typewriter
ISNA(A2+A1)
\family default
 evaluates to 
\family typewriter
TRUE
\family default
.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Array-formulas"

\end_inset

Array formulas
\end_layout

\begin_layout Standard
An 
\emph on
array formula
\emph default
 is a formula that is marked to be evaluated in a special array-oriented
 evaluation model.
 In Excel and LibreOffice a formula is marked as an array formula by confirming
 its entry pressing Ctrl+Shift+Enter, and the UI displays the formula enclosed
 in brackets, as in 
\family typewriter
{=A1:B5+10}
\family default
; in Google Sheets, they use a function-style annotation, as in 
\family typewriter
=ARRAYFORMULA(A1:B5+10)
\family default
.
 In the array formula evaluation mode, when ranges are given as arguments
 to scalar operations (such as + in the above example), the range is decomposed
 and the operation is performed for each element.
 The results of an array formula, therefore, may extend to several cells.
 Once the user enters an array formula, the required number of cells is
 filled with the results, with the initial cell being the top-left entry
 of the result matrix.
\end_layout

\begin_layout Standard
For the array formula above, 
\family typewriter
{=A1:B5+10}
\family default
, the result is a matrix with two columns and five rows, in which each cell
 is filled as if the range was substituted by a scalar corresponding to
 the given offset in the range, such that, for each cell 
\emph on
(x, y)
\emph default
 of the resulting matrix, its value is equivalent to that of 
\family typewriter
=INDEX(A1:B5, 
\family default
\emph on
x
\family typewriter
\emph default
, 
\family default
\emph on
y
\family typewriter
\emph default
)+10
\family default
 (where 
\family typewriter
INDEX
\family default
 is the function that takes element in row x, column y of the given range).
 This example belies the complexity in the evaluation of array formulas,
 for a simple substitution of ranges for their elements is not sufficient.
 When a function such as 
\family typewriter
SUM()
\family default
 expects an array argument, the full range is given to the function.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="6">
<features rotate="0" tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Microsoft
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LO
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Google
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Excel
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Excel
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Calc
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sheets
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Online
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="left" valignment="middle" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
=SUM(SQRT({10,20}))
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
7.6344
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
3.1622
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
3.1622
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
7.6344
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AF
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
7.6344
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
7.6344
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
7.6344
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="left" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
=SUM(SQRT(A1:A2))
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
#VALUE!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
#VALUE!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
#VALUE!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
#VALUE!
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AF
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
7.6344
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
7.6344
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
7.6344
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="left" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
=SUM(SQRT(INDIRECT({"A1","A2"}))
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
#VALUE!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
3.1622
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
3.1622
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
#VALUE!
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AF
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
#VALUE!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
7.6344
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
3.1622
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="left" valignment="middle" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
=SUM(INDIRECT({"A1","A2"})
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
10
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AF
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
30
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
=SUM(MINVERSE(A1:B2))
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
4.163E-17
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
27756E-17
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
#VALUE!
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Formula-evaluation-incompatibilities"

\end_inset

Formula evaluation incompatibilities between spreadsheets
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This showcases a behavior that is very different from that of most programming
 languages: evaluation of sub-expressions is context-sensitive.
 The way a sub-expression is evaluated may vary according to an enclosing
 function call, perhaps several levels up in the syntax tree of the expression.
 The expected types of arguments for built-in functions define whether expressio
ns given to them will have scalar or matrix evaluation.
 Within an array formula, for scalar arguments, arrays are destructured
 so that a scalar element is given.
\end_layout

\begin_layout Standard
The UI presentation of the array formula also influences the resulting values
 of cells: an array formula is always entered over a rectangular group of
 one or more cells.
 This group has a user-defined size that may or may not match the size of
 the matrix value of the array formula.
 The default size of the cell group matches that of the matrix value, but
 the cell group may be resized by the user by dragging the selection corner.
 Growing the group beyond the size of the result matrix may result in cells
 filled with 
\family typewriter
#N/A
\family default
; conversely, shrinking the cell group may hide parts of the result matrix.
\end_layout

\begin_layout Standard
We say it 
\begin_inset Quotes eld
\end_inset

may
\begin_inset Quotes erd
\end_inset

 result in 
\family typewriter
#N/A
\family default
 because the precise semantics are a bit more complicated: if any of the
 dimensions of the result matrix is 1, increasing the size of the cell group
 in this dimension will produce repeated values in that dimension.
 For example, if the array formula 
\family typewriter
={10,20}
\family default
 which produces a single-row matrix is inserted in a 
\begin_inset Formula $3\times2$
\end_inset

-group 
\family typewriter
A1:B3
\family default
, then the row will be duplicated, and cells 
\family typewriter
A1:A3
\family default
 and 
\family typewriter
B1:B3
\family default
 will present the same contents, namely: 
\family typewriter
10
\family default
, 
\family typewriter
20
\family default
 and 
\family typewriter
#N/A
\family default
.
 If the matrix representation of an array formula value is 
\begin_inset Formula $1\times1$
\end_inset

 (which is also the case if the result value is not a matrix), all values
 in its cell group will be identical.
\end_layout

\begin_layout Standard
Array formulas are a niche feature: from the Enron corpus of 15935 industrial
 spreadsheets used in 
\begin_inset CommandInset citation
LatexCommand citep
key "AivaloglouXLGrammar2015"

\end_inset

, we independently assessed that 185 of them use array formulas (1.16%).
 However, arrays are pervasive in Excel: ranges such as 
\family typewriter
A1:A5
\family default
 reference arrays of cells, and common functions such as 
\family typewriter
SUM()
\family default
 take arrays as arguments.
 Functions that expect arrays as arguments evaluate these arguments in an
 
\emph on
array context
\emph default
, producing different values than arguments evaluated in a 
\emph on
scalar context
\emph default
.
 In Excel, an array context of evaluation can produce iterated calculation
 of scalar functions, like in the context of array formulas.
 This is not implemented in LibreOffice or Google Sheets, which both reserve
 iterated execution to array formulas.
 Interestingly, Excel Online, which does not support array formulas, does
 implement iterated execution in array contexts of plain formulas.
 Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Formula-evaluation-incompatibilities"

\end_inset

 illustrates these incompatibilities (in the second column of this table,
 F denotes plain formula mode, AF denotes array formula mode).
 In the first two examples, the enclosing 
\family typewriter
SUM
\family default
 function imposes an array context over scalar function 
\family typewriter
SQRT
\family default
, triggering its iterated calculation in Excel and Excel Online plain formulas.
 In the last two examples, assuming 
\family typewriter
A1
\family default
 and 
\family typewriter
A2
\family default
 contain 
\family typewriter
10
\family default
 and 
\family typewriter
20
\family default
 and 
\family typewriter
B1
\family default
 and 
\family typewriter
B2
\family default
 contain 
\family typewriter
30
\family default
 and 
\family typewriter
40
\family default
, 
\family typewriter
INDIRECT({"A1","A2"})
\family default
 produces an array 
\family typewriter
{10,20}
\family default
 which is coerced to scalar 
\family typewriter
10
\family default
 in all modes except LibreOffice's array formula mode; in the third example,
 Excel and Excel Online fail to propagate the array context in a doubly-nested
 function.
 In the last row, we see that the spreadsheets also have inconsistencies
 in their evaluation order leading to observable differences in their results
 due to floating point calculations.
\end_layout

\begin_layout Standard
Array formulas are a powerful feature: they implement a separate evaluation
 model for formulas, and have been used to demonstrate that spreadsheets
 can model relational algebra 
\begin_inset CommandInset citation
LatexCommand citep
key "Tyszkiewicz:2010:SRD:1807167.1807191"

\end_inset

.
 Still, they are usually disregarded when discussing the semantics of spreadshee
ts, and do not feature on any of the works cited above.
 The Excel documentation is vague when explaining their evaluation logic,
 resorting to examples 
\begin_inset CommandInset citation
LatexCommand citep
key "Microsoft2016ArrayFormulas"

\end_inset

.
 In fact, in the standardization process of spreadsheet file formats, the
 complete specification of formula evaluation was a contention issue: the
 draft specification of the OASIS OpenFormula did not specify formula evaluation
, which led a Microsoft Office team member to raise issues about it 
\begin_inset CommandInset citation
LatexCommand citep
key "Jones2005formulas"

\end_inset

.
 However, Microsoft's own specification did not fully specify formula evaluation
 at the time either , and even the following draft of OpenFormula did not
 specify array formulas 
\begin_inset CommandInset citation
LatexCommand citep
key "OASIS2006OpenFormulaDraft"

\end_inset

.
 Eventually, specification of array formulas were included in both OASIS
 ODF 1.2 
\begin_inset CommandInset citation
LatexCommand citep
key "OASIS2011ODFFormula"

\end_inset

 and Microsoft Office Open XML 
\begin_inset CommandInset citation
LatexCommand citep
key "ISO29500_OfficeOpenXML"

\end_inset

, but even then the specification was informal and mostly driven by examples,
 in both documents.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="6">
<features rotate="0" tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Microsoft
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LO
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Google
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Excel
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Excel
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Calc
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sheets
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Online
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
={}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
7.6344
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
#REF!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
\bar under
={}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
=ABS({})
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
#VALUE!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
#REF!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
\bar under
=ABS({})
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A3
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
=10/{}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
7.6344
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
#VALUE!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
#REF!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
\bar under
=10/{}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
=ABS(10/{})
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
#VALUE!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
#REF!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
\bar under
=ABS(10/{})
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A5
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
=ABS(A1)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
#VALUE!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
#VALUE!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
#REF!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
#VALUE!
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
=ABS(A3)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
#VALUE!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
#VALUE!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
#REF!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
#VALUE!
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A7
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
=10/0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
#DIV/0!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
#DIV/0!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
#DIV/0!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
#DIV/0!
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
=ABS(10/0)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
#DIV/0!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
#DIV/0!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
#DIV/0!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
#DIV/0!
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A9
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
=ABS(A7)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
#DIV/0!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
#DIV/0!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
#DIV/0!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
#DIV/0!
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Empty-arrays"

\end_inset

Incompatibilities handling empty array literals
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
An interpreter modeling spreadsheet semantics
\end_layout

\begin_layout Standard
This is an interpreter designed to model the core semantics of spreadsheets,
 with a focus on the dataflow language at its core.
 Our intention here is to illustrate the various design decisions that go
 into specifying precise semantics for a spreadsheet containing a realistic
 set of features, showcasing how complexity arises from what is usually
 seen as a conceptually simple language.
 We believe that this helps to explain the number of incompatibilities between
 different implementations that we found and described in our work.
\end_layout

\begin_layout Standard
We chose to model most closely the semantics of LibreOffice, which is the
 spreadsheet for which the most detailed specification documents are available.
\end_layout

\begin_layout Standard
As in the interpreter for Pure Data, this section was also written in Literate
 Haskell, including the complete listings of the intepreter, and its source
 code in 
\family typewriter
.lhs
\family default
 format is also available at 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://hisham.hm/thesis/
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
In the same spirit of our modeling of Pure Data, we produced an executable
 model of the core semantics of spreadsheets, implemented in Haskell 
\begin_inset Foot
status open

\begin_layout Plain Layout
Available at 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/hishamhm/spreadsheet
\end_layout

\end_inset


\end_layout

\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout LyX-Code

\size footnotesize
data XlValue = XlNumber Double
\end_layout

\begin_layout LyX-Code

\size footnotesize
             | XlString String
\end_layout

\begin_layout LyX-Code

\size footnotesize
             | XlBoolean Bool
\end_layout

\begin_layout LyX-Code

\size footnotesize
             | XlError String
\end_layout

\begin_layout LyX-Code

\size footnotesize
             | XlMatrix [[XlValue]]
\end_layout

\begin_layout LyX-Code

\size footnotesize
data XlAddr = XlAbs Int
\end_layout

\begin_layout LyX-Code

\size footnotesize
            | XlRel Int
\end_layout

\begin_layout LyX-Code

\size footnotesize
data XlRC = XlRC XlAddr XlAddr
\end_layout

\begin_layout LyX-Code

\size footnotesize
data XlFormula = XlLit XlValue
\end_layout

\begin_layout LyX-Code

\size footnotesize
               | XlFun String [XlFormula]
\end_layout

\begin_layout LyX-Code

\size footnotesize
               | XlRef XlRC
\end_layout

\begin_layout LyX-Code

\size footnotesize
               | XlRng XlRC XlRC
\end_layout

\begin_layout LyX-Code

\size footnotesize
data XlCell = XlCell XlFormula
\end_layout

\begin_layout LyX-Code

\size footnotesize
            | XlAFCell XlFormula (Int, Int)
\end_layout

\begin_layout LyX-Code

\size footnotesize
type XlCells = Map.Map XlRC XlCell
\end_layout

\begin_layout LyX-Code

\size footnotesize
data XlWorksheet = XlWorksheet XlCells
\end_layout

\begin_layout LyX-Code

\size footnotesize
type XlValues = Map.Map XlRC XlValue
\end_layout

\begin_layout LyX-Code

\size footnotesize
data XlState = XlState XlCells XlValues
\end_layout

\begin_layout LyX-Code

\size footnotesize
data XlEvent = XlAddFormula XlRC XlFormula
\end_layout

\begin_layout LyX-Code

\size footnotesize
             | XlAddArrayFormula XlRC XlRC XlFormula 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Xl-Data-types"

\end_inset

Data types used in all four spreadsheet interpreters
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The approach was to model not only the initial state of a spreadsheet (producing
 the values of cells by recursively computing their formulas), but its 
\emph on
use
\emph default
 over time.
 For this, we model the spreadsheet application as an interpreter
\end_layout

\begin_layout LyX-Code
run :: XlWorksheet -> [XlEvent] -> XlState
\end_layout

\begin_layout Plain Layout
that takes as inputs an initial state and a list of events, and outputs
 the resulting state of the environment.
 The initial state is an empty spreadsheet.
 In spreadsheets, a complete document is called a 
\begin_inset Quotes eld
\end_inset

workbook
\begin_inset Quotes erd
\end_inset

, that contains one or more 
\begin_inset Quotes eld
\end_inset

worksheets
\begin_inset Quotes erd
\end_inset

; in our model, we support a single worksheet, since this does not affect
 the evaluation semantics.
 It is represented via the 
\family typewriter
XlWorksheet
\family default
 type (depicted in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Xl-Data-types"

\end_inset

).
 Events are modeled as the 
\family typewriter
XlEvent
\family default
 type, containing cell addresses (
\family typewriter
XlRC
\family default
, for 
\begin_inset Quotes eld
\end_inset

row-column
\begin_inset Quotes erd
\end_inset

) and formulas (
\family typewriter
XlFormula
\family default
), representing user interaction editing cells.
 The output is the resulting program state (
\family typewriter
XlState
\family default
): the full set of cell contents (
\family typewriter
XlCells
\family default
) and cell values (
\family typewriter
XlValues
\family default
).
 The execution of the interpreter iterates through the list of events, producing
 a new 
\family typewriter
XlState
\family default
 as each event is processed.
 The formula that is edited is updated in the map of cell contents and the
 necessary cell values are recomputed.
 Our model supports both absolute and relative references (
\family typewriter
XlAbs
\family default
 and 
\family typewriter
XlRel
\family default
), since relative cells depict the relationship between the textual language
 of formulas and their grid representation.
\end_layout

\begin_layout Plain Layout
We produced a series of incremental models of spreadsheet evaluation, ranging
 from naive models to more precise ones:
\end_layout

\begin_layout Enumerate
Basic evaluation of cells, with unspecified behavior for circular references
 and other errors
\end_layout

\begin_layout Enumerate
Interpreter 1 extended with correct semantics for circular and indirect
 references
\end_layout

\begin_layout Enumerate
Interpreter 2 extended with a form of array evaluation
\end_layout

\begin_layout Enumerate
Interpreter 3 extended with implicit iteration in array formulas
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
placement t
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout LyX-Code

\size footnotesize
 1 
\emph on
run :: XlWorksheet -> [XlEvent] -> XlState
\end_layout

\begin_layout LyX-Code

\size footnotesize
 2 run sheet@(XlWorksheet cells) events =
\end_layout

\begin_layout LyX-Code

\size footnotesize
 3    foldl' runEvent (XlState cells Map.empty) events
\end_layout

\begin_layout LyX-Code

\size footnotesize
 4    where
\end_layout

\begin_layout LyX-Code

\size footnotesize
 5       
\emph on
runEvent :: XlState -> XlEvent -> XlState
\end_layout

\begin_layout LyX-Code

\size footnotesize
 6       runEvent env@(XlState cells values) event@(XlEvent rc newCell)
 =
\end_layout

\begin_layout LyX-Code

\size footnotesize
 7          let
\end_layout

\begin_layout LyX-Code

\size footnotesize
 8             (dependencyGraph, vertList, keyToVert) =
\end_layout

\begin_layout LyX-Code

\size footnotesize
 9                graphFromEdges (cellsToNodes cells)
\end_layout

\begin_layout LyX-Code

\size footnotesize
10             
\end_layout

\begin_layout LyX-Code

\size footnotesize
11             
\emph on
dependentsGraph :: Graph
\end_layout

\begin_layout LyX-Code

\size footnotesize
12             dependentsGraph = transposeG dependencyGraph
\end_layout

\begin_layout LyX-Code

\size footnotesize
13             
\end_layout

\begin_layout LyX-Code

\size footnotesize
14             
\emph on
affectedNodes :: [Vertex]
\end_layout

\begin_layout LyX-Code

\size footnotesize
15             affectedNodes =
\end_layout

\begin_layout LyX-Code

\size footnotesize
16                case keyToVert rc of
\end_layout

\begin_layout LyX-Code

\size footnotesize
17                   Just v  -> filter (
\backslash
e -> e /= v)
\end_layout

\begin_layout LyX-Code

\size footnotesize
18                                     (reachable dependentsGraph v)
\end_layout

\begin_layout LyX-Code

\size footnotesize
19                   Nothing -> []
\end_layout

\begin_layout LyX-Code

\size footnotesize
25          in
\end_layout

\begin_layout LyX-Code

\size footnotesize
26             foldl' evalVertex
\end_layout

\begin_layout LyX-Code

\size footnotesize
27                    (XlState (insert rc newCell cells)
\end_layout

\begin_layout LyX-Code

\size footnotesize
28                           (updateValue rc cell values))
\end_layout

\begin_layout LyX-Code

\size footnotesize
29                    affectedNodes
\end_layout

\begin_layout LyX-Code

\size footnotesize
20          where
\end_layout

\begin_layout LyX-Code

\size footnotesize
21             
\emph on
evalVertex :: XlState -> Vertex -> XlState
\end_layout

\begin_layout LyX-Code

\size footnotesize
22             evalVertex env@(XlState cells values) vtx =
\end_layout

\begin_layout LyX-Code

\size footnotesize
23                let (cell, rc, _) = vertList vtx
\end_layout

\begin_layout LyX-Code

\size footnotesize
24                in  XlState cells (updateValue rc cell values)
\end_layout

\begin_layout LyX-Code

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Xl1-Evaluation-loop"

\end_inset

Evaluation loop of Interpreter 1
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Interpreter 1 is similar to the semantics commonly presented in works from
 the literature that model spreadsheets 
\begin_inset CommandInset citation
LatexCommand citep
key "Abraham:2006:TIS:1140335.1140346,Cunha:2009:SRD:1480945.1480972"

\end_inset

.
 It is a simple interpreter of cell expressions which follows references
 to other cells recursively.
 Circular references are not detected: a loop in the spreadsheet results
 in a loop in the interpreter.
 There is no support for indirect references, such as those produced by
 the 
\family typewriter
INDIRECT
\family default
 function: for this reason, the evaluation graph of the spreadsheet can
 be derived entirely from its cell contents, with no need to inspect the
 calculated cell values.
 Reflecting this, as illustrated in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Xl1-Evaluation-loop"

\end_inset

, the evaluation for an event produces a dependency graph (lines 8-9) from
 the spreadsheet cell contents, transposes this graph into a dependents
 graph (that is, for each cell, which cells depend on this one; lines 11-12),
 and then recursively traverses this graph producing a list of cells that
 should be reevaluated (lines 14-19).
 This list is iterated (lines 26-29), producing a new state at each step
 which contains the updated value of the evaluated cell (lines 21-24).
\end_layout

\begin_layout Plain Layout
Since each event represents a change of cell contents made by the user,
 note that the main iteration through the event list (line 3) causes a recalcula
tion of the dependency graph et each new event.
 Still, in this interpreter the dependency graph remains static as the cell
 references are traversed.
 This is not a valid model of how a spreadsheet works in face of indirect
 references.
 For this reason, Intepreter 2 uses a different evaluation model.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
placement t
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout LyX-Code

\size footnotesize
 1 
\emph on
evalFormula :: Set XlRC -> XlCells -> XlValues -> XlRC -> XlFormula
\end_layout

\begin_layout LyX-Code

\size footnotesize
 2 
\emph on
               -> (XlValue, XlValues)
\end_layout

\begin_layout LyX-Code

\size footnotesize
 3 evalFormula visited cells values fc formula = ...
\end_layout

\begin_layout LyX-Code

\size footnotesize
 4
\end_layout

\begin_layout LyX-Code

\size footnotesize
 5 
\emph on
updateValue :: XlCells -> XlValues -> XlRC -> XlCell -> XlValues 
\end_layout

\begin_layout LyX-Code

\size footnotesize
 6 updateValue cells values rc (XlCell formula) =
\end_layout

\begin_layout LyX-Code

\size footnotesize
 7    snd $ evalFormula Set.empty cells values rc formula 
\end_layout

\begin_layout LyX-Code

\size footnotesize
 8
\end_layout

\begin_layout LyX-Code

\size footnotesize
 9 
\emph on
run :: XlWorksheet -> [XlEvent] -> XlState
\end_layout

\begin_layout LyX-Code

\size footnotesize
10 run sheet@(XlWorksheet cells) events =
\end_layout

\begin_layout LyX-Code

\size footnotesize
11    foldl' runEvent (XlState cells Map.empty) events
\end_layout

\begin_layout LyX-Code

\size footnotesize
12    where
\end_layout

\begin_layout LyX-Code

\size footnotesize
13       
\emph on
runEvent :: XlState -> XlEvent -> XlState
\end_layout

\begin_layout LyX-Code

\size footnotesize
14       runEvent env@(XlState cells _) event@(XlEvent rc newCell) =
\end_layout

\begin_layout LyX-Code

\size footnotesize
15          let 
\end_layout

\begin_layout LyX-Code

\size footnotesize
16             newCells = Map.insert rc newCell cells
\end_layout

\begin_layout LyX-Code

\size footnotesize
17             
\end_layout

\begin_layout LyX-Code

\size footnotesize
18             
\emph on
acc :: XlRC -> XlCell -> XlValues -> XlValues
\end_layout

\begin_layout LyX-Code

\size footnotesize
19             acc rc cell values =
\end_layout

\begin_layout LyX-Code

\size footnotesize
20                if Map.member rc values
\end_layout

\begin_layout LyX-Code

\size footnotesize
21                then values
\end_layout

\begin_layout LyX-Code

\size footnotesize
22                else updateValue newCells values rc cell
\end_layout

\begin_layout LyX-Code

\size footnotesize
23          in
\end_layout

\begin_layout LyX-Code

\size footnotesize
24             XlState newCells (Map.foldrWithKey acc Map.empty newCells)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Xl2-Evaluation-loop"

\end_inset

Evaluation loop of Interpreter 2
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Xl2-Evaluation-loop"

\end_inset

 illustrates the evaluation engine of Interpreter 2.
 Again, the run function iterates over the list of events (line 11), but
 this time, 
\family typewriter
runEvent
\family default
 produces a new state by iterating over all non-empty cells on each step,
 using a fold operation (line 24).
 The 
\begin_inset Quotes eld
\end_inset

accumulator
\begin_inset Quotes erd
\end_inset

 function of this fold operation (lines 18-22) first checks if a value was
 already produced for this cell during this step (via a previous recursive
 evaluation of another cell); if it was not already calculated, it calls
 
\family typewriter
updateValue
\family default
 (defined in lines 5-7).
 This function starts a new recursive evaluation step of formulas, calling
 
\family typewriter
evalFormula
\family default
 (outlined in lines 1-3; its implementation includes cases for each data
 type and function supported).
 Note that 
\family typewriter
evalFormula
\family default
 includes a 
\family typewriter
visited
\family default
 argument of type 
\family typewriter
Set XlRC
\family default
: this is populated as 
\family typewriter
evalFormula
\family default
 recurses, to detect evaluation loops.
\end_layout

\begin_layout Plain Layout
This model recalculates the entire spreadsheet on each edit.
 This is not a realistic representation of what a spreadsheet application
 would do, performance-wise, but since all formulas in our model are pure,
 it produces the same cell values that a more efficient implementation would
 produce.
 We are concerned here with the resulting state produced in each step, which
 is the user-visible results of the execution.
 It is important to note, however, that actual spreadsheet applications
 do include side-effecting functions: for example, they can call functions
 implemented in imperative scripting languages.
 Also, a function like 
\family typewriter
RAND()
\family default
 produces a new value each time it is evaluated.
 Rules for reevaluation in different implementations seem arbitrary.
 In LibreOffice and Excel Online, for example, any cell containing a 
\family typewriter
RAND()
\family default
 call is re-evaluated each time any other cell is edited, even if unrelated
 or when the edit operation maintains the same cell contents.
 Google Sheets has a slightly different behavior: if the edited cell contains
 a formula and the edit operation maintains the same cell contents, it does
 not trigger a reevaluation; if editing a cell with an immediate value,
 it always triggers a recalculation.
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO Verify that it's the same in Excel.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Interpreter 3 is our first approach at implementing array evaluation.
 We extend the previous model by adding a second cell type, 
\family typewriter
XlAFCell
\family default
, which represents a formula marked for array evaluation by pressing Ctrl+Shift+
Enter.
 In spreadsheets, a single array formula can occupy a number of cells: the
 user can select a rectangular cell group when entering the formula, and
 if the result of the calculation is a matrix, the values of its elements
 will be distributed across the positions of the range, according to the
 rules described in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Array-formulas"

\end_inset

.
 For this reason, 
\family typewriter
XAFCell
\family default
 is defined as containing a 
\family typewriter
XlFormula
\family default
 and a pair of integers, representing the size in rows and columns of its
 cell group (see Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Xl-Data-types"

\end_inset

).
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: Further specify the evaluation rules, based on the model.
\end_layout

\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: 
\end_layout

\end_inset

All examples in the OASIS specification pass in Interpreter 3; examples
 in the ISO specification fail, require Interpreter 4.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: Explain how model 4 is different from model 3
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
While implementing the third and fourth interpreters, we identified that
 the semantics of array evaluation are different in Excel and LibreOffice.
 
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: 
\end_layout

\end_inset

Weirdness in Excel specification (both modes produce same result)
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: Note Excel examples that fail in LibreOffice
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: Subtleties in the semantics: evaluation of ranges by intersection
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: Array formulas are a first-class concept in the language but a second-clas
s citizen in the UI: dragging extends a formula over an array of cells;
 why doesn't it produce an array formula? Copying and pasting is 
\begin_inset Quotes eld
\end_inset

more general
\begin_inset Quotes erd
\end_inset

 [pick example from estimates spreadsheet].
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
input{XlInterpreter_text.tex}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Demonstration
\end_layout

\begin_layout Standard
In Appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "appendix:Spreadsheet"

\end_inset

 we present a demonstration of use of this interpreter, showcasing its features.
 We also produced a series of tests that correspond to sections of the OpenDocum
ent specification for the 
\family typewriter
.ods
\family default
 format 
\begin_inset CommandInset citation
LatexCommand citep
key "OASIS2011ODFFormula"

\end_inset

 and the ISO Open Office XML specification for the 
\family typewriter
.xlsx
\family default
 format 
\begin_inset CommandInset citation
LatexCommand citep
key "ISO29500_OfficeOpenXML"

\end_inset

, as well as our own additional tests that cover some unspecified behavior.
\end_layout

\begin_layout Section
Discussion: Language specification and compatibility issues
\end_layout

\begin_layout Standard
One might argue that the various language issues present in formula languages
 discussed in this chapter are due to specification blunders early in the
 history of spreadsheets, forever preserved in the name of backwards compatibili
ty.
 But the insufficient concern with precise semantics of spreadsheets is
 not only historical, as it manifests itself in compatibility issues between
 modern variants, even by the same vendor.
 Further, when evaluating the compatibility of various spreadsheet implementatio
ns we need to define what is meant by compatibility.
 When looking at spreadsheets as 
\emph on
documents
\emph default
, one tends to think about 
\begin_inset Quotes eld
\end_inset

file format compatibility
\begin_inset Quotes erd
\end_inset

: an application should be able to load a file and render it correctly.
 This definition of compatibility is insufficient, as it does not account
 the dynamic semantics of the language: how the state of the program changes
 over time as the program executes.
 When one looks at a spreadsheet as an 
\emph on
interactive program
\emph default
, then the newly-loaded document defines the initial state of the program
 and further edits to cells are inputs that cause state updates.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="6">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Microsoft
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LO
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Google
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Excel
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Excel
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Excel
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Calc
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sheets
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Online
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mobile
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
Err:522
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
#REF!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
100
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
Err:522
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
#REF!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size small
0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
error dialog
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
no
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
yes
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Circular-references"

\end_inset

Behavior upon circular references, after the following sequence: B1 to 100,
 A1 to =B1, B1 to =A1
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Compatible languages should have equivalent dynamic semantics.
 Under this definition, Excel, Excel Online and mobile Excel, all three
 by Microsoft, are not compatible: there are identical sequences of formula
 edits that one can perform over the same spreadsheet which lead to different
 results in each program.
 In other words, the dynamic semantics of their formula languages differ.
 Case in point, all three variants of Excel have different behavior in face
 of circular references.
 In desktop and mobile Excel, the application pops a dialog warning the
 user about the circular references; in the web-based version no such warning
 is present.
 More important, however, is the difference in produced values: when a user
 produces a loop between two cells in desktop Excel, both cells instantly
 produce error values; in Excel Online and mobile Excel, the most recently
 updated cell produces the value zero and the other one retains its previous
 value.
 That such a striking difference in behavior has made it to production seems
 to show that the UI was not treated as a well-defined language whose behavior
 was meant to be duplicated.
 While care has certainly been taken to ensure that Excel Online and mobile
 have good compatibility with Excel, apparently this was taken to mean only
 that they should load Excel files and produces identical 
\emph on
initial
\emph default
 results.
 The behavior of Excel Online is especially worrying, as circular references
 produce invalid values silently.
\end_layout

\begin_layout Chapter
Case study: LabVIEW
\begin_inset CommandInset label
LatexCommand label
name "chap:LabVIEW"

\end_inset


\end_layout

\begin_layout Standard
LabVIEW
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://ni.com/labview/
\end_layout

\end_inset


\end_layout

\end_inset

 is a commercial tool for data acquisition, instrument control and industrial
 automation, developed by National Instruments.
 It is a proprietary commercial application, with extensive support for
 typical engineering domains such as digital signal processing.
 The application consists of a graphical programming environment, including
 a large amount of bundled functionality for data acquisition, as well as
 support for hardware also produced by its vendor.
 LabVIEW programs can be compiled and deployed stand-alone, depending only
 on a runtime package.
 LabVIEW is noted as a major success story of a visual programming language
 in the industry 
\begin_inset CommandInset citation
LatexCommand citep
key "Johnston:2004:ADP:1013208.1013209"

\end_inset

.
 In it, program code is represented as a set of graphical diagrams.
\end_layout

\begin_layout Standard
The programming language of the LabVIEW environment is called G.
 However, since there are no other implementations of G or any specification
 other than the implementation of LabVIEW itself, it is customary to refer
 to the language as LabVIEW or use both names interchangeably 
\begin_inset CommandInset citation
LatexCommand cite
key "Kaufmann:2009:FVL:1637837.1637851,Mok1998RTLLabVIEW"

\end_inset

; for simplicity, we will call the both the application and its language
 LabVIEW throughout the text.
\end_layout

\begin_layout Section
Overview of the language
\end_layout

\begin_layout Standard
In LabVIEW, programs are called 
\emph on
virtual instruments
\emph default
 (VIs), as their interfaces mimic laboratory instruments, with buttons,
 scopes and gauges.
 This is a clear nod to its application domain, since the developer of the
 tool is also a vendor of physical hardware instruments.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename labview_windows.png
	width 95col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:LabVIEW-windows"

\end_inset

The main interface of LabVIEW.
 Each virtual instrument appears in two windows: the front panel (left)
 and the block diagram (right).
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As depicted in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:LabVIEW-windows"

\end_inset

, each VI has always two parts:
\end_layout

\begin_layout Itemize
the 
\emph on
front panel
\emph default
, which is the user program's interface.
 It contains elements that provide inputs and outputs to the program, presented
 as graphical widgets for interaction or visualization.
\end_layout

\begin_layout Itemize
the 
\emph on
block diagram
\emph default
, which is the dataflow graph.
 It contains all elements that are present in the front panel (this time
 in iconic mode) as well as any additional nodes which represent functions
 to be applied to data, effectively constructing the program.
\end_layout

\begin_layout Standard
All widgets included in the front panel are either input elements, called
 
\emph on
controls
\emph default
 in LabVIEW, or output elements, called 
\emph on
indicators
\emph default
.
 This dichotomy leads to a much simpler model for UI programming, as opposed
 to typical GUI frameworks where one needs to implement handlers to various
 events that read-write widgets may produce.
 Indicators appear as write-only nodes in the block diagram and read-only
 widgets in the front panel; contrariwise, controls appear as data-entry
 widgets in the front panel that are read-only nodes in the block diagram.
\end_layout

\begin_layout Standard
When running a program inside the LabVIEW environment, the block diagram
 is still visible when running, but it is read-only.
 At runtime, the interaction with the block diagram is limited.
 It can only be decorated with temporary probes for debugging purposes,
 attached to wires.
 When a LabVIEW program is compiled and deployed, only the front panel is
 visible.
\end_layout

\begin_layout Standard
It is possible to update control values from the block diagram using more
 advanced features of the language that are less evident in its UI, but
 the environment is conducive to a simpler input/output discipline which
 presents data flowing from controls, to the block diagram, and finally
 to indicators.
\end_layout

\begin_layout Subsection
Execution modes
\begin_inset CommandInset label
LatexCommand label
name "sub:LabVIEW-execution-modes"

\end_inset


\end_layout

\begin_layout Standard
There are two modes of execution, which can be launched, respectively, by
 the first two icons in the toolbars depicted in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:LabVIEW-windows"

\end_inset

.
 In the LabVIEW UI they are simply called 
\begin_inset Quotes eld
\end_inset

Run
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

Run continuously
\begin_inset Quotes erd
\end_inset

.
 We will therefore call these modes 
\emph on
single-shot
\emph default
 and 
\emph on
continuous
\emph default
.
\end_layout

\begin_layout Standard
In single-shot mode, all controls and nodes that do not depend on other
 objects are fired, and execution continue while there are values to be
 propagated.
 If all values propagate to the appropriate indicators, their values are
 updated in the UI and the execution halts, bringing LabVIEW back to edit
 mode.
 However, if a diagram contains an infinite loop, for example, the program
 will run forever.
 Since controls are only fired at the beginning of execution, further inputs
 entered by the user while a single-shot execution runs have no effect on
 that execution.
 Controls and indicators retain their last values.
\end_layout

\begin_layout Standard
Continuous mode is equivalent to enclosing the entire program in an infinite
 loop and firing controls on each iteration.
 Each iteration of this continuous run is equivalent to one single-shot
 execution: all controls are fired, and the graph evaluation essentially
 restarts on each step, except that two kinds of objects, shift registers
 and feedback nodes, also retain their values from iteration to iteration.
 These two objects, which we will describe in detail in the next section,
 are the only nodes that can represent cyclic connections in the graph.
 In effect, single-shot execution is acyclic, and cycles can only propagate
 values from one iteration of a graph (or subgraph) to the next.
\end_layout

\begin_layout Standard
The fact that cycles only happen across iterations combined with the restriction
 that only one wire can be connected to an input port means that at most
 one value will arrive at an input port during an iteration.
 This characterizes a static dataflow model, for which no buffers are necessary
 in input ports.
 This greatly simplifies scheduling and memory management: it is not possible
 to produce a stack overflow through an execution cycle, or a buffer overflow
 in nodes (for there are no buffers).
 As we will see below, however, the presencel of aggregate data types brings
 back concerns about memory management.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO controls take effect only when fired, so long-running graphs lead to
 unresponsive applications.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Looping and cycles
\end_layout

\begin_layout Standard
From the end-user's perspective, LabVIEW programs are graphs that can contain
 cycles, but these are controlled via the use of explicit 
\emph on
feedback nodes
\emph default
 and structured looping constructs.
\end_layout

\begin_layout Standard
The LabVIEW UI enforces that the only connections producing explicit cycles
 in a graph are those connecting feedback nodes: wiring any two objects
 in the graph producing a cycle automatically inserts a feedback node between
 them.
 This feedback node exists solely to store the value in between executions
 of the graph.
\end_layout

\begin_layout Standard
Structured looping constructs are available, mirroring those available in
 traditional textual languages.
 The 
\begin_inset Quotes eld
\end_inset

for-loop
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

while-loop
\begin_inset Quotes erd
\end_inset

 constructs act as their familiar equivalents (with the distinction that
 the 
\begin_inset Quotes eld
\end_inset

while
\begin_inset Quotes erd
\end_inset

 structure always runs at least once, like a 
\begin_inset Quotes eld
\end_inset

do-while
\begin_inset Quotes erd
\end_inset

 construct).
 In both cases, the looping construct appears in the UI as a frame inside
 the graph.
 This frame encloses a subgraph and controls its iteration.
 The subgraph may produce one or more values that are sent out as the iteration
 completes.
\end_layout

\begin_layout Standard
Values may also be sent from one iteration of the loop to the next through
 the use of 
\emph on
shift registers
\emph default
.
 A shift register appears as a pair of small nodes at the edges of the loop
 frame: one incoming connector at the right and one outgoing connector at
 the left.
 This is conceptually similar to how textual detaflow languages like Lucid
 allow iteration, with 
\family typewriter
x
\family default
 and 
\family typewriter
\series bold
next
\series default
 x
\family default
 holding distinct values.
 The presence of a shift register denotes an implicit cycle in the graph.
\end_layout

\begin_layout Standard
In short, feedback nodes are constructs for sending data through iterations
 of the main graph when in continuous mode, and shift registers are constructs
 for sending data through iterations of a loop subgraph.
 It is notable that while functionally very similar, they have very different
 representations in the UI.
\end_layout

\begin_layout Subsection
Data types and wires
\end_layout

\begin_layout Standard
The language features primitive and structured data types.
 It supports a large number of primitive basic types: 8, 16, 32 and 64 bit
 integers; fixed-point, floating-point and complex numbers of various sizes.
 For structured data, LabVIEW includes single and multi-dimensional arrays,
 as well as record types called 
\emph on
clusters
\emph default
.
\end_layout

\begin_layout Standard
Controls, nodes and indicators are connected through 
\emph on
wires
\emph default
, which is how edges in the dataflow graph are called.
 Apart from a special 
\begin_inset Quotes eld
\end_inset

dynamic
\begin_inset Quotes erd
\end_inset

 wire which sees limited use in LabVIEW as it demands special conversions,
 wires are in general statically typed: each wire has a data type assigned
 to it.
 In the UI, the color, thickness and stripe pattern of the wire indicates
 its type: the color represents the base type (integer, floating point,
 array, cluster), the thickness represents data dimensions (scalar, single
 or multidimensional array) and additional styling such as stripe patterns
 are used for particular types, such as waveforms and errors, which are
 just predefinitions for particular cluster types.
 For example, a waveform is a cluster containing on array of data points,
 a numeric timestamp and a numeric interval value between data samples.
 Error data flows as a cluster of three values: a boolean indicator an error
 condition, a 32-bit integer with the error code, and a string containing
 source information.
 
\end_layout

\begin_layout Standard
Not all types can be visually distinguished in the interface.
 Apart from the especially predefined clusters like waveform and error,
 all user-defined cluster types look alike.
 For these wires, the contextual help window serves as a useful aid, describing
 the complete type of the wire under the mouse cursor.
\end_layout

\begin_layout Standard
Structured data such as arrays and clusters still flow as a single dataflow
 packet: the transfer of a whole array between two nodes happens as a single
 firing through an array-typed wire.
\begin_inset Note Note
status open

\begin_layout Plain Layout
cite here dataflow paper that talks of the difficulty of dealing with structured
 data
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Some types support automatic coercions.
 For example, it is possible to connect an integer output port to a floating-poi
nt input port.
 The resulting wire has integer type: coercion happens at the input edge
 of the wire.
\end_layout

\begin_layout Subsection
Timing
\end_layout

\begin_layout Standard
LabVIEW offers two wait functions: 
\begin_inset Quotes eld
\end_inset

Wait Until Next ms Multiple
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

Wait
\begin_inset Quotes erd
\end_inset

.
 The former monitors a millisecond counter and waits until it reaches the
 specified multiple of a given number, controlling the loop execution rate
 by holding back the loop step.
 This is designed for synchronizing loops, typically when performing device
 reads and outputs to indicators in the interface.
 Note that the given multiple may happen right after the loop starts, so
 the delay for the first iteration of the loop is indeterminate.
 The latter function, 
\begin_inset Quotes eld
\end_inset

Wait
\begin_inset Quotes erd
\end_inset

, always waits the specified amount of time, effectively adding a pause
 of constant size between steps of the loop.
\end_layout

\begin_layout Standard
The firing of a wait node inside a loop construct holds back the next step
 of the loop, effectively controlling the execution rate, assuming the rest
 of the code in the loop takes less time to execute than the configured
 delay.
 When multiple parallel loops exist in the graph, using 
\begin_inset Quotes eld
\end_inset

Wait Until Next ms Multiple
\begin_inset Quotes erd
\end_inset

 allows one to synchronize them to millisecond precision, which is often
 good enough for the domain of data acquisition hardware.
 It is amusing to note that the icon for 
\begin_inset Quotes eld
\end_inset

Wait Until Next ms Multiple
\begin_inset Quotes erd
\end_inset

 is a metronome, a device for counting tempo in music; in Pure Data, the
 function for generating periodic messages is called 
\family typewriter
metro
\family default
, referencing the same device.
 The image of the metronome reinforces the idea of 
\begin_inset Quotes eld
\end_inset

orchestration
\begin_inset Quotes erd
\end_inset

 between parallel agents.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Todo: add forced example without sequencing, then show it with sequencing.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Semantics
\end_layout

\begin_layout Standard
A difficulty in discussing the semantics of LabVIEW is that is has no published
 specification.
 Its documentation often resorts to examples to explain concepts, and does
 not serve an an exhaustive specification of the language.
 Previous attempts on the formalization of LabVIEW have been restricted
 to subsets of the language, and based themselves on its user manual and
 experimenting with the tool itself.
 In 
\begin_inset CommandInset citation
LatexCommand citep
key "Mok1998RTLLabVIEW"

\end_inset

, Mok and Stuart map a subset of the language to RTL (real-time logic),
 a first-order logic used for describing real-time and embedded systems;
 they note that design decisions had to be made in points where the precise
 behavior was not clear.
 In 
\begin_inset CommandInset citation
LatexCommand citep
key "Kaufmann:2009:FVL:1637837.1637851"

\end_inset

, Kaufmann et al.
 map a purely functional subset of LabVIEW into a dialect of Common Lisp
 used by the ACL2 theorem prover.
\end_layout

\begin_layout Standard
In developing a model of LabVIEW's semantics, we are particularly interested
 about modularity issues and management of state.
 In our modeling, we aim to go beyond the functional subset, including the
 relationship between VIs and global variables.
 Like previous work in the literature, we aim to design the model based
 on LabVIEW's documentation and experimentation with the tool itself.
\end_layout

\begin_layout Standard
Types:
\end_layout

\begin_layout Standard
While LabVIEW supports arrays of clusters, and clusters of arrays, it does
 not support arrays of arrays.
 The recommended alternative is to use an 
\begin_inset Quotes eld
\end_inset

array of cluster of array
\begin_inset Quotes erd
\end_inset

: an array where elements are single-element clusters containing an array.
 This limitation is an explicit design decision, harking back to the development
 of LabVIEW 2.0 in 1988
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://forums.ni.com/t5/LabVIEW-Idea-Exchange/Add-Support-for-Array-of-Array/idi-
p/1875123
\end_layout

\end_inset


\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
concerns with excessive array copying
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
new material:
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: 
\end_layout

\end_inset

Tunnels.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename labview_loops_and_tunnels.png
	scale 75

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Loops-and-tunnels-LabVIEW"

\end_inset

Interaction of loops and tunnels in LabVIEW.
 Loop A never updates its output; Loop B updates only at the end; Loop C
 updates every second.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
When using tunnels to send values into or out of loop structures, the values
 are transferred only at the beginning or at the end of the execution of
 the loop.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Loops-and-tunnels-LabVIEW"

\end_inset

 illustrates the behavior of input and output tunnels in loops.
 We have three while-loops in which the termination condition is connected
 to a boolean button, the iteration counter is connected to a numeric indicator,
 and the loop timing is controlled to execute one iteration per 1000
\begin_inset space ~
\end_inset

ms.
 In Loop A, both the inputs and outputs are connected through tunnels.
 The end result is that the termination value becomes fixed in the loop
 as the value of Boolean A goes through the tunnel.
 If the value of Boolean A at the beginning of execution is true, the loop
 runs for only one iteration and 0 is sent to Indicator A.
 If Boolean A is false at the beginning of execution, the loop never stops,
 and clicking the button has no effect.
 In Loop B, Boolean B is inside the loop, so its value is sent to the conditiona
l terminal on each iteration.
 The loop stops once Boolean B is set to true, and only then the iteration
 value is sent via the output tunnel to Indicator B.
 In Loop C, the interface displays Indicator C being updated once a second
 as long as Boolean C is false.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename labview_connection_errors.png
	scale 75

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Connection-errors-LabVIEW"

\end_inset

Connection errors in LabVIEW.
 Connecting two data sources (A1 and A2) directly to an input (A3) produces
 a helpful error message.
 If one of the connections goes through a tunnel, however (B2), this produces
 a tunnel direction inference error.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Because the direction of tunnels is inferred, incorrect connections involving
 tunnels produce less useful messages than similar connections not going
 through a tunnel.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Connection-errors-LabVIEW"

\end_inset

 illustrates how tunnel inference affects error messages.
 When one connects two controls (A1 and A2) to an indicator (A3), this produces
 one error message that says 
\begin_inset Quotes eld
\end_inset

a wire can be connected to only one data source
\begin_inset Quotes erd
\end_inset

.
 When one attempts a similar connection (B1 and B2 to B3), but one of these
 data sources (B2) goes through a tunnel, this produces three identical
 error messages that say 
\begin_inset Quotes eld
\end_inset

wire connected to an undirected tunnel: a tunnel on this wire cannot determine
 whether it is an input or an output
\begin_inset Quotes erd
\end_inset

.
 This is typical of error messages involving inference: the inference engine
 of the language detects that a unification was not possible, but cannot
 tell which one of the two mismatching elements is the incorrect one.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: 
\end_layout

\end_inset

Three of the new plug-ins introduced in LabVIEW 2015 were suggested by users
 of the vendor's discussion forums: all three of them dealt with array types:
 Change to Array or Element, Size Array Constants to Contents, Transpose
 2D Array.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: 
\end_layout

\end_inset

LabVIEW 2015 also introduced a palette with Data Type Parsing controls,
 for introspecting type information of dynamically-typed data.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: 
\end_layout

\end_inset

LabVIEW 2016 introduced Channel Wires (previewed as an 
\begin_inset Quotes eld
\end_inset

unofficial feature
\begin_inset Quotes erd
\end_inset

 in LabVIEW 2015).
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: 
\end_layout

\end_inset

Feedback nodes, direction, Z-Transform feedback nodes
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: 
\end_layout

\end_inset

Program reuse can be achieved encapsulating sub-graphs into sub-VIs.
 LabVIEW supports running several VIs simultaneously, and it provides a
 form of global variables as a means to transfer data between them.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: 
\end_layout

\end_inset

 XNodes and recursion
\end_layout

\begin_layout Section
An interpreter modeling the semantics of LabVIEW
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
input{LvInterpreter_text.tex}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Demonstration
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO explain that we produce an animation of the graph
\end_layout

\end_inset


\end_layout

\begin_layout Section
Discussion: Is LabVIEW end-user programming?
\end_layout

\begin_layout Standard
When we discuss end-user programming, what defines the concept is not a
 particular programming paradigm, set of constructs of UI style.
 End-user programming is about the fact that the person doing the programming
 is the one who will use the resulting program, and, as a secundary point,
 that they are not programmers by profession.
 That is indeed not always the case in LabVIEW, which is indeed used by
 professional programmers who build, compile and deploy programs for other
 end-users.
\end_layout

\begin_layout Standard
However, two aspects warrant its presence in the discussion on end-user
 programming languages taking place in this work.
 First, although it is used as a traditional programming language by software
 professionals, LabVIEW is also heavily used by end-users in engineering
 and physics fields, and the design of the language is heavily informed
 by this fact.
 One might even argue that the language is better suited to small-scale
 rapid end-user programming than to large-scale software development.
 Second, it a particularly interesting subject in the design space of end-user
 programming because it is developed as a programming environment for writing
 data acquisition programs rather than a programmable data acquisition applicati
on.
 This has effects in the design of the resulting language.
 A good way to observe these effects is by contrasting LabVIEW and Pure
 Data.
\end_layout

\begin_layout Subsection
LabVIEW and Pure Data compared
\begin_inset CommandInset label
LatexCommand label
name "sub:LabVIEW-and-PD"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
both have context help windows
\end_layout

\end_inset


\end_layout

\begin_layout Standard
While both LabVIEW and Pure Data are visual dataflow languages that present
 programs as graph diagrams connecting node objects, the LabVIEW environment
 is a lot more similar to that of a typical programming language IDE.
 Beyond the visual presentation, a fundamental difference is that in LabVIEW
 the block diagram with the graph and front panel with the UI widgets are
 the 
\begin_inset Quotes eld
\end_inset

source code
\begin_inset Quotes erd
\end_inset

 of the program, which can then be executed, presenting the UI windows which
 are the 
\begin_inset Quotes eld
\end_inset

program
\begin_inset Quotes erd
\end_inset

 to be used.
 In Pure Data, there is no such distinction: the graph is the 
\begin_inset Quotes eld
\end_inset

document
\begin_inset Quotes erd
\end_inset

, which is edited in 
\begin_inset Quotes eld
\end_inset

edit mode
\begin_inset Quotes erd
\end_inset

 as the programming takes place, and which is later manipulated in 
\begin_inset Quotes eld
\end_inset

run mode
\begin_inset Quotes erd
\end_inset

 as the music is produced.
 This means both applications have two modes of operation—in LabVIEW, execution
 is toggled with the 
\begin_inset Quotes eld
\end_inset

play
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

stop
\begin_inset Quotes erd
\end_inset

 buttons of the UI.
 However, in Pure Data there is no distinction between what is being edited
 during creation and the end result; not only the interface is the same:
 most importantly, the DSP engine remains running while in 
\begin_inset Quotes eld
\end_inset

edit mode
\begin_inset Quotes erd
\end_inset

, so a musician can transition between these two modes during a performance.
 Recall that even while in 
\begin_inset Quotes eld
\end_inset

edit mode
\begin_inset Quotes erd
\end_inset

 the dataflow program is still running.
\end_layout

\begin_layout Standard
In Pure Data's 
\begin_inset Quotes eld
\end_inset

run mode
\begin_inset Quotes erd
\end_inset

, interaction happens via manipulation of values directly in the graph nodes
 or by clicking nodes to trigger messages: the program structure is transparent.
 While it is possible to hide the graph structure in Pure Data through the
 use of subprograms and indirect messages, the environment does not lead
 the user in this direction; it is more natural to present the graph, and
 it helps understanding the effect of editing values.
 This visibility is common practice in the field: some hardware synthesizers
 even include in their chassis drawings of their high-level audio flow diagrams,
 to help the musician make sense of how the various buttons relate to each
 other in the overall synthesis.
\end_layout

\begin_layout Standard
When running a LabVIEW program, there is no way to affect the program itself
 by interacting with the graph during execution.
 The only form of interaction allowed is via the front panel or other attached
 inputs (such as hardware instruments).
 When a LabVIEW program is compiled and deployed, the graph is not even
 visible, let alone editable by the user.
 A deployed LabVIEW program, therefore, is not itself end-user programmable.
\end_layout

\begin_layout Standard
In Pure Data, the user of the program and the developer are often the same:
 a computer musician programming audio synthesis and sequencing.
 Even when that is not the case—and there are communities where Pure Data
 programs are shared—the explicit nature of the graph structure invites
 users to tweak the patches to their liking, producing their own sounds.
\end_layout

\begin_layout Standard
This would lead us to conclude that Pure Data has a stronger focus on end-users,
 and by catering also to a professional audience, LabVIEW would be more
 difficult for newcomers.
 However, by including features common to typical professional programming
 environments, such as a clearer distinction between types and error messages
 targeting at the specific points of failure, LabVIEW makes it actually
 easier to understand problems in the dataflow graph than Pure Data.
\end_layout

\begin_layout Standard
Language features such as (auto-generated) feedback nodes make it easier
 to understand and debug cycle constructs; data coercion nodes (also auto-generc
ated) make explicit any precision loss—a problem that also affects musicians
 using Pure Data, where it is perceived as degraded audio quality.
 
\end_layout

\begin_layout Standard
Both Pure Data and LabVIEW feature multiple types, including numbers, strings
 and table objects holding aggregated data.
 LabVIEW has a richer set of types, and is statically typed; Pure Data has
 a simpler one, and is dynamically typed.
 Both of them make a visual distinction among edge types in the graph: Pure
 Data displays audio connections as thicker lines and message connections
 as thinner lines; LabVIEW uses colors, thickness and stripe patterns to
 indicate the various data types it supports.
 It is easy to make an invalid connection in Pure Data, for example connecting
 a string outlet to a float inlet, which will cause a runtime error being
 logged.
 In LabVIEW, the mismatch is caught as the user tries to make the connection;
 if the data is coercible, a conversion node is automatically inserted.
\end_layout

\begin_layout Standard
Through a combination of language and environment features, LabVIEW happens
 to be an easier language to program for, even though engineers typically
 have more formal training in programming-related fields than musicians.
 Still, a large community of musicians thrives using software such as Pure
 Data (and its proprietary relative Max/MSP) even without the facilities
 that professional programmers have grown used to.
 This shows us that the abilities of end-users should not be underestimated,
 and invites us to consider how much those end-users could benefit if the
 languages they work on incorporated more from established programming language
 design practices.
\end_layout

\begin_layout Chapter
Some other languages
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO chapter intro
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Other applications considered were: Grasshopper (3D modeling); Nuke (video
 editing); Blueprints, (game scripting); Natron, (video compositing); vvvv
 (multimedia).
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO referências
\end_layout

\end_inset


\end_layout

\begin_layout Section
Reaktor
\end_layout

\begin_layout Standard
Reaktor is a commercial application by Native Instruments for constructing
 synthesizers, which can be used either stand-alone or as plugins for different
 music applications.
 The interface has separate Edit and Play modes, and separate Panel Layouts
 with the input and output widgets for interaction, and a Structure View
 with the dataflow graph for editing.
 It supports abstracting sub-graphs into units.
 A program is presented as an 
\begin_inset Quotes eld
\end_inset

instrument
\begin_inset Quotes erd
\end_inset

, which acts as a synthesizer or an effects unit, often with a front-end
 interface that mimics equivalent hardware.
 Instruments are created using 
\begin_inset Quotes eld
\end_inset

modules
\begin_inset Quotes erd
\end_inset

, that are high-level operators, combined into 
\begin_inset Quotes eld
\end_inset

macros
\begin_inset Quotes erd
\end_inset

 in a dataflow language called the Primary mode.
 The modules themselves are also written as graphs composed of 
\begin_inset Quotes eld
\end_inset

core cells
\begin_inset Quotes erd
\end_inset

, in a distinct environment called Core mode.
\end_layout

\begin_layout Standard
Like Pure Data, Reaktor's Primary mode has two types of wires: audio and
 event wires.
 Further, modules may be monophonic or polyphonic.
 Connecting a polyphonic module to a monophonic module flags a type error,
 marking the wire in red.
 A 
\begin_inset Quotes eld
\end_inset

voice combiner
\begin_inset Quotes erd
\end_inset

 module can be used to mix down a polyphonic signal into a monophonic one.
 Only one wire can be connected to a port, but some modules such as the
 Multiply operation are variadic, allowing more input ports to be created
 as needed.
 The order through which audio is processed is deterministic, and the UI
 has a 
\begin_inset Quotes eld
\end_inset

Module Sorting Debug Tool
\begin_inset Quotes erd
\end_inset

 option for displaying the ordering explicitly, deemed in the manual as
 
\begin_inset Quotes eld
\end_inset

crucial
\begin_inset Quotes erd
\end_inset

 in case of structures with feedback 
\begin_inset CommandInset citation
LatexCommand citep
key "Reaktor6Primary"

\end_inset

.
\end_layout

\begin_layout Standard
When advanced users peek into the implementation of Primary modules, they
 enter Core mode.
 While also a visual dataflow language, Core mode uses lower-level data
 types, such as scalars of types 
\family typewriter
float
\family default
 and 
\family typewriter
int
\family default
 (including low-level concerns such as undefined behavior in type conversions,
 denormals in IEEE 754 floating-point), arrays and custom structured types
 called 
\begin_inset Quotes eld
\end_inset

bundles
\begin_inset Quotes erd
\end_inset

 (akin to LabVIEW's 
\begin_inset Quotes eld
\end_inset

clusters
\begin_inset Quotes erd
\end_inset

).
 Memory storage in the style of shift registers represented as special wire
 types.
 While at first glance Core seems an extension of Primary, they are fundamentall
y distinct languages.
 For instance, their semantics for event propagation are different.
 In Primary, an event propagated for more than one output is forwarded to
 each destination in turn.
 In Core, replicated events arrive logically simultaneously, so if one output
 is plugged into two inputs of the same cell, a single firing event is produced
 (whereas in Primary, this would produce two events).
\end_layout

\begin_layout Standard
Reaktor notably lacks a textual scripting mode.
 This absence is noted even by the music practitioner community: a major
 music industry magazine, Sound On Sound, states in its review of the latest
 version of Reaktor that 
\begin_inset Quotes eld
\end_inset

integration of a scripting language would help serious developers who sometimes
 feel the restrictions of a purely visual-based approach
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.soundonsound.com/reviews/native-instruments-reaktor-6
\end_layout

\end_inset


\end_layout

\end_inset

.
 Still, it is interesting to note that the application also uses a three-tier
 architecture, with a higher-level language in a central role and a lower-level
 language in a peripheral role, on top of the built-in application facilities.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: what are:
\end_layout

\begin_layout Plain Layout
* Table references
\end_layout

\end_inset


\end_layout

\begin_layout Section
VEE
\end_layout

\begin_layout Standard
VEE (Visual Engineering Environment) is a tool for development of engineering
 test-and-measurement software, based around a visual programming language.
 It was originally released by Hewlett-Packard in 1991, and is currently
 marketed by Keysight Technologies.
 
\begin_inset CommandInset citation
LatexCommand citep
key "vee93userguide"

\end_inset


\end_layout

\begin_layout Standard
VEE supports integrating with other languages for scripting.
 MATLAB integration support is included.
 Additionally, VBA scripting and an Excel integration library are also supported
 on Windows.
\end_layout

\begin_layout Standard
There are several data types, including integer, real, complex, waveform,
 enum, text, record and multidimensional arrays.
 Connections, however, are not typed.
 Most nodes perform automatic type conversions.
 VEE also supports named variables, which can be used via Set Variable and
 Get Variable nodes, allowing for indirect connections in the graph.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename vee_for_count.png
	width 75col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:VEE-for-count"

\end_inset

Mix of data and control flow in VEE.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
There are five kinds of ports for connecting wires (called 
\emph on
pins
\emph default
 in VEE): data pins, which carry data; sequence pins, designed only for
 affecting the firing sequence; execute pins, which force an immediate execution
 when fired; control pins, which affect the internal state of a node but
 do not cause data propagation; and error pins, for error handling.
 Sequence pins are prominent in VEE and break the pure dataflow model.
 In a comparison between LabVIEW and VEE in an engineering magazine, it
 is said that 
\begin_inset Quotes eld
\end_inset

LabVIEW follows the data-flow paradigm of programming rigorously.
 HP VEE is loosely based on data-flow diagrams with a large measure of flow-char
ting sprinkled with a little decision table.
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand citep
key "ee1999labview_vs_vee"

\end_inset

.
 Connected subgraphs of a disjoint graph can be launched separately, by
 connecting separate 
\begin_inset Quotes eld
\end_inset

Start
\begin_inset Quotes erd
\end_inset

 buttons to the sequence pins of input nodes of each subgraph.
 Data pins can connect to sequence pins; for example, an 
\family typewriter
If-Then-Else
\family default
 node can be used either in the dataflow way, outputting a value according
 to a condition, or in the flowchart way, triggering a subgraph.
 The 
\family typewriter
For Count
\family default
 iteration node is often used in conjunction with sequence and execute pins.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:VEE-for-count"

\end_inset

 illustrates the mix of data and control flow in VEE.
 Ports at the top and bottom of nodes are sequence pins; the green port
 is an execute pin; other pins at the left and right are data pins.
 This graph has two dataflow connections (black wires) and two control flow
 connections (gray wires).
 The 
\family typewriter
For Count
\family default
 output data pin triggers the sequence input pin of 
\family typewriter
RandomNumber
\family default
 ten times; at the end of the count, the sequence output pin of 
\family typewriter
For Count
\family default
 triggers the execute pin of 
\family typewriter
Collector
\family default
, which then outputs the array to 
\family typewriter
AlphaNumeric
\family default
.
 The sequence output pin of a node fires after the evaluation of all subgraphs
 connected to that node's data outputs is complete, which may include triggering
 sequence pins in nested subgraphs.
 A description of the intricate evaluation semantics of sequence pins in
 VEE is given in 
\begin_inset CommandInset citation
LatexCommand citep
key "vee1998"

\end_inset

.
\end_layout

\begin_layout Standard
There are two kinds of abstractions: UserObjects and UserFunctions.
 A UserObject is merely a collapsable subgraph.
 To reuse it, the object needs to be cloned, producing a new subgraph instance
 which can be edited separately from the original copy.
 A UserFunction is a reusable subgraph, for which all uses are references
 to the same instance.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
other EUP apps also have this confusion, and terminology varies.
 Abstractions, etc (find examples)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
compare hot and cold inlets in Pure Data to data execute pins in VEE
\end_layout

\end_inset


\end_layout

\begin_layout Section
Blender
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO organize and finish
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The node language is used in different parts of Blender.
 The node editor is the interface for creating materials in the render engine,
 for compositing and for texture editing.
 Each of these activities have their own set of nodes available to them.
 A restricted form of the node language called the "Logic Editor" is also
 available for integrating 3D objects with game scripting code.
 The remainder of this section will focus on the more general Node Editors
 available for the other tasks.
\end_layout

\begin_layout Standard
Programs in the Blender node language are directed acyclic graphs.
\end_layout

\begin_layout Standard
Four data types: color, numeric, vector and shader.
\end_layout

\begin_layout Standard
Ports (called sockets) have different colors according to their data types.
\end_layout

\begin_layout Standard
Nodes have properties, which are additional input arguments that are "inlined"
 in the node (that is, it is not necessary to create numeric nodes with
 constants and connect them to a node to parameterize these arguments).
\end_layout

\begin_layout Standard
Node Groups are collection of nodes that can be reused within a file and
 throughout different files, and the documentation describes them as "similar
 to functions in programming".
 Recursion is not allowed.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO what happens when duplicating vs creating a new instance of a group
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Oddly, when made accessible to a different file (through the File → Append
 menu, which appends the content to one file no another), node groups are
 called "Node Trees".
\end_layout

\begin_layout Standard
Node groups can have particular inputs and outputs from its internal nodes
 that are made available to the outside, in a similar manner to how tunnels
 work in LabVIEW.
 These tunnels are accessible when the node group is collapsed both as sockets
 and as properties.
\end_layout

\begin_layout Standard
The documentation warns the user not to include input and output nodes inside
 node groups.
\end_layout

\begin_layout Standard
The documentation mixes the presentation of the language, explaining concepts
 such as sockets and properties, with the presentation of the UI, explaining
 menus and keyboard shortcuts.
\end_layout

\begin_layout Standard
Blender is scriptable in Python.
 An example of the power of its scripting support is the Animation Nodes
 add-on 
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/JacquesLucke/animation_nodes
\end_layout

\end_inset


\end_layout

\end_inset

, which adds a whole new node system for controlling animations, allowing
 users to specify visually tasks that previously required Python code.
\end_layout

\begin_layout Standard
It is worth noting, however, that Blender's scripting interface is not without
 its limitation.
 For instance, it allows manipulating a node tree in the material editor,
 but not creating new node types.
 The Cycles Render Engine supports creating new node types written in OSL
 (Open Shading Language).
\end_layout

\begin_layout Standard
A user created a Boolean if-then-else node using the shader language.
 Another user in the same forum thread where this node was announced mentioned
 this node was equivalent to the "Condition" node in competing product Maya.
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://blenderartists.org/forum/showthread.php?354949-Cycles-Boolean-Node-(Not-Sh
ader)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Discussion: Dataflow end-user programming, then and now
\end_layout

\begin_layout Chapter
Design alternatives critiqued
\begin_inset CommandInset label
LatexCommand label
name "chap:A-Dataflow-Engine"

\end_inset


\end_layout

\begin_layout Standard
In this chapter, we revisit the classifications of design alternatives for
 dataflow end-user programmable languages presented in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Dataflow-UI-langs"

\end_inset

, illuminated by the study of contemporary languages of this kind presented
 throughout this work, and in particular the in-depth case studies of Chapters
 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Pure-Data"

\end_inset

 to 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:LabVIEW"

\end_inset

.
 We present here a critique of these various design choices and the impact
 of their inherent trade-offs.
 As we consider each of the design dimensions proposed in the survey by
 Hils 
\begin_inset CommandInset citation
LatexCommand citep
key "Hils1992DFVPLSurvey"

\end_inset

 and the additional ones proposed in this work, our aim is to discuss which
 choices have shown to be especially appropriate or inappropriate for different
 scenarios.
 We consider especially appropriate those choices that contribute to the
 usefulness of the application within its domain.
 We consider inappropriate design choices those that are related to the
 various pitfalls and shortcomings that we identified in the design of the
 various languages studied and presented in the previous chapters.
\end_layout

\begin_layout Standard
We begin by presenting in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:The-comparison"

\end_inset

 an update to the table presented in 
\begin_inset CommandInset citation
LatexCommand citep
key "Hils1992DFVPLSurvey"

\end_inset

, applying the list of design alternatives from that work (discussed in
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Hils's-classification"

\end_inset

) to a different set of contemporary dataflow languages, while also extending
 it with the additional design dimensions as presented in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:An-extension-to-Hils"

\end_inset

.
 The only language from that survey that is also in our list is LabVIEW
 
\begin_inset CommandInset citation
LatexCommand citep
key "LabVIEWgettingstarted"

\end_inset

.
 It is worth noting that in Hils's larger set of 15 visual dataflow programming
 languages the majority of them were academic projects, many of them short-lived.
 In our shorter list, we restricted ourselves to successful languages (both
 proprietary and open-source) with a proven track in terms of longevity
 and user base.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways true
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="29" columns="7">
<features rotate="0" tabularvalignment="middle">
<column alignment="right" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="right" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\emph on
General information
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Pure Data
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Excel
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
LabVIEW
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Reaktor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
VEE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Blender
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Main reference
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset CommandInset citation
LatexCommand citep
key "PuckettePd"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset CommandInset citation
LatexCommand citep
key "LabVIEWgettingstarted"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset CommandInset citation
LatexCommand citep
key "Reaktor6Primary"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset CommandInset citation
LatexCommand citep
key "vee93userguide"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\begin_inset CommandInset citation
LatexCommand citep
key "blender"

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Licensing
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
3-clause BSD
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Proprietary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Proprietary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Proprietary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Proprietary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
GNU GPL v2+
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Initial release
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1996
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1985
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1986
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1999
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1991
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
1995
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Latest release
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
2016
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
2016
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
2016
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
2015
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
2013
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
2017
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Application domain
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Music
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Office
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Engineering
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Music
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Engineering
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
3D graphics
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\emph on
Design alternatives 
\emph default

\begin_inset CommandInset citation
LatexCommand citep
key "Hils1992DFVPLSurvey"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Pure Data
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Excel
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
LabVIEW
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Reaktor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
VEE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Blender
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Box-line representation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Iteration
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Yes (cycles)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Limited
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Yes (construct)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Limited
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
No
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Subprogram abstraction
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Selector/distributor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Flow of data
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Uni
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Uni
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Uni
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Uni
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Uni
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Uni
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Sequence construct
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
No
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Type checking
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Limited
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Higher-order functions
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
No
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Execution mode
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Data-driven
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Demand-driven
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Data-driven
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Demand-driven
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Data-driven
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Data-driven
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Liveness level
\series default
 
\begin_inset CommandInset citation
LatexCommand citep
key "tanimoto1990liveness"

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
\emph on
Additional design alternatives
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Pure Data
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Excel
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
LabVIEW
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Reaktor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
VEE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Blender
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Dataflow model
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Dynamic
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Static
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Static
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Static
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Static
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Static
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
N-to-1 inputs
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
No
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Separate edit/use views
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
No
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Time-dependent firing
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
No
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Rate-based evaluation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Synchronous
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Synchronous
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
No
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Indirect connections
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
No
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Dynamic connections
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
No
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Textual sub-language
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Imperative
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Functional
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Imperative
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Imperative
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
No
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size small
Scripting
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Python, Lua
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
VBA
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
MATLAB
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Reaktor Core
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MATLAB
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
OSL, Python
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:The-comparison"

\end_inset

A comparison of contemporary dataflow UI-level languages
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Based on the knowledge obtained studying existing languages, we wish to
 propose a new dataflow language with a focus on embeddability and extensibility
, through which developers of end-user applications will be able to construct
 a domain-specific language for their application.
 The idea is that this language will be implemented as a 
\emph on
dataflow engine
\emph default
, to be embedded into the application.
 The application developer will use the engine to specify a DSL for their
 application, defining data types for the objects of its domain, and selecting
 the appropriate subset of the functionality of the dataflow engine that
 should be exposed to the application UI.
\end_layout

\begin_layout Plain Layout
Note that this does not mean that the language proposed here will be the
 language exposed to the end-user, or that a single end-user UI-level language
 is generally suitable for all sorts of data-centric applications: the language
 exposed to the user will be a DSL created by the core application developer,
 exposing elements of the application domain.
 This DSL will run on top of the dataflow engine, which should on its turn
 provide clean execution semantics so that the DSL avoids design pitfalls
 that plague end-user languages that are developed ad hoc.
 The dataflow engine will not concern itself with syntax: it is up to the
 developer of the application's UI to provide the user a presentation of
 the language, which may be textual and/or graphical (hence the name 
\begin_inset Quotes eld
\end_inset

engine
\begin_inset Quotes erd
\end_inset

, in analogy to game engines, where the low-level mechanics are provided
 by the engine but the presentation of the game is up to the game developer).
\end_layout

\begin_layout Plain Layout
This extends the approach taken when embedding scripting languages, where
 the domain data is exposed as values to the execution environment (objects,
 APIs) but the language itself is usually unchanged.
 Here, we want to let the developer produce the appropriate language for
 their interface, by choosing which supported language features to expose.
 For example, some UI-level languages will be purely functional, some will
 need to deal with state; some will allow functional abstraction, others
 won't.
 The semantics of the underlying dataflow engine should be 
\emph on
modular
\emph default
.
 We believe that the set of representative features existing in dataflow
 UI-level languages form a gradient representing a design space, and are
 not just a set of disjoint functionalities particular to each application
 studied.
\end_layout

\begin_layout Plain Layout
This means that the ability to expose or hide certain features needs to
 be built into the design, and not left for the domain developer as a presentati
on issue.
 Taking away features from a language after the fact can have unintended
 consequences and may not be easily possible.
 In scripting languages, this kind of customization is restricted to the
 library level, when available at all.
 Lua is a rare example of a language where its standard libraries are optional
 when embedding; even then, disabling operators and language constructs
 would require editing the source code of the virtual machine.
 In an end-user language one might want to impose restrictions to obtain
 certain operational guarantees, such as the lack of cycles.
 The central challenge in designing the dataflow engine supporting feature
 modularity is finding the proper granularity at which these features can
 be selected.
\end_layout

\begin_layout Plain Layout
We intend to design the dataflow engine and produce an executable model
 of its semantics in Haskell.
 We will then use it to model the languages of the various dataflow applications
 studied, using the engine to develop prototypes that capture the data manipulat
ion style of each application.
 We will compare the resulting languages with the original models, aiming
 to demonstrate that, like in scripting, there is room for reuse in end-user
 UI-level language design and implementation.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The following sections discuss these design dimensions organized logically
 into four groups.
 Being the focus of this work, the first three sections discuss semantic
 aspects, namely graph evaluation, language features and type checking;
 the fourth section groups the remaining aspects.
 Unless otherwise stated, all remarks about Excel below apply to all spreadsheet
s discussed in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Spreadsheets"

\end_inset

.
\end_layout

\begin_layout Section
Graph evaluation
\end_layout

\begin_layout Standard
In this section, we discuss design aspects that refer to the evaluation
 of the dataflow graph as a whole.
 In other words, we will discuss aspects which affect the design of the
 graph evaluator's main loop and not that of specific nodes.
 This way, we present the discussion of semantic aspects in a top-down fashion,
 the same way we presented the interpreters in previous chapters.
 
\end_layout

\begin_layout Subsection
Static and dynamic dataflow models
\end_layout

\begin_layout Standard
When creating a dataflow-based system, the first design decision to take
 with regard to the language is which dataflow model to use; in other words,
 which criteria will be used for firing nodes.
 Given that the essence of dataflow is purely functional, any order of evaluatio
n (and thus any sequence of firings) should produce identical results.
 However, since real-world programs are usually not purely functional and
 include visible effects, the underlying dataflow model can become apparent
 to the end-user: for example, in a static model, a fast operation can be
 held back by a slow operation further ahead in the pipeline, due to the
 lack of queueing.
 Dynamic dataflow models avoid these bottlenecks, but their more complicated
 models present different trade-offs 
\begin_inset CommandInset citation
LatexCommand citep
key "Dennis85Models,kavi2015dataflow"

\end_inset

, some of which become apparent in the resulting language.
 Of the languages compared in this work, only Pure Data employs a dynamic
 model.
 A side-effect of this model is that ordering issues arise.
 As discussed in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Discussion:-Syntax-and-semantics"

\end_inset

, we believe these issues were not addressed appropriately.
\end_layout

\begin_layout Standard
Another side of this trade-off which favors static and synchronous dataflow
 models is that understanding and debugging a dataflow graph is easier when
 there is a single token per arc (or a fixed number of values, as in the
 case of synchronous dataflow), and only one iteration of a loop is running
 at a time.
 For end-user programming, understandability is more important than parallel
 efficiency, so it is our view that end-user dataflow languages should present
 a static dataflow view of program execution.
 When the language contains explicit looping constructs, it should be possible
 to achieve a dynamic flow of execution in certain loops as a user-transparent
 optimization, if the contents of a loop are known to be purely functional,
 for example.
 Such an optimization could then be automatically disabled when the user
 is probing the flow of tokens for debugging purposes, restoring a one-token-per
-wire view.
\end_layout

\begin_layout Subsection
Data-driven and demand-driven dataflow
\end_layout

\begin_layout Standard
In the classic literature on the dataflow paradigm, the data-driven and
 demand-driven models are presented as equally proeminent, complementary
 approaches 
\begin_inset CommandInset citation
LatexCommand citep
key "Treleaven:1982:DDC:356869.356873"

\end_inset

.
 Yet in the context of end-user programming, we identify a tendency towards
 data-driven execution, considering not only the six languages selected
 here, but also the ones that were preliminarily studied to perform the
 selection.
\end_layout

\begin_layout Standard
We believe this is understandable because the data-driven approach more
 directly maps to the mental model one has about the evaluation of a graph,
 with the order of execution matching the way the data flows from input
 nodes toward output nodes.
\end_layout

\begin_layout Standard
Only two languages in this study employ demand-driven evaluation: Excel
 and Reaktor.
 Demand-driven evaluation is natural in a spreadsheet because cells are
 written as textual expressions, which translate to an expression tree that
 is evaluated top-down, that is, starting from the output node.
 The fact that Excel is demand-driven is mostly transparent, because of
 its static dataflow model, its lack of time-dependent firing and purely
 functional nature (with no imperative textual sub-language).
 Beyond the basic intuition about expression trees, one way to verify that
 a spreadsheet is indeed demand-driven is by forcing side-effects via the
 scripting layer of the application, and confirming that these only happens
 when cells are scrolled into view.
 We confirmed this successfully in all spreadsheets analyzed
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The JavaScript-based scripting layer of Google Sheets tries to prevent side-effe
cts (we could not make it pop up a message box as we did in the other applicatio
ns), but we still verified the demand-driven execution by writing a computation-
intensive script that caused a noticeable delay.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The case of Reaktor is a good illustration of how demand-driven execution
 can be a poor choice for end-user applications.
 Although not stated explicitly in its documentation and indistinguishable
 in most cases, the evaluation of Reaktor's Primary mode is demand-driven.
 This can be inferred from the fact that graphs that do not connect to an
 audio output need to have their terminal nodes marked as 
\begin_inset Quotes eld
\end_inset

always active
\begin_inset Quotes erd
\end_inset

 in order to trigger continuous evaluation.
 In one tutorial from the vendor, the documentation instructs to add a dummy
 
\begin_inset Quotes eld
\end_inset

lamp
\begin_inset Quotes erd
\end_inset

 output marked as always-on just to achieve this same effect 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://support.native-instruments.com/hc/en-us/articles/209588249-How-to-Use-an-E
vent-Table-as-Copy-Buffer-in-REAKTOR-5
\end_layout

\end_inset


\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Uni and bi-directional dataflow
\end_layout

\begin_layout Standard
All languages studied in this work employ the traditional uni-directional
 style of dataflow.
 In Hils's work, only one language featured bi-directional flow of data:
 Fabrik 
\begin_inset CommandInset citation
LatexCommand cite
key "Ingalls:1988:FVP:62083.62100"

\end_inset

, a language for designing user interfaces.
\end_layout

\begin_layout Standard
Bi-directional constraint systems have been present in research for end-user
 development systems since the early days of Sketchpad 
\begin_inset CommandInset citation
LatexCommand cite
key "Sutherland1963Sketchpad"

\end_inset

 and the paradigm continues to be researched for this day 
\begin_inset CommandInset citation
LatexCommand cite
key "Apparatus"

\end_inset

, but what we observe in industry practice is that the simpler uni-directional
 model has become established as the norm in dataflow.
 GUI construction systems (notably the same domain as Fabrik) have taken
 up bi-directional constraint systems 
\begin_inset CommandInset citation
LatexCommand cite
key "Jamil2014constraintsolvers"

\end_inset

, with Cassowary 
\begin_inset CommandInset citation
LatexCommand citep
key "Badros:2001:CLA:504704.504705"

\end_inset

 being integrated into Apple's standard GUI libraries, but those are used
 as an internal component and not as end-user programming languages of their
 own.
\end_layout

\begin_layout Subsection
N-to-1 inputs
\end_layout

\begin_layout Standard
Pure Data is the only language in our study that supports N-to-1 inputs,
 that is, multiple wires connecting to a single input port in a node.
 The way it handles these inputs is deeply linked to its dataflow evaluation
 model.
 For audio wires, which use a static and synchronous model, the incoming
 data is merged using additive synthesis (that is, the input argument for
 the port is a buffer where each sample value is the sum of the sample values
 at the corresponding positions from the incoming wire buffers).
 For message wires, which use a dynamic model, it queues inputs, causing
 multiple incoming inputs arriving to a single port through different wires
 to fire the node multiple times.
 Queueing also leads to concerns with ordering, as discussed in Section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Discussion:-Syntax-and-semantics"

\end_inset

.
\end_layout

\begin_layout Standard
It seems clear that disallowing N-to-1 inputs leads to a simpler conceptual
 model and less suprising behavior.
 Not all domains have an obvious choice on what to do when merging inputs
 (and even in Pure Data's domain of audio processing, some synthesizers
 use subtractive synthesis, for example) so having an explicit merge node
 is a clearer why of presenting what is happening with the data.
 The convenience that N-to-1 inputs bring could be obtained by automatically
 inserting those nodes when multiple wires are plugged to an input port,
 similarly to how LabVIEW auto-inserts feedback nodes.
\end_layout

\begin_layout Subsection
Timing considerations
\end_layout

\begin_layout Standard
When considering issues of timing, let us look at both time-dependent firing
 and rate-based evaluation at once.
 We see in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:The-comparison"

\end_inset

 three distinct patterns.
 We have two languages that support time-dependent firing and use a synchronous
 dataflow model for rate-based evaluation: Pure Data and Reaktor; two languages
 that support time-dependent firing but do not feature rate-based evaluation
 (that is, using a purely static model): LabVIEW and VEE; and two languages
 that do not have either: Excel and Blender.
\end_layout

\begin_layout Standard
The approach of these languages with regard to timing is linked to their
 domains and to the kind of data and activity they perform.
 Pure Data and Reaktor, both of them music applications, operate on audio
 streams.
 Processing digital audio in real-time requires rate-based evaluation, and
 music creation demands the ability to specify transformations of data based
 on time.
 LabVIEW and VEE, engineering applications, require supporting activities
 such as periodic reading and writing of data, but since they don't have
 a single domain-specific target for these processing rates which can be
 made fully implicit in the evaluation loop, as it happens, for example,
 with music applications do, processing buffers at standard rates such as
 
\begin_inset Quotes eld
\end_inset

48000 Hz 24-bit stereo
\begin_inset Quotes erd
\end_inset

 (
\begin_inset Formula $48000\times3\times2=288000$
\end_inset

 bytes per second).
 Since sampling rates of various data acquisition instruments supported
 by those engineering tools vary, the user needs to essentially construct
 the rate-processing loop by hand, using arrays and delay objects.
 Both LabVIEW and VEE define 
\begin_inset Quotes eld
\end_inset

waveform
\begin_inset Quotes erd
\end_inset

 types as abstractions to help in this task, but those are no more than
 a 
\begin_inset Quotes eld
\end_inset

typedef
\begin_inset Quotes erd
\end_inset

 of a record type, storing an array and a timestamp.
 
\end_layout

\begin_layout Standard
Languages whose domains do not deal with time avoid time-based evaluation
 features entirely: Excel and Blender have no support them (except for the
 occasional Excel function like 
\family typewriter
TODAY()
\family default
, but that is clearly not integrated with the language's evaluation model—for
 one, the cell value does not update automatically as time passes).
\end_layout

\begin_layout Standard
Another issue related to timing that is often a concern in language design
 is synchronization.
 In end-user applications, timing constraints depend on the domain.
 In the field of music, for example, timing precision matters up to the
 scale of human-perceptible audio latency, which is in the order of a few
 hundredths of seconds.
 This means that synchronization can be often satisfactorily approximated
 via real-time clock events.
 As we saw in the case of LabVIEW, timing primitives with millisecond precision
 are used to cause iterations of parallel loops to proceed in tandem.
 When a language combines two evaluation models, as is the case of Pure
 Data, which uses dynamic dataflow for messages and synchronous dataflow
 for audio, it is also important to avoid synchronization issues.
 Pure Data solves this adequately by alternating message and audio evaluation
 while using an audio buffer to give the evaluation of the message cascades
 enough time to run.
 This can still lead to audio drop-outs if message processing is excessive,
 but musicians nowadays are used to the notion that heavy computations can
 make audio stutter, known in the community jargon as 
\begin_inset Quotes eld
\end_inset

audio dropouts
\begin_inset Quotes erd
\end_inset

, and adapt accordingly.
\end_layout

\begin_layout Subsection
Indirect and dynamic connections
\end_layout

\begin_layout Standard
As discussed in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Indirect-connections"

\end_inset

, while the presence of indirect connections is a syntactic feature, the
 occurrence of connections determined at runtime has semantic consequences.
 Dynamic connections make it impossible to determine a static schedule for
 node evaluation in advance (as is done for audio nodes in Pure Data, for
 example), to optimize in-place replacement of buffers to avoid array copying
 (since any intermediate node may be fired at any time) and to reliably
 detect loops in advance.
\end_layout

\begin_layout Standard
Pure Data, Excel and LabVIEW support dynamic connections.
 As should be no surprise by now, Pure Data supports dynamic connections
 only for message data, not audio.
 An indirect connection, dynamic or not, consists of two nodes, a sender
 and a receiver.
 In Pure Data, only the sender node can have its target dynamically defined;
 the identifier of a receiver node cannot be changed at runtime.
\end_layout

\begin_layout Standard
Of the three languages that support dynamic connections, Pure Data presents
 them as a basic feature of the language; Excel and LabVIEW treat them as
 advanced features, in the form of Excel's 
\family typewriter
INDIRECT
\family default
 function and LabVIEW's object reference system.
 This may be related to the fact that, given that Pure Data already employs
 a dynamic dataflow model, these connections behave like any other ones.
 In static dataflow systems like Excel and LabVIEW, the use of dynamic connectio
ns can cause issues.
 It is easy to find on the internet examples of user problems with dynamic
 connections in both Excel
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

No #REF! error, the cell just doesnt update with the new value (just stays
 exactly the same), even though the reference is correct and the referenced
 cell is obviously updated
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes eld
\end_inset

I actually tried rebooting, didnt help.
\begin_inset Quotes erd
\end_inset

 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.wallstreetoasis.com/forums/excel-help-cells-do-not-update-when-they-re
ference-another-excel-file
\end_layout

\end_inset


\end_layout

\end_inset

 and LabVIEW
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Typing 
\begin_inset Quotes eld
\end_inset


\emph on
labview object reference
\emph default

\begin_inset Quotes erd
\end_inset

 in Google auto-suggests 
\begin_inset Quotes eld
\end_inset


\emph on
labview object reference is invalid
\emph default

\begin_inset Quotes erd
\end_inset

.
 In one of the results, the LabVIEW knowledge base reports 
\begin_inset Quotes eld
\end_inset

This is a documented known issue that occurs in LabVIEW Real-Time versions
 2014 and 2015.
 After making a modification to the VI, Error 1055 is thrown from any property
 node attempting to access the dynamic refnum.
 In order to resolve this error, close and re-open the VI.
\begin_inset Quotes erd
\end_inset

 (
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://digital.ni.com/public.nsf/allkb/2E848F065A18570986257F3800708328
\end_layout

\end_inset

).
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Language features
\end_layout

\begin_layout Standard
We now move to the second part of the discussion on semantic aspects.
 Here, we discuss the design of specific nodes and features that may or
 may not be present in a dataflow language.
\end_layout

\begin_layout Subsection
Selector/distributor
\end_layout

\begin_layout Standard
Selector and distributor nodes are the most basic features in a dataflow
 language.
 Unsurprisingly, all languages studied here implement them and there is
 not much design variation among them.
 For more complex data types, such as images in Blender and audio in Pure
 Data and Reaktor, a selector 
\begin_inset Formula $\sigma(k,v_{1},v_{2})$
\end_inset

 can work like a 
\begin_inset Quotes eld
\end_inset

mixer
\begin_inset Quotes erd
\end_inset

 node, in which 
\begin_inset Formula $k$
\end_inset

 is a blend value between 0 and 1 instead of a boolean.
\end_layout

\begin_layout Subsection
Iteration
\end_layout

\begin_layout Standard
In stark contrast with selectors and distributors, iteration constructs
 are the ones that show the greatest amount of variation in design among
 dataflow languages, leading even to a survey specifically about it 
\begin_inset CommandInset citation
LatexCommand cite
key "Mosconi:2000:ICD:2245742.2245907"

\end_inset

.
 And indeed, no two languages among those presented in this work implement
 iteration the same way.
 We consider here iteration in a broad sense of the word, defining it as
 any language feature that allows evaluating a subgraph a number of times.
\end_layout

\begin_layout Standard
Pure Data, being a dynamic dataflow language, allows for cycles, and this
 is a simple way of producing iteration.
 Evidently, cycles are only allowed in the dynamic part of the language,
 that is, between message-handling nodes.
 Cycles between audio nodes are detected and rejected as soon as the DSP
 engine is activated.
\end_layout

\begin_layout Standard
In Excel, a array formulas may be considered a limited form of iteration,
 since they allow evaluating multiple times for a given range of values
 a single expression tree.
 Some array formula patterns combining common functions were turned into
 predefined functions which always evaluate their arguments in an array
 context, like 
\family typewriter
SUMPRODUCT
\family default
 and 
\family typewriter
SUMIF
\family default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Excel users invented an idiom to produce the equivalent of the missing function
 
\family typewriter
\size normal
SUMPRODUCTIF
\family default
\size default
 without resorting to array formulas: the expression 
\family typewriter
\size normal
SUMPRODUCT(--(C1:C10="flag"),A1:A10,B1:B10))
\family default
\size default
 uses double negation to coerce boolean values into 0 or 1, annulling elements
 of the product when the condition does not match.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename naiad.png
	scale 65

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Naiad"

\end_inset

Loop contexts in Naiad 
\begin_inset CommandInset citation
LatexCommand citep
key "Murray:2013:NTD:2517349.2522738"

\end_inset

, featuring a very similar structure to that of Show and Tell and LabVIEW
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
LabVIEW features structured constructs for looping, based on the idea of
 a frame around a subgraph, with values flowing between iterations through
 shift registers.
 The design of this construct is essentially the same as that of Hierarchical
 Data Flow introduced in Show and Tell 
\begin_inset CommandInset citation
LatexCommand citep
key "Kimura1985HDF,Kimura86ShowAndTell"

\end_inset

.
 More recently, this model of structured loops in static dataflow graphs
 has been reinvented in Naiad 
\begin_inset CommandInset citation
LatexCommand cite
key "Murray:2013:NTD:2517349.2522738"

\end_inset

, a modern distributed system for Big Data processing, which advertises
 static dataflow with structured loops as one of its main features.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Naiad"

\end_inset

, from 
\begin_inset CommandInset citation
LatexCommand cite
key "Murray:2013:NTD:2517349.2522738"

\end_inset

, illustrates the similarities: nodes 
\begin_inset Formula $I$
\end_inset

 and 
\begin_inset Formula $E$
\end_inset

 work like LabVIEW tunnels, and node 
\begin_inset Formula $F$
\end_inset

 works like a shift register, with the difference that Naiad employs a tagged-to
ken system to allow for parallel iterations.
\end_layout

\begin_layout Standard
Reaktor has no iteration structure per se, but it features a node called
 "Iteration" which acts as a counter, producing a series of values that
 can be used for firing other subgraphs and indexing values.
 VEE has a similar iteration node to Reaktor, but because of its support
 for sequence pins that dictate control flow, it is a more powerful construct
 for triggering arbitrary subgraphs.
 VEE also performs an implicit 
\begin_inset Formula $map$
\end_inset

 operation when passing an array to a function that expects a scalar, similarly
 to Excel's array context.
 Finally, Blender notably lacks an iteration construct.
 
\end_layout

\begin_layout Subsection
Sequence construct
\end_layout

\begin_layout Standard
A sequence construct is a way to specify that one subgraph should execute
 after another, without having a data dependency between them (akin to sequencin
g two statements 
\begin_inset Formula $s_{1};s_{2}$
\end_inset

 in textual programming languages).
 As such, it is a fundamentally imperative construct.
\end_layout

\begin_layout Standard
The only languages from our survey to include explicit sequencing constructs
 are LabVIEW and VEE.
 Given that they are both engineering applications and are the only ones
 to feature constructs clearly named after their textual-language counterparts
 such as 
\begin_inset Quotes eld
\end_inset

for
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

while
\begin_inset Quotes erd
\end_inset

, we speculate that explicit sequencing was added to ease the transition
 from users who had some previous programming experience.
 
\end_layout

\begin_layout Standard
It is interesting to note that all the other applications do not have sequencing
 constructs.
 This seems to indicate that for domain specialists without preconceived
 notions about programming, imperative constructs are not a necessity and
 declarative programming can be used successfully.
\end_layout

\begin_layout Subsection
Subprogram abstractions
\end_layout

\begin_layout Standard
The ability to abstract away subprograms is a commonplace feature in modern
 programming languages.
 In the dataflow model, a subprogram abstraction means replacing a subgraph
 with a node that represents it.
 In graphical languages, this feature becomes especially necessary to tame
 the visual clutter of the graph representation.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename subgraph_1.eps
	scale 80

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:subgraph"

\end_inset

A graph containing two occurrences of a subgraph 
\begin_inset Formula $S$
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In end-user programming languages, and especially visual ones, abstractions
 present semantic complications that are usually missing in languages for
 professional programmers.
 A typical motivation for abstracting a subgraph is to reuse it.
 In the example of Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:subgraph"

\end_inset

, subgraph 
\begin_inset Formula $S$
\end_inset

 appears twice in the main diagram.
 Expanding both occurences of 
\begin_inset Formula $S$
\end_inset

, one would find the same subgraph with nodes 
\begin_inset Formula $X$
\end_inset

, 
\begin_inset Formula $Y$
\end_inset

 and 
\begin_inset Formula $Z$
\end_inset

.
 When copying a node representing an abstracted subgraph for reuse, end-users
 have different intuitions whether these two nodes are references to the
 same subgraph or if they are two separate copies that can be modified without
 affecting the other one.
 Translating to the world of textual languages, this is the question whether
 an abstraction behaves as a newly-declarated function used in two places,
 or if it is merely a visual (syntactic) abbreviation, akin to those achieved
 by code-folding text editors.
\end_layout

\begin_layout Standard
Moreover, when end-users perceive an abstraction as a single subgraph referenced
 in two different places, then there is the question if they perceive the
 subgraph as reentrant: in other words, whether they see the two invocations
 of the subgraph as fully independent executions (that is, like usual function
 calls where each invocation has its own activation record), or if they
 see the shared subgraph as a single entity in memory.
 In case of stateful nodes, this is especially relevant, because that determines
 if multiple invocations of the abstraction in the main graph affect each
 other or not (which would be equivalent, for example, to declaring all
 local variables in a C function as being 
\family typewriter
static
\family default
 or not).
\end_layout

\begin_layout Standard
Note that these two issues of copying and reentrancy are related: copies
 naturally have no reentrancy problems.
 We have therefore three possible behaviors:
\end_layout

\begin_layout Enumerate
copying a subgraph produces a new, unrelated subgraph with identical contents;
\end_layout

\begin_layout Enumerate
copying a subgraph produces a new reference to the same subgraph, but each
 reference produces a new instance in memory at runtime;
\end_layout

\begin_layout Enumerate
copying a subgraph produces a new reference to the same subgraph, which
 has a single instance in memory at runtime.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement t
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="4">
<features rotate="0" tabularvalignment="middle">
<column alignment="left" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
separate subgraph
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
same subgraph
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
separate at runtime
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
same at runtime
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rotate="90" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
after editing
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename subgraph_w_separate_graphs.eps
	scale 80

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename subgraph_w_single_graph.eps
	scale 80

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename subgraph_w_single_graph.eps
	scale 80

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row bottomspace="0.2cm">
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(a1)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(b1)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(c1)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rotate="90" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
at runtime
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename subgraph_w_separate_graph_runtime.eps
	scale 80

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename subgraph_w_single_graph_separate_runtime.eps
	scale 80

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename subgraph_w_single_graph_runtime.eps
	scale 80

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row bottomspace="0.2cm">
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(a2)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(b2)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(c2)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:subgraph-behavior"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:subgraph-behavior"

\end_inset

 illustrates the effect of editing the graph from Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:subgraph"

\end_inset

 under these different behaviors.
 Consider that the user expands the right-hand occurrence of 
\begin_inset Formula $S$
\end_inset

 and changes 
\begin_inset Formula $Z$
\end_inset

 to 
\begin_inset Formula $W$
\end_inset

.
 In the first scenario, editing the second occurrence of 
\begin_inset Formula $S$
\end_inset

 does not affect the first (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:subgraph-behavior"

\end_inset

(a1)), and their executions will also be independent (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:subgraph-behavior"

\end_inset

(a2)).
 In the second scenario, all references point to the same subgraph (Figure
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:subgraph-behavior"

\end_inset

(b1)), but the execution of each instance is independent (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:subgraph-behavior"

\end_inset

(b2)).
 In the third scenario, there is a single copy of 
\begin_inset Formula $S$
\end_inset

, both in the diagram (note that Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:subgraph-behavior"

\end_inset

(c1) is identical to Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:subgraph-behavior"

\end_inset

(b1)) and in memory (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:subgraph-behavior"

\end_inset

(b1)), meaning that the execution is not re-entrant.
\end_layout

\begin_layout Standard
Seasoned programmers used to textual languages will expect the behavior
 of scenario 2, with a single representation of a function in the program
 and separate instances in memory as it executes, which is the best one
 in terms of code reuse and safe execution.
 Note, however, that of the three scenarios depicted in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:subgraph-behavior"

\end_inset

, this is the only one where the visual presentation when editing the program
 does not represent the behavior in memory.
\end_layout

\begin_layout Standard
Different applications approach these issues in different ways.
 Pure Data has two ways of representing subprograms: 
\begin_inset Quotes eld
\end_inset

subpatches
\begin_inset Quotes erd
\end_inset

, which behave according to scenario 1, and are stored as part of the same
 file as the main graph, and 
\begin_inset Quotes eld
\end_inset

abstractions
\begin_inset Quotes erd
\end_inset

, which are stored as separate graph files, and behave according to scenario
 2.
 A problem arises, though, when saving abstractions.
 Pure Data persists the internal state of graphs when saving them, so when
 a patch contains multiple instances of an abstraction, the internal state
 of only one of them is saved.
 Users are advised to make the initialization of their abstractions stateless
 through the use of creation arguments, but they still look for workarounds
 to save their state.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://forum.pdpatchrepo.info/topic/8803/state-saving-abstractions/14
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In LabVIEW, sub-VIs are not reentrant by default
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "NI2013reentrancy"

\end_inset

.
 There is a single instance in memory, as in scenario 3 above.
 Note that this leads effectively to a situation with N-to-1 wires leading
 to input ports, even though LabVIEW does not allow it otherwise.
 This breaks LabVIEW's static dataflow model and introduces queueing.
 The user can enable reentrancy, producing one instance in memory per reference,
 changing its behavior to scenario 2.
 Sub-VIs cannot be recursive.
 Each instance remains in memory even when not running, to save the state
 of shift registers and feedback nodes.
 There is also a third setting, in which LabVIEW creates a pool of instances
 as a way to reduce memory usage, but in this case sub-VIs become stateless.
\end_layout

\begin_layout Standard
A Node Group in Blender shows in its collapsed box a number that represents
 the number of 
\begin_inset Quotes eld
\end_inset

linked
\begin_inset Quotes erd
\end_inset

 instances.
 When a Node Group is copied, this number increments in all instances to
 denote that the same Node Group is being used in multiple places.
 The user can turn an instance into an independent copy by clicking this
 number.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO Referential
\begin_inset space ~
\end_inset

transparency: Purity of functions vs.
 Undo
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Higher-order functions
\end_layout

\begin_layout Standard
None of the languages presented here include support for defining higher-order
 functions.
 In fact, the only languages with support for user-defined higher-order
 functions in Hils's original survey are all either general-purpose programming
 languages (outside of the scope of this work) or Hils's own DataVis 
\begin_inset CommandInset citation
LatexCommand cite
key "Hils1991datavis"

\end_inset

, a research language for scientific visualization.
 In 
\begin_inset CommandInset citation
LatexCommand citep
key "Fukunaga:1993:FOD:170791.170832"

\end_inset

, higher-order functions for dataflow visual languages are again discussed
 only in the context of general-purpose languages.
\end_layout

\begin_layout Standard
It is unsurprising that successful end-user programmable applications lack
 higher-order functions: those applications feature languages tailored for
 their specific domains, and a language is most effective when it is designed
 to work in terms of objects of its intended domain 
\begin_inset CommandInset citation
LatexCommand cite
key "West:2015:CSR:2814228.2814247"

\end_inset

.
 Domain specialists think in terms of objects of their domain: numbers in
 a spreadsheet represent monetary values, a matrix in a graphics editor
 represents an image.
 Functions as first-class objects are a reification of programs.
 First-order functions represent programs that are operations on objects
 of the domain: a function 
\begin_inset Formula $transpose:Score\times Key\rightarrow Score$
\end_inset

 represents the work of transposing a musical score into another key (e.g.
 from 
\begin_inset Formula $C\sharp$
\end_inset

 to 
\begin_inset Formula $B\flat$
\end_inset

), and as such it is an activity within the specialist's domain.
 Higher-order functions are one step removed from the domain in terms of
 abstraction: they are programs that are operations on other programs.
 The addition of higher-order functions to the set of first-class values,
 thus, makes the universe of discourse
\begin_inset Foot
status open

\begin_layout Plain Layout
in Boole's original sense 
\begin_inset CommandInset citation
LatexCommand citep
key "Boole1854Thought"

\end_inset


\end_layout

\end_inset

 strictly larger, and the added objects are familiar (and of interest) to
 computing professionals, not to domain specialists.
 An argument of the same nature could be made in the opposite direction
 of the abstraction ladder, to explain the absence of low-level access to
 bits and bytes.
\end_layout

\begin_layout Section
Type checking
\end_layout

\begin_layout Standard
This work has not focused much on type checking issues, since the type systems
 of all languages studied are very simple.
 In at least one case, the type system of a language was deliberately simplified
 by the language designers, with the restriction on recursive data types
 in LabVIEW.
 Still, there are interesting observations to be made about type checking
 in dataflow end-user applications.
\end_layout

\begin_layout Standard
We define type checking in the context of dataflow as a verification provided
 by the environment, prior to execution, that the types of values expected
 by an input port matches the types of values produced by an output port
 connected to it.
 In the case of an environment with liveness level 2, this means that the
 system reports a type mismatch before entering the "use" mode.
 In the case of a responsive environment (i.e.
 one with liveness level 3), we expect the system to flag a type incompatibility
 immediately as the user attempts to add an invalid connection, disallowing
 the creation of the wire in the first place.
 
\end_layout

\begin_layout Standard
LabVIEW performs type checking, and the various data types supported are
 visually identified through colors in nodes and wires.
 When a user draws incorrect wires those remain in the diagram marked as
 such and running the program is not possible.
 As explained in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:LabVIEW"

\end_inset

, LabVIEW's inference system for tunnel directions can cause previously
 correct wires to become flagged as incorrect, sometimes with wide-ranging
 and confusing results, and unhelpful error messages.
 The well-intentioned convenience provided by the inference system has proven
 to be, in our opinion, inappropriate for an end-user programming system.
 
\end_layout

\begin_layout Standard
Pure Data offers limited type checking, in the sense that the interface
 provides a clear separation between message and audio data, differentiating
 both nodes and wires of these two kinds and disallowing mismatching connections
, but type mismatches between various message data types are not checked.
 In various senses, Pure Data works almost like two languages in one, with
 its single-typed synchronous model for audio flow on one side, and a dynamicall
y-typed dynamic dataflow model for message passing on the other.
 
\end_layout

\begin_layout Standard
Both Blender and Reaktor provide visual hints about the types of their input
 and output ports, and only allow connecting wires between ports of compatible
 types.
 Type errors are impossible.
\end_layout

\begin_layout Standard
Excel and VEE are dynamically typed: type errors are reported only at runtime.
 Since Excel is a responsive application and connections between cells are
 given by the user textually, there is no way for the language to prevent
 type errors in the manner of Blender and Reaktor.
 However, one could conceive of a statically-typed spreadsheet that, in
 the event of cell errors, instead of merely producing an error value for
 the whole formula
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Not to mention that such errors in dynamically-typed spreadsheets are subject
 to often-arbitrary error propagation semantics as we have seen in Chapter
 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Spreadsheets"

\end_inset

.
\end_layout

\end_inset

, produced an error message indicating which term of the expression caused
 the type error, as modern compilers do.
\end_layout

\begin_layout Standard
There are other interesting issues related to types which we did not focus
 in this work.
 Efficient handling of data structures and strategies to avoid excessive
 copying of data between nodes are matters of concern 
\begin_inset CommandInset citation
LatexCommand citep
key "DinamicaVM,Foley-Bourgon:2016:EIC:2989225.2989235"

\end_inset

, especially in less restricted evaluation models.
\end_layout

\begin_layout Section
Other aspects
\end_layout

\begin_layout Standard
Finally, we discuss other aspects with primarily syntactic or pragmatic
 impact.
 Since these affect the design of the language as a whole, choices made
 one way or another in these aspects may influence other choices in the
 semantic aspects discussed above.
\end_layout

\begin_layout Subsection
Liveness, representation and modes
\end_layout

\begin_layout Standard
All languages from this study score either 2 or 3 in Tanimoto's liveness
 scale 
\begin_inset CommandInset citation
LatexCommand cite
key "tanimoto1990liveness"

\end_inset

.
 Recalling the meaning of each level, we have that in level 2 the visual
 representation is the executable program, and that in level 3 the visual
 representation is responsive: editing the visual representation triggers
 updates to the evaluation of the program.
\end_layout

\begin_layout Standard
Level 2 is therefore a syntactic feature: all visual languages fit this
 criterion.
 All languages presented in this work apart from the spreadsheets use box-line
 graph representations, but the (semantically significant!) spatial layout
 of a spreadsheet is also a visual representation of the program.
\end_layout

\begin_layout Standard
Level 3 refers to the lack of separate 
\begin_inset Quotes eld
\end_inset

edit
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

use
\begin_inset Quotes erd
\end_inset

 modes.
 Depending on the the language, a responsive loop may have a semantic impact
 or not: if a spreadsheet was made non-responsive, with explicit 
\begin_inset Quotes eld
\end_inset

edit
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

use
\begin_inset Quotes erd
\end_inset

 modes, that would only mean that recalculations would have to be triggered
 explicitly by a 
\begin_inset Quotes eld
\end_inset

Run
\begin_inset Quotes erd
\end_inset

 button (which would briefly send the program into 
\begin_inset Quotes eld
\end_inset

use
\begin_inset Quotes erd
\end_inset

 mode and back).
 Effectively, our interpreter from Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Spreadsheets"

\end_inset

 would be unchanged.
 For a program with long-running loops, however, adding a responsive interface
 would bring new questions about the language's behavior: what would happen
 in a responsive version of LabVIEW if graphs could gain or lose nodes and
 wires as the program runs? Our interpreter from Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:LabVIEW"

\end_inset

 would be very different.
\end_layout

\begin_layout Standard
None of the programs we analyzed implements liveness at Tanimoto's level
 4, in which the program is 
\begin_inset Quotes eld
\end_inset

responsive and live
\begin_inset Quotes erd
\end_inset

 in the sense that results update continually as the program is edited beyond
 merely reacting to the user's edits.
 Pure Data does continue to produce audio if the user switches from 
\begin_inset Quotes eld
\end_inset

use
\begin_inset Quotes erd
\end_inset

 back to 
\begin_inset Quotes eld
\end_inset

edit
\begin_inset Quotes erd
\end_inset

 mode, but the sets of actions allowed in each mode are disjoint.
 So, in that sense, it does not qualify for level 3 in terms of inputs but
 it reaches level 4 in terms of outputs.
 That may in fact indicate a shortcoming in Tanimoto's classification method.
\end_layout

\begin_layout Standard
A more useful observation may be that the applications that attain level
 3 of liveness, Excel and Blender, share some important traits in their
 semantics that make their responsiveness possible: they combine static
 dataflow with the absence of time-dependent firings and no side-effecting
 nodes.
 This allows both applications to re-evaluate subgraphs as needed and present
 the user an instant update each time they make an edit.
 
\end_layout

\begin_layout Subsection
Textual sub-language and scripting
\end_layout

\begin_layout Standard
There are two distinct aspects with regard to integration with textual languages.
 The first aspect is what we call a textual sub-language, which is a textual
 part of the UI-level language.
 As such, it is a uniquely syntactic distinction: the interpreters in Chapters
 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Pure-Data"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Spreadsheets"

\end_inset

 implement their textual parts as AST nodes that are intertwined with the
 program representation as a whole.
 The second aspect is the integration of a scripting language in the application
, reflecting the architecture described in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Background"

\end_inset

.
\end_layout

\begin_layout Standard
The textual sub-languages of Excel and Pure Data are at the forefront of
 their respective applications, and they are central to their dataflow languages
 as the dataflow languages are central to the UI as a whole.
 In line with the three-layer architecture, both applications allow for
 more advanced scripting as well.
 Excel, as part of the Microsoft Office family, integrates with Visual Basic
 for Applications.
 The vanilla package of Pure Data does not ship with a scripting engine
 by default, but it is extensible through plug-ins and there are extensions
 available that add Python and Lua scripting, the latter being available
 from the main Pure Data community site and included by default in some
 distributions of the application.
 Max/MSP is also extensible with a number of options of scripting language
 plugins, including Python, Lua, Ruby and JavaScript.
\end_layout

\begin_layout Standard
Reaktor and Blender are the only two languages to lack a textual sub-language.
 Blender integrates with textual languages at the scripting language level,
 but Reaktor presents its scripting layer as a second graphical language.
 It is notable how, in spite of avoiding textual languages, the design of
 Reaktor evolved to the same three-layer structure described in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:three-layer"

\end_inset

: Reaktor Core was introduced in 2005, adding more powerful, lower-level
 programming capabilities to the application.
 In many aspects, the semantics of the higher-level Reaktor Primary language
 resemble those of Pure Data, and the semantics of the lower-level Reaktor
 Core resemble those of LabVIEW (further fueling the discussion introduced
 in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:LabVIEW-and-PD"

\end_inset

).
\end_layout

\begin_layout Standard
LabVIEW has a somewhat blurred boundary between its textual sub-language
 and its scripting capabilities: it offers a gradient of options, starting
 from a functional 
\begin_inset Quotes eld
\end_inset

expression node
\begin_inset Quotes erd
\end_inset

 in which a single-variable mathematical expression can be entered textually;
 a 
\begin_inset Quotes eld
\end_inset

formula note
\begin_inset Quotes erd
\end_inset

 in which small imperative programs can be written in a safe subset of C,
 accessing data only via the node's input and output ports; a 
\begin_inset Quotes eld
\end_inset

script node
\begin_inset Quotes erd
\end_inset

 which accepts MathScript, a subset of MATLAB; and a 
\begin_inset Quotes eld
\end_inset

MATLAB node
\begin_inset Quotes erd
\end_inset

, which connects to an external MATLAB instance for execution.
 The latter two nodes allow for side-effects.
\end_layout

\begin_layout Section
Discussion: An architectural pattern for end-user programmable applications
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement t
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename ../proposta_hisham/scriptable_app.eps
	scale 90

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename ../proposta_hisham/scriptable_eup_app.eps
	scale 90

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "40col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\align center

\size small
(a) Scriptable application
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace smallskip
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "40col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\align center

\size small
(b) Scriptable end-user programmable application
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace smallskip
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename ../proposta_hisham/first_draft_design.eps
	scale 90

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename ../proposta_hisham/second_draft_design.eps
	scale 90

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "40col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\align center

\size small
(c) UI-level DSL provided by a dataflow engine
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace smallskip
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "40col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\align center

\size small
(d) UI-level and scripting languages with shared bindings
\end_layout

\begin_layout Plain Layout
\begin_inset VSpace smallskip
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Architectural-patterns"

\end_inset

Architectural patterns of programmable applications
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
TODO EXPANDIR
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO Fill this in
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The architecture of today's end-user programmable applications is typically
 an extension of that of scriptable applications, adding an ad hoc end-user
 language accessible via the application's interface (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Architectural-patterns"

\end_inset

(b)).
 To move past ad hoc end-user languages and get us closer to the situation
 we have in the scripting world, it is necessary to take into account the
 fact that these languages need to be fully customized to their domain.
 An approach for this is to produce a DSL on top of a reusable component,
 as we advocated in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:A-Dataflow-Engine"

\end_inset

 (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Architectural-patterns"

\end_inset

(c)).
\end_layout

\begin_layout Standard
One concern when exposing the functionality of an application as two different
 languages is a possible discontinuity in the abstractions provided (termed
 the semiotic continuum principle in 
\begin_inset CommandInset citation
LatexCommand citep
key "deSouza2001SemEngPrinciples"

\end_inset

), so that the scripting layer contains functionality that is unrepresentable
 in the UI, or vice-versa.
 
\end_layout

\begin_layout Standard
Such a possibility exists when there are different paths towards the application
 core, which may be inconsistent (as in Figures 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Architectural-patterns"

\end_inset

(b) and 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Architectural-patterns"

\end_inset

(c)).
 A way to ensure this consistency between the end-user UI-level language
 and the scripting language would be to share the application bindings,
 thus providing a single path to the application core (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Architectural-patterns"

\end_inset

(d)).
 There are interesting possibilities of how to achieve this, such as compatible
 lower-level APIs or using the scripting language to implement the dataflow
 engine.
 
\end_layout

\begin_layout Chapter
Conclusion
\begin_inset CommandInset label
LatexCommand label
name "chap:Conclusion"

\end_inset


\end_layout

\begin_layout Standard
End-user languages for UI interaction are today in the state where scripting
 languages were in the 1980s: ad hoc languages, one for each application,
 with their implementation often mixed with that of the application itself,
 and their design reflecting an organic evolution
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
In the case of scripting languages, many of those evolved out of either
 configuration files or interactive command-line prompts
\end_layout

\end_inset

.
 In the world of scripting, this has since been replaced by out-of-the-box
 implementations of widely used languages, reused among many applications,
 with their implementation clearly isolated from the application, and their
 design reflecting an evolution towards suitability for multiple domains.
 Most importantly, this notion of a 
\begin_inset Quotes eld
\end_inset

scriptable application
\begin_inset Quotes erd
\end_inset

 composed by a low-level core and a scripting language extended with bindings
 to this core has become a common architectural pattern (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Architectural-patterns"

\end_inset

(a)).
\end_layout

\begin_layout Standard
In this work, we aim to bring a similar evolution to end-user UI-level languages
 one step closer to reality, by means of two main contributions:
\end_layout

\begin_layout Description
Mapping
\begin_inset space ~
\end_inset

the
\begin_inset space ~
\end_inset

design
\begin_inset space ~
\end_inset

space
\begin_inset space ~
\end_inset

of
\begin_inset space ~
\end_inset

dataflow
\begin_inset space ~
\end_inset

end-user
\begin_inset space ~
\end_inset

languages.
 We claim that we need to have a better understanding of the state of dataflow
 languages in the context of end-user programming.
 To lower the barrier of entry for the development of programmable end-user
 applications, we believe that domain developers should be given building
 blocks for designing dataflow domain-specific languages in a coherent way.
 But first of all, we need to understand which are the building blocks they
 need, and which are the ones they are now constructing.
 In this work, we are evaluating a number of candidate end-user languages,
 and selecting among them a few representative examples, producing an in-depth
 analysis of their semantics.
 As an end result, we wish to obtain a clearer view of the design space
 of dataflow end-user languages, rooted on actual practice.
\end_layout

\begin_layout Description
And...?
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "thesis"
options "alpha"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Chapter
\start_of_appendix
Demonstration of the interpreter modeling Pure Data
\begin_inset CommandInset label
LatexCommand label
name "appendix:Pure-Data"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
input{PdInterpreter_demo.tex}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Demonstration of the spreadsheet interpreter
\begin_inset CommandInset label
LatexCommand label
name "appendix:Spreadsheet"

\end_inset


\end_layout

\begin_layout Standard
Bla
\end_layout

\begin_layout Chapter
Demonstration of the interpreter modeling LabVIEW
\begin_inset CommandInset label
LatexCommand label
name "appendix:LabVIEW"

\end_inset


\end_layout

\end_body
\end_document
